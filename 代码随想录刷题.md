# 代码随想录

## 数组

### 二分查找

704.二分查找

35.搜索插入位置
34.在排序数组中查找元素的第一个和最后一个位置
69.x 的平方根
367.有效的完全平方数

收获：

1.二分查找法如果失败的话就是应该插入的位置。

2.除2可以用右移1表示。

3.$\sqrt{x}$使用二分法搜索表示为:$k^2\le x$，即搜索最大的整数值；

4.需要注意两个int值相乘的取值范围会超过int，应该使用long long。

### 移除元素

27.移除元素

26.删除排序数组中的重复项
283.移动零
844.比较含退格的字符串
977.有序数组的平方

收获：

1.数组双指针的思路。

### 有序数组的平方

收获：

昨天自己做的思路：找到绝对值最小的位置，左右指针从中间相两边，新的数组从小到大增加元素。

作者的思路：左右指针从最左边和最右边开始，新的数组从最后开始增加大的元素。

### 长度最小的子数组

209.长度最小的子数组

904.水果成篮
76.最小覆盖子串

收获：

主要是滑动窗口的应用。

需要思考：1.窗口里面是什么；2.窗口什么时候右移；3.窗口什么时候收缩。

### 螺旋矩阵

59.螺旋矩阵II

这是一种模型行为类型的题，看上去复杂，第一次遇到。

收获：循环不变量，即在一个循环中保持不变的量，比如二分法循环中不变的是左闭右开区间或者左闭右闭区间，比如简单选择排序中不变的是前i个元素是最小的。

### 总结

作者一共介绍了四种题型和方法，分别是二分法、双指针、滑动窗口、模拟操作（循环不变量）

### 数组部分一刷回顾

数组第一种类型：查找数组元素，对于有序数组，采用二分查找法，二分查找法的关键在于确定查找区间是左闭右开开始左闭右闭，如果是左闭右开，那么循环条件就是左边界小于右边界，并且循环终止时left = right；
如果是左闭右闭，那么循环条件就是左边界<=有边界，并且循环终止时left=right+1。
跳出循环的时候，所有元素都已经比较过，并且如果查找失败跳出循环，此时的下标就应该是这个元素被插入的位置：如果是左闭右开，此时left = right，应该把从right到末尾的元素全部后移；如果是左闭右闭，那么此时left = right + 1，应该把从left到末尾的元素全部后移。

数组第二种类型：双指针法，利用快慢指针对数组进行操作



## 链表

### 删除链表元素

题目：203

收获：删除元素应该先保存链表下一个结点的信息

### 设计链表

题目：707

收获：循环的时候注意循环体执行次数和循环判断条件的关系。

### 翻转链表

题目：206

思路就是使用双指针，值得注意的点就是注意删除操作顺序。

收获：重复的操作可以使用递归实现，，即不断对于两个结点进行翻转。

另一种形式的递归：每次都先翻转后面的链表，后面链表翻转完成之后再进行当前结点的翻转，注意这个递归返回的是最后一个节点值。

栈的思路：遍历一遍链表然后入栈，之后出栈即可。

或者采用头插法。

### 两两交换链表中的结点

题目：24

思路：使用双或者三指针，只需要注意更改next的顺序即可。

### 删除链表中的倒数第n个结点

题目：19

思路：第一个指针先走n步，接着第二个指针跟着第一个结点一起走到尾，就会指向第len-n+1也就是倒数第n个结点。

这题是删除倒数第n个，所以稍有变动。

并且虚拟头结点的好处就是对于第一个结点的操作与其他结点一样，没有虚拟头节点对于头结点的操作需要单独处理。

### 链表相交

题目160

思路：1.将链表A+链表B   链表B+链表A，使用两个指针遍历这两个链表，如果存在相交结点，那么一定相遇在空结点之前。

2.链表A+链表B，判断是否存在循环

作者的思路：求两个链表长度，总之与思路1一样

### 环形链表

题目：142

主要思路：1.使用快慢指针寻找相遇点；2.当第一次相遇时，令其中一个指针指向头结点，两个指针同速前进，再次相遇点就是环的起点。

有三个点：头结点、环的起点、相遇点，相遇点一定在环的起点之后（没到环的起点怎么相遇）。

假设相遇点时slow走了k，那么fast一定走了2k，也就是k一定是环的长度的n倍。

假设相遇点距离环的起点的距离为m，那么环的起点点距离头结点的距离为k-m；即从头结点走k-m到达环的起点。

假如从相遇点开始走，走k一定是重新到达相遇点，那么走k-m是到环的起点。

### 总结

链表的基础操作（删除、插入等）、双指针技巧、删除链表的元素可以删除该结点的后一个元素、环型链表的处理



## 哈希表

主要用于需要判断一个元素是否存在一个数组中时。

### 有效的字母异位词

242.有效的字母异位词

383.赎金信

49.字母异位词分组

438.找到字符串中所有字母异位词

收获：hash表（map）的键值可以是任何东西。比如49题中把string作为键，把列表作为值。

438复习了滑动窗口的使用。



### 两个数组的交集

349.两个数组的交集

350.两个数组的交集 II

收获：主要是set和map的使用，其中set好像更慢一点。

### 快乐数

第202题. 快乐数

收获：学会使用unorder_set

### 两数之和

第1题：两数之和

收获：

- 为什么会想到用哈希表：当需要判断一个元素是否存在时
- 哈希表为什么用map：因为数组的下标只能是int，set没有下标，map用于存一个映射。
- 本题map是用来存什么的：key存target - nums1（第一个加数） value存这个数对应的下标
- map中的key和value用来存什么的

### 四数相加

第454题：

收获：要找的是加数 + 加数 + 加数 + 加数 = 0出现的次数，因此map的key应该是加数，value是出现的次数。

### 赎金信

第383

收获：之前做过，这里由于hash表的长度是固定的（26个小写字母），所以使用数组更加合适。**map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的**

### 三数之和

第15

对于自己来说难以理解：1.hash思路有，但是由于题目中要求不能重复，难以完成。（待完成）

2.使用双指针，先把数组排序，然后需要注意的是：（1）.去重的逻辑：去重a：应该判断与之前的元素是否相同，由于是排序之后的，如果相同说明要么都找不到，要么找到也是重复的；去重bc，在找到第一对bc之后，应该重复判断与他们相邻的是否相等，相等就应该去重。（2）.找到之后两个指针同时跳变

### 四数之和

18

思路：就是在三数之和的基础上加层循环

但是需要注意的是：剪枝的一些细节，比如由于target是一个随机值，不能判断第一个元素大于零就直接返回，因为有可能target是小于第一个元素的。

错误：我的思路是两个双指针，错误的地方是：外层如果用双指针，那么当双指针同时增加时，会漏掉什么元素？？？

这个问题与之前遇到的同时增加的

思考：我的思路：从外层选两个，从内层选两个，

作者的思路：从n个中选一个，从剩下的n-1个中选一个，然后双指针选择剩下的两个

注意：两种方式：（1）从n中选一个，从剩下的n-1中选一个，一共有n(n-1)/2中组合

（2）我的两个指针同时从前后增加，那么只有n/2种组合

而题目明显是要求第一种方式选择，不要漏掉组合。

注意：双指针是如何把从n中选两个的时间复杂度变成n的？

（1）从n中选两个不同的，正常思路就是n的平方；

（2）如果采用双指针，O(n^2)的解法优化为 O(n)的解法，因为一次选中不同的两个？

### 总结

**一般来说哈希表都是用来快速判断一个元素是否出现集合里**。

哈希函数是把传入的key映射到符号表的索引上。

接下来是常见的三种哈希结构：

- 数组
- set（集合）
- map（映射）

**使用set的理由：**

**主要因为如下两点：**

- 数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。
- 如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

**使用map的理由：**

- 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
- set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。

C++提供如下三种map：

- std::map
- std::multimap
- std::unordered_map

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

std::unordered_map 底层实现为哈希，std::map 和std::multimap 的底层实现是红黑树。

在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。

虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。

同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解），[1.两数之和 (opens new window)](https://programmercarl.com/0001.两数之和.html)中并不需要key有序，选择std::unordered_map 效率更高！

## 字符串

**如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。**

### 反转字符串1

题目：第344题

思路：双指针

### 反转字符串2

题目：第341

我的思路：每次取前2k个，用i=1，2，3去乘2k

作者的思路：直接取每个区间的起点，i=0， 2k，

然后在循环中判断i + k是否超过最后字符串结尾即可。

### 替换空格

剑指Offer 05.替换空格

思路：**其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

这么做有两个好处：

1. 不用申请新数组。
2. 从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。

### 151.翻转字符串里的单词

思路1：保存每个字符串并存入栈结构，最后再出栈，这样存储空间是O(n)

思路2：去除多余的空格、翻转整个字符串、翻转单个字符串，存储空间是O(1)

### 左旋转字符串

题目：剑指Offer58-II.左旋转字符串

思路：（原地修改）旋转整个字符串、旋转左半字符串、旋转右半字符串

### 旋转字符串回顾

此时我们已经反转好多次字符串了，来一起回顾一下吧。

在这篇文章344.反转字符串 ，第一次讲到反转一个字符串应该怎么做，使用了双指针法。

然后发现541. 反转字符串II ，这里开始给反转加上了一些条件，当需要固定规律一段一段去处理字符串的时候，要想想在for循环的表达式上做做文章。

后来在151.翻转字符串里的单词 中，要对一句话里的单词顺序进行反转，发现先整体反转再局部反转 是一个很妙的思路。

最后再讲到本题，本题则是先局部反转再 整体反转，与151.翻转字符串里的单词 类似，但是也是一种新的思路。

### 实现KMP算法

复习KMP算法，和作者的不一样

主要是理解思路

### 重复的子字符串

题目：第459题

思路1：O(n^2)，字串的长度一定是s的整数倍，并且假设字串长度为i，那么任意的j > i，都有s[j] == s[j - i]

思路2：利用两个s拼接在一起，一定能从中间找到s，因为如果是由重复字符串构成的话，中间的一部分一定是s。但是不能两端找到字串s，因为就是由两个s组成的。

时间复杂度为KMP算法O(m+n)，空间复杂度为O(n)

思路3：在由重复子串组成的字符串中，最长相等前后缀不包含的子串就是最小重复子串

KMP算法的next数组其实就是最长前缀和最长后缀的概念，只不过我在实现的时候是求不包括当前字符的前缀长度

前缀和后缀的概念：

前缀：是指不包含最后一个字符的所有以第一个字符开头的连续子串

后缀：是指不包含第一个字符的所有以最后一个字符结尾的连续子串

作者求的是当前字符的前后缀长度，与我不同，所以作者遇到当前字符不同时，需要查找前一个字符的next值，我要找当前字符的next值，其实是一样的.

只不过作者引入了-1，我不想看了。

### 总结

双指针法、翻转再翻转、KMP

## 栈与队列

### 用栈实现队列

题目：232

思路：栈1用于输入，当输出时需要将所有元素入栈2，这样栈1的栈底元素就是栈2的栈顶元素。

收获：peek用到了pop函数，即实现了代码复用。

在代码开发时一定要注意复用，忌讳实现类似的函数，即把一段代码复制粘贴稍微修改。



### 使用队列实现栈

题目：225

思路1：哪个队列不为空就入哪个队列（如果都为空随便入）；出队就是将有元素的队列的前面所有元素入另一个队列，最后一个元素为出队元素

收获：作者提供使用一个队列的思路，即每次出队时候都再次入队。

### 有效的括号

题目：20.有效的括号

思路：使用栈完成匹配

### 删除字符串中的所有相邻重复项

题目：1047

思路：使用栈完成匹配

收获：1.string的构造函数，并且string的长度不计算空字符

2.**递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中**，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。

**在企业项目开发中，尽量不要使用递归**！在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），**造成栈溢出错误（这种问题还不好排查！）**

### 逆波兰表达式求值

题目：150

思路：使用栈存储数据，当遇到运算符时就出栈两个元素并将结果入栈。

收获：1.**逆波兰表达式相当于是二叉树中的后序遍历**。 大家可以把运算符作为中间节点，按照后序遍历的规则画出一个二叉树。

2.stoi、stol、stoll函数：在头文件string中，将字符串转换为int、long、long long类型的整数。

int stoi(const std::string& str, std::size_t* pos = 0, int base = 10);

注意默认base是10。

### 滑动窗口最大值

题目：239. 滑动窗口最大值

思路：我原本的思路是使用一个队列保存窗口元素，因为要求当前队列最大值，所以需要对队列进行排序，但是排序之后就无法按照原始顺序弹出元素。

收获：

1.作者给出的思路是：并不需要保持所有元素，而是保持一个单调队列，即还是按照原始顺序，但是保持最大元素在队列头，并且按照单调递减的顺序保留数据，删除其他元素。这样保持一个单调队列，push和pop方法改为：

1.pop(value):如果要弹出的元素不是头元素，那么队列不做任何操作

2.push(value):入队时与队尾元素相比，如果队尾更小，就从队尾弹出元素，保持是一个单调的状态。并且从队尾进页保持了原始顺序。

这个队列是按照原始顺序进队和出队的，只是由于最大值不同队列内元素个数不同。

2.了解双端队列dequeue

### 前 K 个高频元素

题目：347.前 K 个高频元素

收获：1.优先级队列表示大顶堆、小顶堆

2.使用小顶堆删除最小的，保留下来的就是k个最大的。

### 总结

在栈与队列系列中，我们强调栈与队列的基础，也是很多同学容易忽视的点。

使用抽象程度越高的语言，越容易忽视其底层实现，而C++相对来说是比较接近底层的语言。

我们用栈实现队列，用队列实现栈来掌握的栈与队列的基本操作。

接着，通过括号匹配问题、字符串去重问题、逆波兰表达式问题来系统讲解了栈在系统中的应用，以及使用技巧。

通过求滑动窗口最大值，以及前K个高频元素介绍了两种队列：单调队列和优先级队列，这是特殊场景解决问题的利器，是一定要掌握的。

## 二叉树

### 二叉树简介

满二叉树、完全二叉树、二叉查找树（搜索树）、平衡二叉搜索树

**二叉搜索树是一个有序树**。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

二叉树存储结构：顺序存储（如果双亲结点是i那么左孩子是2\*i + 1，右孩子是2\*i + 2)和链式存储

题目：2两数相加

思路：模拟加法进位

### 二叉树递归遍历

递归的方法：

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

144.二叉树的前序遍历(opens new window)
145.二叉树的后序遍历(opens new window)
94.二叉树的中序遍历

### 二叉树迭代遍历

前序遍历：使用栈实现

前序处理的方式是：根、左、右，因此向将根节点放入栈、右孩子进入栈、最后左孩子进入栈

**访问和处理的顺序是一致的。**前序遍历的访问顺序是中左右，处理的顺序也是中左右。

```
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // 中
            st.pop();
            result.push_back(node->val);
            if (node->right) st.push(node->right);           // 右（空节点不入栈）
            if (node->left) st.push(node->left);             // 左（空节点不入栈）
        }
        return result;
    }
};
```

中序遍历：处理顺序是中左右，但是访问顺序是一直访问到左孩子结点为空时才会访问中结点，接着以右孩子作为新的根结点。

因此借助指针来访问，使用栈处理。

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```

后序遍历：

将前序遍历稍微修改：前序遍历是中左右->中右左->逆序->左右中

即逆序。

```
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->right) st.push(node->right); // 空节点不入栈
        }
        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
        return result;
    }
};
```

### 二叉树统一迭代法

以中序遍历为例，**将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**要处理的结点放入栈之后，需要加上一个空结点。

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode *> st;
        vector<int> res;

        // 根节入栈
        if (root != nullptr) st.push(root);

        while (!st.empty()) {
            TreeNode *node = st.top();

            if (node != nullptr) {
                // 先将这个结点弹出
                st.pop();

                // 尝试将右孩子入栈
                if (node->right != nullptr) st.push(node->right);
                // 将中结点入栈，并且中间结点已经访问过，作为下一次处理的结点需要标记
                st.push(node);
                st.push(nullptr);

                // 最后将左孩子入栈但是不标记
                if (node->left != nullptr) st.push(node->left);
            } else {
                // 如果栈顶是空指针，说明下一个是需要处理的结点
                st.pop();

                // 将需要处理的结点假如列表
                res.push_back(st.top()->val);
                st.pop();
            }
        }

        return res;
    }
};
```

前序遍历和后序遍历只需要改变左右孩子、中间结点进入栈的顺序即可。

### 二叉树层序遍历

思路1：我的思路是为每层后面加一个空结点标识，当遇到空结点说明上一层处理完了，同时也要在队列中加一个空结点标识现在队列中是一层。

作者的思路1：当队列不为空时，每次处理一层，使在每次循环最开始记录当前队列多少元素，即为当前层数。然后使用for循环处理这size个结点即可。

作者的思路2：使用深度优先遍历，递归的方式，每次处理完根节点之后，接着递归处理左右孩子。

递归参数：当前根结点，保存访问记录的列表，当前深度（因为一层使用一个列表表示，因此需要知道当前深度应该加到哪个列表中）

递归终止条件：当前根结点为空

一层递归逻辑：处理当前根结点，接着处理左右孩子。

题目：

102.二叉树的层序遍历
107.二叉树的层次遍历II
199.二叉树的右视图

20230526：

637.二叉树的层平均值
429.N叉树的层序遍历
515.在每个树行中找最大值

20230527：

116.填充每个节点的下一个右侧节点指针
117.填充每个节点的下一个右侧节点指针II
104.二叉树的最大深度
111.二叉树的最小深度

### 翻转二叉树

题目：226

这道题思路很简单：遍历左右结点，把节点的左右孩子互换即可。我使用的是层序遍历

作者提出前、后序都可以，唯独中序遍历不可。

为什么中序遍历不行：画一下图就可以了。

注意，递归中序不可以，但是迭代中序可以。

**复习**：递归遍历（前中后）、迭代遍历的统一写法

递归遍历的前序遍历又称为深度优先遍历，层序遍历称为广度优先遍历

有时间都写一下。

### 阶段总结

二叉树基本概念

二叉树前中后递归遍历

二叉树前中后迭代遍历：由于中序遍历的访问和处理是不一致的（总是先访问到中间结点，才会访问左右孩子，但是处理的时候是先处理左孩子，再处理中间结点），所以需要一个标志（标识应该被处理）。后序遍历就是前序遍历稍微修改一下：中左右->中右左 这样范围访问之后再逆序即可。

二叉树前中后统一迭代遍历方法

二叉树层序遍历

589.N叉树的前序遍历(opens new window)

590.N叉树的后序遍历

### 对称二叉树

101.对称二叉树

思路：不是比较左右结点，而是比较左右子树的外侧和里侧，这样左子树的左孩子与右子树的右孩子比较，左子树的右孩子与右子树的左孩子比较。

递归的方式：

1.递归返回值和参数：参数为两个结点，返回值是bool

2.递归终止条件：这两个结点存在空结点的情况和不存在空结点的情况

3.递归的逻辑：首先排除空间结点情况和均不是空结点但是不相等的情况，剩下的就是两个结点都不为空并且相等。接着外侧和里侧进行比较。



思路2：使用队列，队列里面的前两个结点是要比较的两个结点。

思路3：使用栈也是一样的。

题目：

100.相同的树
572.另一个树的子树

### 二叉树的最大深度

题目：104、559

思路1：递归法

思路2：迭代法（使用层序遍历比较简单）

收获：

本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。

- 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）

**根节点的高度就是二叉树的最大深度**

### 二叉树的最小深度

题目：111

思路问题：

这就重新审题了，题目中说的是：**最小深度是从根节点到最近叶子节点的最短路径上的节点数量。**，注意是**叶子节点**。

什么是叶子节点，左右孩子都为空的节点才是叶子节点！

如果采用以下递归逻辑：

```
int leftDepth = getDepth(node->left);
int rightDepth = getDepth(node->right);
int result = 1 + min(leftDepth, rightDepth);
return result;
```

那么如果一个结点没有左孩子，那么没有左孩子的分支就会作为最小深度。

正确逻辑应该是：

如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度。

反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。

 最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。

思路2：使用迭代方式的层序遍历。只要遇到左右孩子为空的就输出深度。

### 完全二叉树的节点个数

题目：222

思路：采用层序遍历统一每一层的结点个数。

思路2：还是采用普通二叉树遍历方法，不过采用递归的思路。

作者的思路：采用二叉树的思路：需要判断是否为满二叉树（根据左右结点深度是否一致）

如果是满二叉树，就根据公式计算这个完全二叉树的结点数并返回；

如果不是满二叉树，那就接着遍历返回左右子树的结点数之和+根节点的数量1

### 平衡二叉树

题目：110

明确概念：

- 二叉树节点的深度：指从**根节点**到**该节点**的最长简单路径边的条数。
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。

因为求深度可以从上到下去查 所以需要**前序遍历**（中左右），而高度只能从下到上去查，所以只能**后序遍历**（左右中）

在题目求二叉树**最大深度**时采用的是后序遍历，求的是根节点的高度，也就是高度。

平衡二叉树就是左右子树高度不能相差1

因此采用后序遍历。

参数即返回值：参数是一个子树根结点，返回值是子树高度，如果不是平衡子树就返回-1

终止：当遇到空结点时。

逻辑：

求左右子树高度，注意这里如果子树高度为-1，说明子树不是平衡的，那么以这个根节点的树也不是平衡的。

判断左右子树高度是否相差1以内。



20230606：

103：求最大深度使用前序遍历实现



思路2：迭代法：使用一个函数计算当前节点的深度，然后使用后序遍历判断每个节点的左右子树深度是否一致。





### 二叉树的所有路径

题目：257. 二叉树的所有路径

思路：采用前序遍历，使用递归的形式

递归参数：当前根结点、当前路径、装结果

递归终止：当当前结点左右孩子都为空时，将当前路径转换为string保存在结果中。

每一层递归逻辑：先将当前根节点加入路径、然后尝试对当前节点的左右孩子递归，注意递归返回时要回溯，即从路径中弹出左右孩子。



思路2：使用递归，一个栈用于模拟前序遍历，一个栈用于装从根结点到当前节点的路径。

### 总结

对称二叉树：递归比较两个子树的外侧和内侧

二叉树最大深度：深度指的是从根节点到当前节点的结点个数（适合使用前序遍历，因为首先处理处理当前结点深度），高度指的是从当前结点到叶子结点的结点个数（适合后序遍历，先处理子树的高度再处理根的高度）

二叉树最小深度：需要注意的是深度指的是到叶子结点，即左右孩子结点都为空。

完全二叉树结点数量：采用递归方式，如果是满二叉树，即左右孩子深度一样，就利用公式计算，否则就统计左右孩子加上根节点。

是否为平衡二叉树：递归求左右孩子的高度，判断是否相差1

找寻所有路径：前序遍历递归





### 左叶子之和

题目：404

我的思路：采用前序递归遍历
递归参数为当前子树根节点和保存和的变量，无返回值

递归终止条件为：当前子树根节点为空

递归逻辑：先判断当前子树根节点是否存在左孩子（左孩子指的是左结点并且左结点没有孩子），有就求和

接着递归遍历子树根节点的左右孩子子树。

这里体现了处理和访问的关系。

我的思路2：讲递归遍历换为迭代遍历。

作者：

**节点A的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么A节点的左孩子为左叶子节点**

那么**判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。**

作者改进：

终止条件多了一个：

```
if (root->left == NULL && root->right== NULL) return 0; //其实这个也可以不写，如果不写不影响结果，但就会让递归多进行了一层。
```

即如果这个结点本身就是一个叶子结点，那么不用判断了，因为没有左结点。

### 找树左下角的值

题目：513

我的思路：采用层序遍历，保存每一层最左边的节点的值，当层序遍历完成也就是最底层最左边的值。

作者递归的方法：最左下角要求深度必须是最大的，采用递归时需要记录此时的深度。采用前序遍历访问。

需要全局变量：1.最大深度；2.最大深度最左节点的值

递归参数：当前根节点，当前深度，无返回值

递归终止条件：遇到叶子结点，终止条件需要判断当前是否为最大深度，并且更新最大深度，这里必须时大于最大深度才更新全局节点值，保证保存的是最左。

递归处理逻辑：递归遍历左右孩子。注意需要回溯。

### 路径总和

题目：112

我的思路：采用迭代遍历，但是如果使用一个变量记录到一个叶子节点的路径之和，遇到的问题是回溯。如果一个分支结点只有左孩子没有右孩子，并且到这个左孩子的路径之和不能满足要求，那么回溯的时候需要回溯两次。

作者给出的解决方案是栈中保存结点和到这个结点的路径之和。

作者的思路1：采用递归的方式

递归的参数：当前结点，以及一个计数，初始化为目标值，返回值为true或者false

递归的终止条件：遇到叶子结点，此时需要判断计数值是否为0，为0说明找到了一条路径，直接返回true，否咋返回false

递归单层逻辑：分别处理右左孩子



递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先 (opens new window)中介绍）
如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）



题目 113

思路：采用递归，不过不需要返回。

这里遇到的问题是，注意在本层处理路径的回溯，那么返回曾就不需要再处理回溯。

### 从中序与后序遍历序列构造二叉树

- 106.从中序与后序遍历序列构造二叉树

- 105.从前序与中序遍历序列构造二叉树

  我的思路与作者思路基本一致：递归

  递归的参数：前序列表和后序列表，返回值是构建的树的根节点

  递归的终止条件是两个列表都为空（返回空结点）和都为1（返回一个结点构成的树）

  递归的处理逻辑是：根据前序或者后序找到根节点，将中序分成左右子树，递归构建左右子树。

### 最大二叉树

题目：654

思路：采用递归的方式
递归参数：列表，用于本次构建的列表的左、右边界；返回值：构建的树的根节点
递归终点：左右边界中间个数为0（返回空结点）或者中间个数为1（返回单个结点）
每一层递归逻辑：找到最大值，确定左子树和右子树的列表边界，分别递归。

### 总结

左叶子之和：判断一个左叶子必须根据一个根结点来判断，必须是一个左孩子并且自己没有孩子

左下角的值：采用层序很好理解；递归时需要采用一个变量记录最大深度，第一次到达最大深度时并且为叶子结点就是最左。

路径总和：

中序遍历和后序遍历、中序遍历和前序遍历：

最大二叉树



### 合并二叉树

题目617

想不出来。

作者的思路1：递归的参数：两棵树 返回值：合并到子树的根节点；

递归终止条件：如果第一棵树为空就返回第二课；如果第二课树为空就返回第一颗

递归逻辑：此时两个数的根节点都不为空，因此根节点值相加赋给第一课树

接着第一颗树的左孩子等于，第一颗树的左孩子与第二棵树的左孩子组成新的树；

有孩子也一样。

作者的思路2：采用迭代法，适用队列模拟层序遍历，比较队列前两个结点。

首先排除两棵树都为空的情况，进入队列之后就是队列前两个结点不为空，因此将两个结点相加，值赋给第一个结点。

然后如果两个结点的左孩子都不为空就都入队，右孩子都不为空就都入队。

接着如果第一颗数左孩子为空，但是第二棵树左孩子不为空，那么第一个课树的左孩子就是第二棵树的左孩子。

第一棵树的右孩子如果为空就是第二课树的右孩子。

### 搜索二叉树中的搜索

思路1：采用递归的方式
递归的参数为：子树根节点，目标值；递归的返回值：目标结点
递归的终止：当前根节点为空（返回为空）或者当前结点值为目标值（返回当前节点）
递归逻辑：注意，因为是二叉搜索树，因此左子树的节点的值一定比根结点小，右子树的节点的值一定比根节点大，因此可以根据val与根节点的值的比较情况选择向左还是右子树递归搜索。

思路2：采用迭代的方式，**一提到二叉树遍历的迭代法，可能立刻想起使用栈来模拟深度遍历，使用队列来模拟广度遍历。**但是因为二叉树搜索树是有顺序的，所以直接根据值判断需要放的结点是左子树还是右子树即可。

### 验证二叉搜索树

思路1：**二叉搜索树是有序的，采用中序遍历一定会产生一个有序序列。**因此可以中序遍历生成数组，判断数组是否为递增的。

思路2：将思路1改为递归。使用一个全局变量记录上一次的值，上一次的值必须小于中间的值。

递归参数：当前根节点 递归返回值：true 或者false

递归终止：空结点时

递归逻辑：先递归判断左子树是否为二叉搜索树，此时会更新上一次的值；接着判断当前根节点的值是否大于上一次次的值；最后判断右子树是否为二叉搜索树。

思路3：采用迭代法，判断标准与上面一一致。

### 二叉搜索树的最小绝对差

题目：530

思路：二叉搜索树就是有序数组

收获：当初始值不好赋值时，可以使用指针，将指针初始化为空，当空指针时就知道这是第一次操作。

### 二叉搜索树中的众数

题目：501

思路1：递归，需要全局变量，一个max_count记录最大频率，一个pre_node记录上一个结点（主要是为了记住值），一个count记录上个节点的值出现的次数
递归的参数为：当前子树根结点；无返回值
递归的终止：当遇到空结点时
递归的逻辑：先递归处理左子树，最后递归处理右子树，对于当前根节点的处理在中间（中序遍历），中间的处理逻辑为：如果上一个结点为空指针，说明这是第一次；如果当前根节点的值不等于上一个节点的值，则更新当前频率为1 
然后更新pre_node为当前根节点
最后根据次数更新结果数组：如果count==max_count则需要把当前值加进去；如果大于则之前的结果数组里面的值都作废，只添加当前值；如果小于什么都不做。

思路2：采用迭代法。逻辑一样。



收获：如果不是二叉搜索树，那么就需要遍历整个树，把每个值对应的频数记录
这里是二叉树，所以相等的值一定是连续出现的，因此只要相等就可以频数加1，另外需要记录一个最大频数（如果不记录，那就需要首先遍历一次二叉树，将所有数值的频数记录，再进行一个遍历，找到最大频数）。根据最大频数和当前频数进行更新。

### 二叉树的最近公共祖先

题目236

我的思路：从上到下遍历每个结点，判断当前结点是否为两个目标节点的祖先（即分别判断两个目标结点是否在以当前节点为根节点的子树中），如果是祖先，那么就根据深度判断是否更新最近祖先。

作者的思路：采用回溯法，后序遍历是天然的回溯，先处理左右孩子再根据返回值处理根节点。

递归参数：当前根节点，两个目标结点 递归返回值：结点
递归终止：遇到空的根结点（返回空），或者当前根节点就是其中一个目标结点（返回根节点）
递归逻辑：需要接收左子树和右子树的返回结果，如果都不为空，那么说明当前根节点就是最近的祖先；如果其中一个为空，那么就返回另一个，因为表示在其中一个子树中有目标结点，返回给上一层处理；如果都为空说明没有找到，返回空。

收获：判断递归需不需要返回值的逻辑：

如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？

搜索一条边的写法：

```cpp
if (递归函数(root->left)) return ;

if (递归函数(root->right)) return ;
```

搜索整个树写法：

```cpp
left = 递归函数(root->left);  // 左
right = 递归函数(root->right); // 右
left与right的逻辑处理;         // 中 
```

**在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）**。

### 总结

合并两个二叉树：一起操作两个树

搜索二叉树：利用搜索二叉树的有序性，利用中序遍历将搜索二叉树看作是一个有序数组

判断一个二叉树是否为搜索二叉树：即判断一个二叉树在中序遍历下是否满足递增顺序

二叉搜索树的最小绝对差：也是利用二叉搜索树的有序性，需要注意的是初始化不好赋值时可以利用指针，因为空指针可以作为一个标志来使用

二叉搜索树中的众数

求二叉树的公共祖先：利用回溯到方法从底向上遍历

### 二叉搜索树的最近公共祖先

题目：235

关键：如果当前根节点的值位于p与q之间，说明刚好就是公共祖先。是否为最近公共祖先？如果向左子树继续搜索，那么一定不是q（假设为区间右边界）的祖先，同理对于右子树。

可以采用递归或者迭代的方法。

### 二叉搜索树的插入

思路1：递归
递归的参数：当前根节点，需要插入的结点的值  递归的返回值：无
递归的终止条件：隐含在逻辑中
递归逻辑：首先根据当前根节点的值判断应该插入左子树还是右子树；如果在左子树，先判断当前是有左孩子，如果没有左孩子就把这个值当作左孩子（这也就是终止体条件），如果有左孩子那么继续向左孩子递归；如果在右子树也是一样的处理。

思路2：采用迭代法，处理逻辑相同

### 二叉搜索树的删除

题目：450

找到目标结点之后的处理逻辑：
判断：1.如果左右孩子都为空（即叶子结点）则直接删除该结点，需要一个全局变量记录前一个结点
2.如果其中一个不为空，则让父结点继承这个结点；
3.如果两个都不为空，由于二叉搜索树的性质，这个目标节点的左子树全部结点都小于右子树，所以就可以作为右子树最左节点的子树。

遍历方式：递归和迭代。

作者的思路与我一致。

收获：普通二叉树的删除方式：代码中目标节点（要删除的节点）被操作了两次：

- 第一次是和目标节点的右子树最左面节点交换。

- 第二次直接被NULL覆盖了。

  ```c++
  class Solution {
  public:
      TreeNode* deleteNode(TreeNode* root, int key) {
          if (root == nullptr) return root;
          if (root->val == key) {
              if (root->right == nullptr) { // 这里第二次操作目标值：最终删除的作用
                  return root->left;
              }
              TreeNode *cur = root->right;
              while (cur->left) {
                  cur = cur->left;
              }
              swap(root->val, cur->val); // 这里第一次操作目标值：交换目标值其右子树最左面节点。
          }
          root->left = deleteNode(root->left, key);
          root->right = deleteNode(root->right, key);
          return root;
      }
  };
  ```

  ### 二叉搜索树的修剪
  
  题目：669
  
  思路1：递归的参数：当前根结点，左右边界  **返回值：修建完成的子树**
  递归终止：遇到空结点
  递归逻辑：如果当前结点小于边界，那么递归返回这个结点的右子树；如果当前结点大于边界，那么递归但会这个节点的左子树；如果在边界里面，当前结点的左子树等于递归处理的左子树的结果，右子树等于递归处理的右子树的结果
  
  删除过程就是返回时不返回当前结点，如果不删除就是修改当前结点的左右孩子。
  
  思路2：迭代：第一步是找到一个根节点在范围里面（以这个根节点作为最终的根节点）
  第二步是修剪左子树：修建过程双重循环，内部循环是找到一个大于最低边界的结点（如果左子树小于最低边界，那么就让当前根的左子树为左子树的右孩子），外层循环是不断重复使得左子树大于最低边界。
  
  第三步是修剪右子树。

### 将有序数组换转为二叉搜索树

题目：108

思路1：递归，将数组等分为左右两部分，中间作为根节点，左右子树个数相同，高度差就不会超过1
递归的参数：数组，用于构建子树的下界和上界[low,high)；递归的返回值：构建完成的子树
递归的终止：上界等于下界
递归的逻辑：首先找到中间的下标mid，使用nums[mid]创建根节点，然后使用[low,mid)和[mid+1,high)递归构建左子树和右子树；最后返回当前根节点。

思路2：使用迭代方法，每次循环都是创建一个新的结点，然分别以左右区间再次循环。
作者给出的思路是：先创建左孩子和右孩子（如果区间存在的话），然后留到下一次循环时更新（先存入队列），同时也罢相应的左右区间保存到左区间和右区间队列中。

### 把二叉搜索树转换为累加树

题目：538

我的思路：首先求出整棵树的总和，然后采用中序遍历，中间节点的值等于总和不断减去前一个遍历的节点的值（注意sum累减）

作者的思路：采用逆序操作，中序遍历时采用右中左的顺序，然后当前结点加上上一次遍历的结点的值。

采用迭代法就是我的思路中的逆中序遍历，但是只需要一次中序遍历。

采用递归法：递归参数：当前根节点 递归返回值：无
递归终止条件：遇到空结点
递归处理逻辑：先处理右子树，然后处理当前根节点，最后处理左子树。处理当前根节点的逻辑为：如果前一个结点的指针不为空就累加，然后更新pre指针为当前结点。

**收获：**逆序和正序，sum-nums[i]是顺序遍历（i从0开始），刚好是后面所有元素的和，所以使用逆序比较方便。

### 二叉树总结

- 涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。
- 求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。
- 求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。

注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序，[二叉树：找所有路径 (opens new window)](https://programmercarl.com/0257.二叉树的所有路径.html)也用了前序，这是为了方便让父节点指向子节点。

所以求普通二叉树的属性还是要具体问题具体分析。

我的总结就是，对于二叉树，最重要的是基本遍历方法（分为递归和迭代法），所有对于二叉树的处理都是在遍历的基础上实现的。即遍历顺序和处理顺序是息息相关的。

另外就是要注意二叉树的一些性质，利用性质解决问题。

## 回溯

### 回溯的基本理论

回溯是递归的产物。

回溯相当于穷举搜索。

回溯主要解决的问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

回溯算法抽象为树形结构，回溯法解决的是在集合中递归寻找子集，集合的大小构成树的宽度，递归的深度就是树的深度。

**回溯算法模板：**

- 回溯算法的返回值以及参数：返回值一般为void，但是参数需要根据逻辑来定。

  ```c++
  void backtracking(参数)
  ```

- 回溯算法终止条件：由于是树形结构，所以一般是搜索到叶子节点了，也就找到了满足条件的一个答案，将答案存储起来，结束本次递归。

  ```c++
  if (终止条件) {
      存放结果;
      return;
  }
  ```

- 回溯搜索的遍历过程：在集合中搜索，集合的大小就是树的宽度，递归的深度就是树的深度
  <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png" alt="回溯算法理论基础" style="zoom:80%;" />

  ```c++
  for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
      处理节点;
      backtracking(路径，选择列表); // 递归
      回溯，撤销处理结果
  }
  ```

  for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。

  backtracking这里自己调用自己，实现递归。

  大家可以从图中看出**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。

### 组合问题

题目：77

思路：

![77.组合1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195242899.png)

需要两个全局变量，一个表示所有组合的答案，一个表示当前组合。

回溯参数：集合、k值、集合的起点
回溯终止：当当前组合数目达到k值时
回溯逻辑：循环遍历集合中从集合起点开始的集合元素，将其添加进当前组合，然后继续backtracing，因为函数会处理满足要求的组合，函数返回之后从当前组合中删除刚刚加进去的元素（回溯）。

```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```



### **剪枝优化**

以n=4，k=4为例：
![77.组合4](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130194335207-20230310134409532.png)

图中每一个节点（图中为矩形），就代表本层的一个for循环，那么每一层的for循环从第二个数开始遍历的话，都没有意义，都是无效遍历。

**所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置**。

**如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了**。

注意代码中i，就是for循环里选择的起始位置。

接下来看一下优化过程如下：

1. 已经选择的元素个数：path.size();
2. 还需要的元素个数为: k - path.size();
3. 在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历

为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。



### 组合总和III

题目：216

思路：与上面一致。



剪枝优化：

当path里面的总和大于n时，就可以不用再循环了。

### 电话号码的字母组合

题目：17

思路：想想回溯的宽度就是集合的大小，回溯的深度就是数字字符串的长度，每一层回溯的集合就是这一层数字对应的字符串集合。

使用成员变量保存的：1.最终答案；2.回溯路径；3.数字对应的字符串集合

回溯参数：最终path长度、数字字符串、数字字符串下标
回溯终止：当路径达到最终长度
回溯逻辑：取出本层数字对应的字符串，遍历字符串，尝试将每一个字符加到path结尾，然后进行递归。

优化：参数中最终path的长度就是数字字符串的长度，所以不用传递。

### 回溯总结

回溯就是暴力搜索。

回溯算法的整体思想：看作是对于树结构的操作，**for循环横向遍历，递归纵向遍历，回溯不断调整结果集**。

回溯算法剪枝：**for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够 题目要求的k个元素了，就没有必要搜索了**。

### 组合总和

题目：第39题

思路：回溯的参数：待选集合、目标值、起点
回溯的终止：当path总和大于或者等于target时
回溯的逻辑：注意待选集合中的元素可以重复利用，所以起点每次递归时不用加1

剪枝：先对待选集合进行升序排列，那么当出现加上一个集合中的元素超过target时就可以直接终止本层循环（横向）。

### 组合总和II

题目：40题

遇上一题思路类似：关键是去重，这里集合里的元素是会有重复的，**所谓去重，其实就是使用过的元素不能重复选取**。

回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。

**所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重**。

**强调一下，树层去重的话，需要对数组排序！**

![40.组合总和II](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000918.png)

要去重的是“同一树层上的使用过”，如何判断同一树层上元素（相同的元素）是否使用过了呢。

**如果`candidates[i] == candidates[i - 1]` 并且 `used[i - 1] == false`，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]**。

此时for循环里就应该做continue的操作。

![40.组合总和II1](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000954.png)

在图中将used的变化用橘黄色标注上，可以看出在candidates[i] == candidates[i - 1]相同的情况下：

- used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
- used[i - 1] == false，说明同一树层candidates[i - 1]使用过

### 分割回文串

题目：131

思路：

例如对于字符串abcdef：

- 组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个.....。
- 切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段.....。

所以切割问题，也可以抽象为一棵树形结构，如图：

![131.分割回文串](https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg)

递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。

此时可以发现，切割问题的回溯搜索的过程和组合问题的回溯搜索的过程是差不多的。

回溯的参数：字符串集合、划分的界限
回溯的终止条件：当划分的界限为最后一个字符时
回溯的单层逻辑：遍历剩余的字符串，分别尝试以每一个字符串作为最后界限，切分出一个回文，如果能够切分出一个回文，那么就接着递归；如果不能切出一个回文，就增加i值，重新尝试分割。

### 复原IP地址

题目：93

思路：遇上一题分割回文串一样，都是将分割位置作为遍历的变量
![93.复原IP地址](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123203735933.png)

递归参数：字符串、起点位置
递归终止条件：当分割位置超出字符串最后位置时
递归单层逻辑：以start_index为起点位置，逐渐增加分割位置，切割出一个字符串来。如果这个字符串合法，那么就接着递归，从i+1的位置作为新的起始位置；如果不合法或者path中字符串已经超过4个，则说明本层切割都不合法，应该返回到上一层。

### 子集

题目：78

思路：

![78.子集](https://code-thinking.cdn.bcebos.com/pics/78.%E5%AD%90%E9%9B%86.png)

递归参数：总的数组集合，以及剩余集合下标

递归终止条件：当下标超过集合大小时

递归单层逻辑：添加下一个元素，然后递归。注意在递归最开始需要将path添加到result中。

不需要剪枝，每一个路径都是子集。

### 回溯总结

回溯问题：求组合总和：主要是考虑集合中的元素可以重复使用，那么在递归时就不需要将start_index加1；另外这里可以采取排序之后剪枝的操作。

回溯问题：求总和总和3：这里主要是集合元素中会有重复。答案中要求的是树层去重，也就是不能有两个完全一样的答案。树枝是可以有重复元素的，就是path中的元素可以是重复的。

![40.组合总和II1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123202817973.png)

在图中将used的变化用橘黄色标注上，可以看出在candidates[i] == candidates[i - 1]相同的情况下：

- used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
- used[i - 1] == false，说明同一树层candidates[i - 1]使用过

回溯：分割回文串：使用求解组合问题的思路来解决切割问题，将切割的下标作为递归参数传递。

回溯：复原IP地址：同样是将切割问题看作是组合问题。

回溯：求解子集。

### 子集II

题目：90

思路：与上一题子集思路一致，只不过需要增加一步去重操作。去重的原理就是排序之后利用used数组判断树层重复还是树枝重复。

### 递增子序列

题目：491

思路：与上一题求子集思路一致，不过这里去重不是排序之后，因此不能将当前nums[i]与nums【i-1】比较，而是使用一个集合判断当前元素是否使用过。

![491. 递增子序列1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124200229824.png)

在图中可以看出，**同一父节点下的同层上使用过的元素就不能再使用了**

**`unordered_set<int> uset;` 是记录本层元素是否重复使用，新的一层uset都会重新定义（清空），所以要知道uset只负责本层！**

### 全排列

题目：46

思路：采用回溯的思路，每一树层遍历的集合是未被使用过的元素的集合

递归参数：集合
递归终止：当path元素个数与nums元素个数相同时
递归单层逻辑：需要使用一个全局的used数组记录每个元素在递归树中使用情况，全集中的每个元素都是唯一的，排列只能使用一次，所以使用过的元素不能够再次使用。

![46.全排列](https://code-thinking-1253855093.file.myqcloud.com/pics/20201209174225145.png)

- 时间复杂度: O(n!)
- 空间复杂度: O(n)

### 全排列II

题目：47

思路：在上一题的基础上排序之后去重

**拓展**

大家发现，去重最为关键的代码为：

```cpp
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
    continue;
}
```

**如果改成 `used[i - 1] == true`， 也是正确的!**，去重代码如下：

```cpp
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == true) {
    continue;
}
```

这是为什么呢，就是上面我刚说的，如果要对树层中前一位去重，就用`used[i - 1] == false`，如果要对树枝前一位去重用`used[i - 1] == true`。

**对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！**

这么说是不是有点抽象？

来来来，我就用输入: [1,1,1] 来举一个例子。

树层上去重(used[i - 1] == false)，的树形结构如下：

![47.全排列II2](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201406192.png)

树枝上去重（used[i - 1] == true）的树型结构如下：

![47.全排列II3](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201431571.png)

大家应该很清晰的看到，树层上对前一位去重非常彻底，效率很高，树枝上对前一位去重虽然最后可以得到答案，但是做了很多无用搜索。

### 回溯总结

求子集II：排序之后去重

递增子序列：没有排序，但是需要在每一层遍历中判断同一个父节点只能使用剩余集合中的相同元素一次。

排列1：与组合不同的是每次遍历和集合都是全集，所以需要判断这个元素是否之前已经使用过

排列2：与上一题相比全集中会有重复元素，所以排列之后判断相同元素是否在同一层使用过；同时由于遍历全集，即使与前面元素不同，还需要判断路径上是否已经使用过这个元素。

**性能分析：**

子集问题分析：

- 时间复杂度：$O(n × 2^n)$，因为每一个元素的状态无外乎取与不取，所以时间复杂度为$O(2^n)$，构造每一组子集都需要填进数组，又有需要$O(n)$，最终时间复杂度：$O(n × 2^n)$。
- 空间复杂度：$O(n)$，递归深度为n，所以系统栈所用空间为$O(n)$，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为$O(n)$。

排列问题分析：

- 时间复杂度：$O(n!)$，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ..... 1 = n!。每个叶子节点都会有一个构造全排列填进数组的操作（对应的代码：`result.push_back(path)`），该操作的复杂度为$O(n)$。所以，最终时间复杂度为：n * n!，简化为$O(n!)$。
- 空间复杂度：$O(n)$，和子集问题同理。

组合问题分析：

- 时间复杂度：$O(n × 2^n)$，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。
- 空间复杂度：$O(n)$，和子集问题同理。

**一般说道回溯算法的复杂度，都说是指数级别的时间复杂度，这也算是一个概括**



### 重新安排行程

题目：332

思路：主要思路是按照起点找到这个起点对应的所有终点，然后在这一层中遍历所有的可能的终点集合。对于每一个可能的终点集合，更新起点为这个终点，然后递归。

这个题目中需要按照字典序排列，那么就使用map保存每一个起点对应终点，第一个终点就是字典序最小的。

另外需要注意的是每次都是从全集中寻找，所以要判断一张票是否使用过，这里采用记录次数的方法，次数大于0才可以使用。

递归参数：unordered_map<string, map<string, int>> targets：unordered_map<出发机场, map<到达机场, 航班次数>> targets
递归返回值：bool，如果找到一条路径就返回，这个路径一定是字典序最小的。
递归终止条件：当结果中结点个数为票数+1时
递归单层逻辑：与思路一致。

### N皇后

题目：51

思路：以行为递归树的深度，以列为每层需要遍历的集合。限制条件就是用来判断选中位置是否合法。

在判断一个位置是否合法时，我的思路是根据已经放置的位置标记剩余行不可使用的位置。而作者的思路是放置皇后，看这个位置的同列、斜线上是否存在之前放置的皇后。即我的思路是列出一个白名单再判断，作者的思路是先放置再根据当前位置判断。

### 解数独

题目：37

思路：采用递归和回溯的方式

```c++
class Solution {
public:
    bool IsValid(const vector<vector<char>> &board, const int row,
                 const int col, const char c) {
        // 判断同一行是否有字符c
        for (int j = 0; j < 9; ++j) {
            if (board[row][j] == c)
                return false;
        }
        // 判断同列是否有元素
        for (int i = 0; i < 9; ++i) {
            if (board[i][col] == c)
                return false;
        }
        // 判断3*3的方格内是否存在这个元素
        int start_row = (row / 3) * 3;
        int start_col = (col / 3) * 3;
        for (int i = start_row; i < start_row + 3; ++i) 
            for (int j = start_col; j < start_col + 3; ++j) 
                if (board[i][j] == c) return false;
        
        return true;
    }

    bool BackTrace(vector<vector<char>> &board) {
        for (int row = 0; row < 9; ++row) {
            for (int col = 0; col < 9; ++col) {
                if (board[row][col] != '.') continue;

                // 尝试填充1~9
                for (char c = '1'; c <= '9'; ++c) {
                    if (IsValid(board, row, col, c)) {
                        board[row][col] = c; // 填充字符c
                        if (BackTrace(board)) return true;
                        board[row][col] = '.';
                    }
                }
                // 对于(row, col)位置尝试了9个字符都没成功
                return false;
            }
        }

        // 遍历完所有位置但是没有返回false
        // 说明填充均是正确的
        return true;
    }

    void solveSudoku(vector<vector<char>>& board) {
        BackTrace(board);
    }
};
```

## 分治与递归、动态规划、贪心

**分治法解决思路：**

- 分解：将一个大问题分解成多个小问题（可以分解成两个问题或者多个问题
- 递归：递归解决每个小问题
- 合并：由子问题的解（小问题一定有边界条件）合并出大问题的解

比如斐波那契数列，假如要计算F(4)，可以将这个问题分解为
1.计算F(3)和F(2);
2.计算F(3)分解为计算F(2)和F(1);计算F(2)分解为计算F(1)和F(0);
3.得出子问题的解之后就可以组合出大问题的解。



**动态规划解题思路：**

基本性质：1.在分治法中会出现子问题重叠的现象。比如上面的例子中，会重复求F(2)与F(1)等。
2.最优子结构性质：原问题的最优解一定包含了子问题的最优解

基本步骤：
1、定义子问题，分析**最优解**的结构特征；
2、找出最优解对应的**最优值**，并递归地定义最优值；
3、以自底向上的方式计算出**最优值**；
4、根据计算**最优值**时得到的信息，构造最优解

比如求解斐波那契数列，求解F(n)，表示最优解，同时代表了最优值。那么F(n) = F(n - 1) + F(n - 2)。
于是就可以自底向上计算问题。f(1),f(2),f(3)...f(n)

**动态规划与分治法比较：**
1.对于子问题的划分：分治法常常对半分，动态规划是划分成n-1
2.求解过程：分治法采用递归，动态规划采用自底向上



## 贪心

**贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。

**说实话贪心算法并没有固定的套路**。

如何验证可不可以用贪心算法呢？

**最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧**。

一般数学证明有如下两种方法：

- 数学归纳法
- 反证法

看教课书上讲解贪心可以是一堆公式，估计大家连看都不想看，所以数学证明就不在我要讲解的范围内了，大家感兴趣可以自行查找资料。

**面试中基本不会让面试者现场证明贪心的合理性，代码写出来跑过测试用例即可，或者自己能自圆其说理由就行了**。

**刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心**。

贪心算法一般分为如下四步：

- 将问题分解为若干个子问题
- 找出适合的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解

### 分发饼干

题目：455

思路：对于孩子i，从饼干中找到一个刚刚满足的他的饼干大小。

作者的思路：将二者都排序，然后遍历饼干，小饼干先满足小胃口的

### 摆动序列

题目：376

解法1：贪心算法：局部最优：删除单调递增的元素，尽量使得出现波峰和波谷

整体最优：波峰和波谷最多

这样最基本的计算增加子序列长度的条件就是：当前一个差值和后一个差值符号相反时就可以增加

另外需要考虑的是：当出现相等的情况时，即

**情况一：上下坡中有平坡**

例如 [1,2,2,2,1]这样的数组，如图：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20230106170449.png)

它的摇摆序列长度是多少呢？ **其实是长度是 3**，也就是我们在删除的时候 要不删除左面的三个 2，要不就删除右边的三个 2。

如图，可以统一规则，删除左边的三个 2：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20230106172613.png)

在图中，当 i 指向第一个 2 的时候，`prediff > 0 && curdiff = 0` ，当 i 指向最后一个 2 的时候 `prediff = 0 && curdiff < 0`。

如果我们采用，删左面三个 2 的规则，那么 当 `prediff = 0 && curdiff < 0` 也要记录一个峰值，因为他是把之前相同的元素都删掉留下的峰值。

所以我们记录峰值的条件应该是： `(preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)`，为什么这里允许 prediff == 0 ，就是为了 上面我说的这种情况。

另外需要考虑的是计算两个差值需要至少三个数，当数组只有两个数时应该如何处理：
**情况二：单独处理两个元素**

可以直接将两个元素的数组列出来，也可以加入到上面的情况中。

例如序列[2,5]，如果靠统计差值来计算峰值个数就需要考虑数组最左面和最右面的特殊情况。

因为我们在计算 prediff（nums[i] - nums[i-1]） 和 curdiff（nums[i+1] - nums[i]）的时候，至少需要三个数字才能计算，而数组只有两个数字。

这里我们可以写死，就是 如果只有两个元素，且元素不同，那么结果为 2。

不写死的话，如何和我们的判断规则结合在一起呢？

可以假设，数组最前面还有一个数字，那这个数字应该是什么呢？

之前我们在 讨论 情况一：相同数字连续 的时候， prediff = 0 ，curdiff < 0 或者 >0 也记为波谷。

那么为了规则统一，针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即 preDiff = 0，如图：

![376.摆动序列1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124174357612.png)

针对以上情形，result 初始为 1（默认最右面有一个峰值），此时 curDiff > 0 && preDiff <= 0，那么 result++（计算了左面的峰值），最后得到的 result 就是 2（峰值个数为 2 即摆动序列长度为 2）

**情况三：单调坡度有平坡**

在版本一中，我们忽略了一种情况，即 如果在一个单调坡度上有平坡，例如[1,2,2,2,3,4]，如图：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20230108171505.png)

图中，我们可以看出，版本一的代码在三个地方记录峰值，但其实结果因为是 2，因为 单调中的平坡 不能算峰值（即摆动）。

之所以版本一会出问题，是因为我们实时更新了 prediff。

那么我们应该什么时候更新 prediff 呢？

我们**只需要在 这个坡度 摆动变化的时候**，更新 prediff 就行，这样 prediff 在 单调区间有平坡的时候 就不会发生变化，造成我们的误判。

### 最大子序和

题目：53

思路1：暴力破解法：元素下标从第一个元素到最后一个元素，分为作为子序列起始元素，遍历起始元素后面的元素，记录最大子序列和。

思路2：贪心算法：局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。

全局最优：选取最大“连续和”

**局部最优的情况下，并记录最大的“连续和”，可以推出全局最优**。

我的理解：可以将整个序列看成是多个子序列，将多个子序列进行组合成一个更大的子序列，那么只有当子序列之和为正时合并才会使得组合而成的子序列的值变大。

```c++
int maxSubArray(vector<int>& nums) {
    int result = INT32_MIN;
    int count = 0;

    for (int i = 0; i < nums.size(); ++i) {
        count += nums[i];
        if (count > result) result = count;

        if (count < 0) count = 0;
    }

    return result;
}
```

### 总结

**贪心的本质是选择每一阶段的局部最优，从而达到全局最优。**

饼干分发：小饼干尽量满足胃口小的

最长摇摆序列：保持相邻两个元素波动，即删除单调坡度上的点

最大子序列和：将序列看成是多个子序列，只有子序列和为正才能参与组合，子序列和为负只会拉低组合序列的和的大小。

### 买卖股票的最佳时机II

题目：122

我的思路：买入股票之后，只要股票价格在涨，就不卖出；当股票价格下跌时就立即卖出。

特殊情况是整个序列都是递增的，不会出现下降，这个时候需要判断是否为最后一个元素

```
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int profit = 0;
        int in, out;
        in = prices[0];
        for (int i = 1; i < prices.size(); ++i) {
            if (prices[i - 1] <= prices[i] && i != prices.size() - 1) {
                continue;
            } else if (prices[i - 1] <= prices[i] && i == prices.size() - 1) {
                profit += prices[i] - in;
                break;
            } else {
                out = prices[i - 1];
                profit += out - in;

                in = prices[i];
            }
        }

        return profit;
    }
};
```

作者的思路：**如果想到其实最终利润是可以分解的，那么本题就很容易了！**

如何分解呢？

假如第 0 天买入，第 3 天卖出，那么利润为：prices[3] - prices[0]。

相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。

**此时就是把利润分解为每天为单位的维度，而不是从 0 天到第 3 天整体去考虑！**

那么根据 prices 可以得到每天的利润序列：(prices[i] - prices[i - 1]).....(prices[1] - prices[0])。

如图：

![122.买卖股票的最佳时机II](https://code-thinking-1253855093.file.myqcloud.com/pics/2020112917480858-20230310134659477.png)

**局部最优：收集每天的正利润，全局最优：求得最大利润**。

局部最优可以推出全局最优，找不出反例，试一试贪心

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int profit = 0;
        for (int i = 1; i < prices.size(); i++) {
            profit += max(prices[i] - prices[i - 1], 0);
        }

        return profit;
    }
};
```

### 跳跃游戏

题目：55

思路1：贪心算法
每次可以跳跃的最大距离是nums[i]，这表示下一步可以走的距离是[i+1, i+nums[i]]，如果nums[i]为0，表示永远不可能到达重点。
局部最优：跳跃到下一步最大距离最大的位置，这样下一次可供选择的跳跃点更多，这里注意应该是覆盖范围更大。
整体最优：所有的覆盖范围累加如果能够超越边界就可以跳出去。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230203105634.png" alt="img" style="zoom: 50%;" />

### 跳跃游戏II

题目：45

思路1：每一步尽可能的多走，但是不能有多远就跳多远，因为这样就不能确定下一步能够到达哪里。

注意覆盖范围内是一步可以跳到的，因此更新下一步的覆盖范围时也是尽可能使得下一步的覆盖范围达到最大。

总体思路是：计算当前可以到达的最大范围，这是一步可以到达的范围；那么然后比较这些范围内下一步可以到达的范围，选择下一步最大范围的跳，这样能够保证以最小步数来扩充范围。跳跃之后判断点是否超过终点，超过终点就结束。

**这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖**。

如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。

如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201201232309103.png" alt="45.跳跃游戏II" style="zoom:67%;" />

从图中可以看出来，就是移动下标达到了当前覆盖的最远距离下标时，步数就要加一，来增加覆盖距离。最后的步数就是最少步数。

这里还是有个特殊情况需要考虑，当移动下标达到了当前覆盖的最远距离下标时

- 如果当前覆盖最远距离下标不是是集合终点，步数就加一，还需要继续走。
- 如果当前覆盖最远距离下标就是是集合终点，步数不用加一，因为不能再往后走了。

### K次取反后最大化的数组和

题目：1005

我的思路：
设负数个数为neg，则首先应该把负数编程正数才能使得和最大，所以整体思路为：
如果neg 大于等于 k：那么把所有的负数变成正数就可以；
如果neg 小于k：判断是否存在0：如果存在0，那么剩下的次数全变化0即可；否则接着判断剩下次数的奇偶：如果是偶数，那么可以将一个正数来回变化偶数次，不影响最后结果；如果是奇数，那么前面的偶数次可以用来做反复变化，最后一次将最小的正数编程负数即可。

真正实施代码：

```c++
int largestSumAfterKNegations(vector<int>& nums, int k) {
        // 升序排列
        sort(nums.begin(), nums.end());

        // 首先处理负数
        int i;
        for (i = 0; i < nums.size(); ++i) {
            if (k == 0) break; // 次数用完退出

            if (nums[i] < 0) {
                // 消耗一次变化次数
                --k;
                nums[i] = -nums[i];
            } else if (nums[i] == 0){
                k = 0;
                break; // 当遇到非负数时退出循环
            } else {
                break;
            }
        }

        // 此时K表示所有的负数都被消耗
        if (k > 0) {
            if (k % 2 == 0) {
                // 此时无需再处理数组
                ;
            } else {
                // 重新排序选择最小的整数取反即可
                sort(nums.begin(), nums.end());
                nums[0] = -nums[0];
            }
        }


        int ans = 0;
        for (int j = 0; j < nums.size(); ++j)
                ans += nums[j];

        return ans;
    }
```

时间复杂度O(nlogn)，即主要是排序消耗的时间；空间复杂度O(1)



作者思路：

- 第一步：将数组按照绝对值大小从大到小排序，**注意要按照绝对值的大小**
- 第二步：从前向后遍历，遇到负数将其变为正数，同时K--
- 第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完
- 第四步：求和

这里优化了判断当负数处理完之后判断是否有0的存在，直接反复处理最小的元素即可。

### 贪心周总结

股票问题：把一段时间的利润拆分成这几天每一天的利润。即用一天价格减去前一天的价格做差。

这样贪心的思路就是：只收集正利润，即上涨的利润。全局最优：得到最大利润

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2020112917480858.png" alt="122.买卖股票的最佳时机II" style="zoom:50%;" />

跳跃游戏I：问题转换为覆盖范围，即每次跳跃取最大步数是这一步目前的最大覆盖范围。

局部最优：每次都取最大范围。

整体最优：整体最大覆盖范围是否能够到达终点。



跳跃游戏II：当前最大覆盖范围：一步内可以到达的地方。如果当前最大覆盖范围没有到达终点，那么就需要再走一步，扩大覆盖范围。新走的一步也要使得覆盖范围最大，即保证下一步的覆盖范围最大。即在当前覆盖范围内可走的下标 i + nums[i] 就是走到下一步 i 的覆盖范围。



K次取反之后最大化的数组和：局部最优：让绝对值最大的负数先变成正数。然后再让绝对值最小的正数变成负数。



### 加油站

题目：134

我的思路：如果各个站点的加油站 剩油量rest[i]相加之和大于等于零，说明总油量减去总消耗大于等于零那么一定可以跑完一圈。

但是不知道起点怎么求。

作者给了思路：

每个加油站的剩余量rest[i]为gas[i] - cost[i]。

i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，**因为这个区间选择任何一个位置作为起点，到i这里都会断油**，那么起始位置从i+1算起，再从0计算curSum。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230117165628.png" alt="img" style="zoom:50%;" />

那么为什么一旦[0，i] 区间和为负数，起始位置就可以是i+1呢，i+1后面就不会出现更大的负数？

如果出现更大的负数，就是更新i，那么起始位置又变成新的i+1了。

那有没有可能 [0，i] 区间 选某一个作为起点，累加到 i这里 curSum是不会小于零呢？ 如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230117170703.png" alt="img" style="zoom:50%;" />

如果 curSum<0 说明 区间和1 + 区间和2 < 0， 那么 假设从上图中的位置开始计数curSum不会小于0的话，就是 区间和2>0。

区间和1 + 区间和2 < 0 同时 区间和2>0，只能说明区间和1 < 0， 那么就会从假设的箭头初就开始从新选择其实位置了。

**那么局部最优：当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置**。

时间复杂度O(n)，空间复杂度O(1)

### 分发糖果

题目：135

我的思路：从前向后遍历，当左孩子小于右孩子时，右孩子糖果等于左孩子糖果+1；（那么如果左孩子大于右孩子呢？理论上应该是左孩子糖果等于右孩子+1，但是遍历顺序是从前向后，所以此时没办法确定右孩子的糖果数目）

接着从后向前遍历，此时就能够根据右孩子糖果数确定左孩子糖果数，此时如果左孩子大于右孩子，那么此时左孩子有两个选择，一个选择是右孩子+1，另一个选择是上一步中求得的这个孩子应该有的糖果数。应该选择较大的，这样既能保证大于左边又能保证大于右边。

时间复杂度O(n)，空间复杂度O(n)

采用了两次贪心的策略：

- 一次是从左到右遍历，只比较右边孩子评分比左边大的情况。
- 一次是从右到左遍历，只比较左边孩子评分比右边大的情况。

这样从局部最优推出了全局最优，即：相邻的孩子中，评分高的孩子获得更多的糖果。

### 柠檬水找零

题目：860

思路：

- 情况一：账单是5，直接收下。
- 情况二：账单是10，消耗一个5，增加一个10
- 情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5

账单是20的情况，为什么要优先消耗一个10和一个5呢？

**因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！**

所以局部最优：遇到账单20，优先消耗美元10，完成本次找零。全局最优：完成全部账单的找零。

### 根据身高重建队列

题目：406

思路：

遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。

**如果两个维度一起考虑一定会顾此失彼**。

对于本题相信大家困惑的点是先确定k还是先确定h呢，也就是究竟先按h排序呢，还是先按照k排序呢？

如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。

那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面,，后续根据k值选择插入位置，防止小的k值还不存在就插入大的k值下标），让高个子在前面。

**此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！**

那么只需要按照k为下标重新插入队列就可以了，为什么呢？

以图中{5,2} 为例：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201216201851982.png" alt="406.根据身高重建队列" style="zoom:50%;" />

按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。

所以在按照身高从大到小排序后：

**局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性**

**全局最优：最后都做完插入操作，整个队列满足题目队列属性**

例子：

排序完的people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]

插入的过程：

- 插入[7,0]：[[7,0]]
- 插入[7,1]：[[7,0],[7,1]]
- 插入[6,1]：[[7,0],[6,1],[7,1]]
- 插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]
- 插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]
- 插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]

时间复杂度O(nlogn + n^2)，后面的时间复杂度是指遍历一遍所有的元素，然后根据k选择插入位置

空间复杂度O(n)

### 用最少数量的箭引爆气球

题目：452

我的思路（存在缺陷）：对于一个气球来说，想要引爆的射箭位置就是[L, H]，那么如果想要一次引爆多个气球，就需要从他们的交集位置射出，所以我的思路就是遍历所有气球位置，使得尽量从交集位置射出。

但是问题是：气球顺序会影响两个位置范围结合求子集的顺序，这样会使得

```c++
[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]
```

比如上面的气球顺序，当[7,12],[3,8]相遇，那么子集范围就确定为[7,8]，不能达到最小箭的数目
<img src="D:\RegularFile\LeetCode-c++\pic\452.jpg" alt="452" style="zoom: 33%;" />

这里明显是6可以解决除了最后一个所有的气球，但是如果采用上面的思路，就需要3个箭头。

但是如果排序之后再使用上面算法，可以通过，但是时间复杂度是O(max(nlogn, n^2))



作者的思路：

局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少。

如果把气球排序之后，从前到后遍历气球，被射过的气球仅仅跳过就行了，没有必要让气球数组remove气球，只要记录一下箭的数量就可以了。**为了让气球尽可能的重叠，需要对数组进行排序**。

**如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭**。

以题目示例： [[10,16],[2,8],[1,6],[7,12]]为例，如图：（方便起见，已经排序）

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123101929791.png" alt="452.用最少数量的箭引爆气球" style="zoom:50%;" />

时间复杂度O(nlogn)，快速排序；空间复杂度O(1)



## 动态规划

动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。

所以动态规划中每一个状态一定是由上一个状态推导出来的。贪心没有状态推导，而是从局部直接选最优的。

解题步骤：

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

如何debug：
**找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的**

### 斐波那契数

题目：509

思路1：
1、确定dp数组以及下标的含义：
dp[i]的定义是：第i个数的斐波那契数值是dp[i]
2、确定递推公式
**状态转移方程 dp[i] = dp[i - 1] + dp[i - 2]**
3、dp数组如何初始化

```
dp[0] = 0;
dp[1] = 1;
```

4、确定遍历顺序
从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的。
5、举例推导dp数组按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：

0 1 1 2 3 5 8 13 21 34 55

时间复杂度O(n)，空间复杂度O(n)

实际上只需要维护两个数值就可以，不需要整个状态数组。所以空间复杂度为O(1)

思路2：采用递归的方式，从上到下计算

```c++
class Solution {
public:
    int fib(int N) {
        if (N < 2) return N;
        return fib(N - 1) + fib(N - 2);
    }
};
```

时间复杂度O(2^n)，空间复杂度O(n)，包括了实现递归所占用的系统栈的空间

#### 递归的时间复杂度

面试题：求x的n次方

最直观：一个for循环

```c++
int function1(int x, int n) {
    int result = 1;  // 注意 任何数的0次方等于1
    for (int i = 0; i < n; i++) {
        result = result * x;
    }
    return result;
}
```

时间复杂度是O(n)

一种递归：

```c++
int function2(int x, int n) {
    if (n == 0) {
        return 1; // return 1 同样是因为0次方是等于1的
    }
    return function2(x, n - 1) * x;
}
```

递归算法的时间复杂度本质上是要看: **递归的次数 \* 每次递归中的操作次数**。

每次n-1，递归了n次时间复杂度是O(n)，每次进行了一个乘法操作，乘法操作的时间复杂度一个常数项O(1)，所以这份代码的时间复杂度是 n × 1 = O(n)。

另一种递归：

```c++
int function3(int x, int n) {
    if (n == 0) return 1;
    if (n == 1) return x;

    if (n % 2 == 1) {
        return function3(x, n / 2) * function3(x, n / 2)*x;
    }
    return function3(x, n / 2) * function3(x, n / 2);
}
```

我们来分析一下，首先看递归了多少次呢，可以把递归抽象出一棵满二叉树。刚刚同学写的这个算法，可以用一棵满二叉树来表示（为了方便表示，选择n为偶数16），如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201209193909426.png" alt="递归算法的时间复杂度" style="zoom: 33%;" />

当前这棵二叉树就是求x的n次方，n为16的情况，n为16的时候，进行了多少次乘法运算呢？

这棵树上每一个节点就代表着一次递归并进行了一次相乘操作，所以进行了多少次递归的话，就是看这棵树上有多少个节点。

这么如果是求x的n次方，这个递归树有多少个节点呢，如下图所示：(m为深度，从0开始)

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200728195531892.png" alt="递归求时间复杂度" style="zoom:67%;" />

**时间复杂度忽略掉常数项`-1`之后，这个递归算法的时间复杂度依然是O(n)**

最后一种递归：

```c++
int function4(int x, int n) {
    if (n == 0) return 1;
    if (n == 1) return x;
    int t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来
    if (n % 2 == 1) {
        return t * t * x;
    }
    return t * t;
}
```

再来看一下现在这份代码时间复杂度是多少呢？

依然还是看他递归了多少次，可以看到这里仅仅有一个递归调用，且每次都是n/2 ，所以这里我们一共调用了log以2为底n的对数次。

**每次递归了做都是一次乘法操作，这也是一个常数项的操作，那么这个递归算法的时间复杂度才是真正的O(logn)**。

### 爬楼梯

题目：70

思路1：每次可以选择爬1或者2个台阶

1。确定dp数组以及下标含义
dp[i]表示到达第i个阶梯的方法，

2.确定递推公式
dp[i] = dp[i - 1] + dp[i - 2]，表示登上第i-1层阶梯的方法之和再走一个阶梯，以及先登上第i- 2层阶梯的方法之和再走两个阶梯

3.初始化

由题意可知：dp[1] = 1；dp[2] = 2

4.遍历方式：后者必须依赖于前面两个元素，所以必须从前向后遍历

5.举例子

dp[1] = 1
dp[2] = 2
dp[3] = 3 = dp[1] + dp[2]
dp[4]: 1 1 1 1; 1 1 2; 1 2  1;  2 1 1; 2 2 一共5种，等于dp[3] + dp[2]

思路2：采用分治或者说是递归的方式，同样由递推公式可得dp[i] = dp[i - 1] + dp[i - 2]，那么可以将一个大问题分解成小问题，递归解决小问题，小问题到达边界条件之后合并解决大问题。

时间复杂度O(2\^n)：每计算一个F(n)都需要把这个结点分成两个结点，可以看作是一颗满二叉树，这个满二叉树的高度是n，于是可以得知一共有2^n级别个结点，这些结点都是一次递归操作，每次递归中的操作是O(1)级别的。

会超时。

### 使用最小花费爬楼梯

题目：746

思路：采用动态规划方式

1.dp数组即下标含义：
dp[i]表示到达第i层阶梯的最小花费

2.dp数组递推公式：
到达dp[i]有两种方式：（1）先到到达i-2，然后使用第i-2层的花费之后走两层到达第i层；（2）先到达第i-1层，然后使用第i-1层的花费之后走一层达到第i层。因此要使得dp[i]最小，就需要选择这两种方式中较小的一种。

另外需要注意的是，达到第i层不是终点，终点应该是走过所有楼梯，所以是第i+1层。

3.dp数组初始化：
可以从第0层或者第1层开始，所以到达这两层的最小花费是直接到达，即dp[0] = dp[1] = 0

4.遍历顺序：
因为i依赖于i-2和i-1，所以从前向后遍历

5.举例子尝试：
cost = [10,15,20]

(1)dp[0] = dp [1] = 0;

(2)dp[2]：选择有两种：第一种选择是：dp[0] + cost[0] = 10；第二种选择是：d[1] + cost[1] = 15；

(3)dp[3]：选择有两种：第一种选择是：dp[1] + csot[1] = 15；第二种选择是：dp[2] + cost[2] = 35;

所以最小花费是从下标1开始，走两层到达顶部（也就是第3层）

时间复杂度O(n)，空间复杂度O(1)，这里只需要保留前两次数据即可。

### 不同路径

题目：62

思路1：动态规划。怎么想出来的：尝试使用回溯的方法，到达一个点（i,j），剩余可以走的路径只有向右或者向下。发现子问题会存在重复，于是考虑到动态规划。想要到达（m,n），必须先到达（m-1,n）或者（m,n-1），因此可以将一个大问题划分成子问题。

1.dp数组以及下标含义：
这里dp数组是二维的，dp[i]\[j]表示到达（i,j）的路径数目

2.dp数组递推公式：
想要到达（i，j），要么（1）先到达（i-1，j）再向下移动一格；要么（2）先到达（i，j-1）再向右移动一格。于是可以得到
dp[i]\[j] = dp[i-1]\[j] + dp[i]\[j-1]

3.dp数组初始化：
第一行和第一列的元素都为1（dp[0]\[0]不应该存在，因为如果起点就是终点的话路径应该为0）

4.遍历顺序：
每一个元素依赖于上面的元素和左边的元素，所以按行从左向右遍历

5.举例子测试：假如m=3，n=2

首先初始化：第一行和第一列都是1，即dp(0,1) = 1, dp(1, 0) = 1, dp(2, 0) = 1

接着进行遍历（遍历从第二行的第二列开始）：dp(1, 1) = dp(0, 1) + dp(1, 0) = 2

接着遍历第三行：dp(2, 1) = dp(1, 1) + dp(2, 0) = 2 + 1 = 3

时间复杂度O(m*n)，因为是遍历二维数组；空间复杂度O(m\*n)，整个dp数组所占用的空间。是否可以优化？



思路2：采用回溯的方式，每层回溯可以遍历的集合就是左和下。

使用一个全局遍历记录总的路径个数

递归的参数：终点(m,n)，当前位置(row,col)；没有返回值
递归的终止条件：当行或者列超出范围时，这时已经不是合理的范围；另外就是当前位置到达终点时也需要记录一个路径，并且返回
递归的单层逻辑：只能行增加或者列增加继续递归。

时间复杂度O(2^(m+n-1))，有递归树可以看出，每一个结点有两条孩子，是一颗满二叉树，这棵树的深度其实就是m+n-1（深度按从1开始计算）。空间复杂度就是时间复杂度，每一层都是一层递归栈。



思路3：组合数学：从（1，1）到达（m，n），不管是什么走法（每一步只能向左或者向右），一定是向下走m-1步，向右走n-1步，一共是m+n-2步。

由于每次要么下要么右，并且必须有m-1个是向下，所以相当于在m+n-2次中有m-1个是向下操作（剩下的自然只能是向右）。

所以是组合数C

计算组合数的算法：



分子分母都是m个数相乘。不能先算出分子再算出分母，放置int类型溢出。所以采用边算边除以分母的方式：

```c++
// 使用组合数
    int uniquePaths(int m, int n) {
        long long numerator = 1; // 分子
        int denominator = m - 1; // 分母
        int count = m - 1;
        int t = m + n - 2; // 起点
        
        while (count--) {
            numerator *= (t--);
            // 当可以整除分母时
            // 由于是组合数，所以分子一定可以把所有的分母都给整除掉
            while (denominator != 0 && numerator % denominator == 0) {
                numerator /= denominator;
                denominator--;
            }

        }

        return numerator;
    }
```

时间复杂度O(m)

### 不同路径II

题目：63

思路1：采用深度优先搜索，每次可以选择搜索的集合就是右和下，如果是障碍物就不能搜索。

时间复杂度是O(2^(m +n -1))，感觉会超时

思路2：与上一题一样使用动态规划
1.dp数组以及下标含义：
dp[i]\[j]表示到达（i，j）可能的路径个数

2.dp数组递推公式：
遇上一题一样，想要到达（i，j），必须先到达（i-1，j）或者（i，j-1），所以
dp[i]\[j] = dp[i-1]\[j] + dp[i]\[j-1]
但是这里需要判断是否为障碍物。如果（i，j）是障碍物，那么这里的dp没有意义，可以不进行计算；如果（i-1，j）或者（i，j-1）是障碍物，那么就不添加是障碍物的dp。如果都是障碍物，那么dp[i]\[j]就是0.

3.dp数组初始化：
（0，0）无意义，题目也说明不会只存在一个格子；
首先初始化第一行：（0，1）为1，然后依次向后初始化：如果第一行没有出现障碍物，那么全是1；如果出现障碍物，那么障碍物之后的都是0.
接着初始化第一列：（1，0）为1，然后依次向下初始化：如果第一列没有出现障碍物，那么全是1；如果出现障碍物，那么障碍物以下的都是0.

4.遍历顺序：
因此每一个元素都依赖于上面和左面，所以按行从左向右开始遍历

5.举例子：
示例1正确。

### 整数拆分

题目：343

思路1：采用动态规划

1.dp数组以及下标定义：
dp[i]表示i被拆分之后最大乘积。

2.dp数组递推公式：
j从1到i-1开始遍历，得到dp[i]的方式有两种：（1）j * (i - j)；（2）j * dp[i - j]（相当于拆分 i - j）；通过比较这些值中最大的来确定dp[i]
因此递推公式为：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))
这里有dp[i]的原因是不断更新dp[i]的值，所以也参与到比较中

3.初始化：
i从2开始，每次j从1遍历到i / 2就可以，~~因为当 j 超过 i / 2之后，就开始重复~~

因为拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的。

例如 6 拆成 3 * 3， 10 拆成 3 * 3 * 4。 100的话 也是拆成m个近似数组的子数 相乘才是最大的。

只不过我们不知道m究竟是多少而已，但可以明确的是m一定大于等于2，既然m大于等于2，也就是 最差也应该是拆成两个相同的 可能是最大值。

那么 j 遍历，只需要遍历到 n/2 就可以，后面就没有必要遍历了，一定不是最大值。

至于 “拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的” 这个我就不去做数学证明了，感兴趣的同学，可以自己证明。

4.遍历顺序：
后者依赖于前者，所以从前向后遍历



时间复杂度O(n^2)，因为是双层循环；空间复杂度O(n)

### 不同的二叉搜索树

题目：96

思路1：动态规划

1.dp数组以及下标的含义：
dp[i]表示由i个结点组成互不相同的二叉搜索树的个数

2.dp数组递推公式：
j 从1遍历到 i ，表示以 j 值作为二叉搜索树的根节点。由于二叉搜索树根节点的左子树所有元素必须比根节点小，所以小于j的元素在左子树，大于j的元素在右子树。那么以结点 j 为根节点的二叉搜索树的个数就等于左子树种类数 与 右子树种类数的乘积。即dp[j] = dp[j - 1] * dp[i - j]。如果左子树节点数或者右子树节点数为0，那么应该为1，所以决定了dp[0]为1

所以只需要 j 从1遍历到n分别作为根节点求出dp[j] ，再把所有的dp[j]累加在一起就可以得到dp[i]

3.数组初始化：
上面可以得到，当j-1 == 0 或者i - j == 0即左子树或者右子树节点数为0时，为了方便与另一颗子树做乘法，所以dp[0] 应该为1；
另外dp[1] 为1.

4.遍历顺序：
dp数组第i个元素依赖于：从j-1到i-j（j取值为[1,i]），即依赖于dp[0]到dp[i - 1]，所以必须是从前向后遍历

5.举例子
n为3的例子正确

时间复杂度O(n^2）因为是双层循环；空间复杂度O(n)，因为第i个依赖于前i-1个，所以空间没办法优化。

















