# 代码随想录

## 数组

### 二分查找

704.二分查找

35.搜索插入位置
34.在排序数组中查找元素的第一个和最后一个位置
69.x 的平方根
367.有效的完全平方数

收获：

1.二分查找法如果失败的话就是应该插入的位置。

2.除2可以用右移1表示。

3.$\sqrt{x}$使用二分法搜索表示为:$k^2\le x$，即搜索最大的整数值；

4.需要注意两个int值相乘的取值范围会超过int，应该使用long long。

### 移除元素

27.移除元素

26.删除排序数组中的重复项
283.移动零
844.比较含退格的字符串
977.有序数组的平方

收获：

1.数组双指针的思路。

### 有序数组的平方

收获：

昨天自己做的思路：找到绝对值最小的位置，左右指针从中间相两边，新的数组从小到大增加元素。

作者的思路：左右指针从最左边和最右边开始，新的数组从最后开始增加大的元素。

### 长度最小的子数组

209.长度最小的子数组

904.水果成篮
76.最小覆盖子串

收获：

主要是滑动窗口的应用。

需要思考：1.窗口里面是什么；2.窗口什么时候右移；3.窗口什么时候收缩。

### 螺旋矩阵

59.螺旋矩阵II

这是一种模型行为类型的题，看上去复杂，第一次遇到。

收获：循环不变量，即在一个循环中保持不变的量，比如二分法循环中不变的是左闭右开区间或者左闭右闭区间，比如简单选择排序中不变的是前i个元素是最小的。

### 总结

作者一共介绍了四种题型和方法，分别是二分法、双指针、滑动窗口、模拟操作（循环不变量）

### 数组部分一刷回顾

数组第一种类型：查找数组元素，对于有序数组，采用二分查找法，二分查找法的关键在于确定查找区间是左闭右开开始左闭右闭，如果是左闭右开，那么循环条件就是左边界小于右边界，并且循环终止时left = right；
如果是左闭右闭，那么循环条件就是左边界<=有边界，并且循环终止时left=right+1。
跳出循环的时候，所有元素都已经比较过，并且如果查找失败跳出循环，此时的下标就应该是这个元素被插入的位置：如果是左闭右开，此时left = right，应该把从right到末尾的元素全部后移；如果是左闭右闭，那么此时left = right + 1，应该把从left到末尾的元素全部后移。

数组第二种类型：双指针法，利用快慢指针对数组进行操作



## 链表

### 删除链表元素

题目：203

收获：删除元素应该先保存链表下一个结点的信息

### 设计链表

题目：707

收获：循环的时候注意循环体执行次数和循环判断条件的关系。

### 翻转链表

题目：206

思路就是使用双指针，值得注意的点就是注意删除操作顺序。

收获：重复的操作可以使用递归实现，，即不断对于两个结点进行翻转。

另一种形式的递归：每次都先翻转后面的链表，后面链表翻转完成之后再进行当前结点的翻转，注意这个递归返回的是最后一个节点值。

栈的思路：遍历一遍链表然后入栈，之后出栈即可。

或者采用头插法。

### 两两交换链表中的结点

题目：24

思路：使用双或者三指针，只需要注意更改next的顺序即可。

### 删除链表中的倒数第n个结点

题目：19

思路：第一个指针先走n步，接着第二个指针跟着第一个结点一起走到尾，就会指向第len-n+1也就是倒数第n个结点。

这题是删除倒数第n个，所以稍有变动。

并且虚拟头结点的好处就是对于第一个结点的操作与其他结点一样，没有虚拟头节点对于头结点的操作需要单独处理。

### 链表相交

题目160

思路：1.将链表A+链表B   链表B+链表A，使用两个指针遍历这两个链表，如果存在相交结点，那么一定相遇在空结点之前。

2.链表A+链表B，判断是否存在循环

作者的思路：求两个链表长度，总之与思路1一样

### 环形链表

题目：142

主要思路：1.使用快慢指针寻找相遇点；2.当第一次相遇时，令其中一个指针指向头结点，两个指针同速前进，再次相遇点就是环的起点。

有三个点：头结点、环的起点、相遇点，相遇点一定在环的起点之后（没到环的起点怎么相遇）。

假设相遇点时slow走了k，那么fast一定走了2k，也就是k一定是环的长度的n倍。

假设相遇点距离环的起点的距离为m，那么环的起点点距离头结点的距离为k-m；即从头结点走k-m到达环的起点。

假如从相遇点开始走，走k一定是重新到达相遇点，那么走k-m是到环的起点。

### 总结

链表的基础操作（删除、插入等）、双指针技巧、删除链表的元素可以删除该结点的后一个元素、环型链表的处理



## 哈希表

主要用于需要判断一个元素是否存在一个数组中时。

### 有效的字母异位词

242.有效的字母异位词

383.赎金信

49.字母异位词分组

438.找到字符串中所有字母异位词

收获：hash表（map）的键值可以是任何东西。比如49题中把string作为键，把列表作为值。

438复习了滑动窗口的使用。



### 两个数组的交集

349.两个数组的交集

350.两个数组的交集 II

收获：主要是set和map的使用，其中set好像更慢一点。

### 快乐数

第202题. 快乐数

收获：学会使用unorder_set

### 两数之和

第1题：两数之和

收获：

- 为什么会想到用哈希表：当需要判断一个元素是否存在时
- 哈希表为什么用map：因为数组的下标只能是int，set没有下标，map用于存一个映射。
- 本题map是用来存什么的：key存target - nums1（第一个加数） value存这个数对应的下标
- map中的key和value用来存什么的

### 四数相加

第454题：

收获：要找的是加数 + 加数 + 加数 + 加数 = 0出现的次数，因此map的key应该是加数，value是出现的次数。

### 赎金信

第383

收获：之前做过，这里由于hash表的长度是固定的（26个小写字母），所以使用数组更加合适。**map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的**

### 三数之和

第15

对于自己来说难以理解：1.hash思路有，但是由于题目中要求不能重复，难以完成。（待完成）

2.使用双指针，先把数组排序，然后需要注意的是：（1）.去重的逻辑：去重a：应该判断与之前的元素是否相同，由于是排序之后的，如果相同说明要么都找不到，要么找到也是重复的；去重bc，在找到第一对bc之后，应该重复判断与他们相邻的是否相等，相等就应该去重。（2）.找到之后两个指针同时跳变

### 四数之和

18

思路：就是在三数之和的基础上加层循环

但是需要注意的是：剪枝的一些细节，比如由于target是一个随机值，不能判断第一个元素大于零就直接返回，因为有可能target是小于第一个元素的。

错误：我的思路是两个双指针，错误的地方是：外层如果用双指针，那么当双指针同时增加时，会漏掉什么元素？？？

这个问题与之前遇到的同时增加的

思考：我的思路：从外层选两个，从内层选两个，

作者的思路：从n个中选一个，从剩下的n-1个中选一个，然后双指针选择剩下的两个

注意：两种方式：（1）从n中选一个，从剩下的n-1中选一个，一共有n(n-1)/2中组合

（2）我的两个指针同时从前后增加，那么只有n/2种组合

而题目明显是要求第一种方式选择，不要漏掉组合。

注意：双指针是如何把从n中选两个的时间复杂度变成n的？

（1）从n中选两个不同的，正常思路就是n的平方；

（2）如果采用双指针，O(n^2)的解法优化为 O(n)的解法，因为一次选中不同的两个？

### 总结

**一般来说哈希表都是用来快速判断一个元素是否出现集合里**。

哈希函数是把传入的key映射到符号表的索引上。

接下来是常见的三种哈希结构：

- 数组
- set（集合）
- map（映射）

**使用set的理由：**

**主要因为如下两点：**

- 数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。
- 如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

**使用map的理由：**

- 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
- set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。

C++提供如下三种map：

- std::map
- std::multimap
- std::unordered_map

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

std::unordered_map 底层实现为哈希，std::map 和std::multimap 的底层实现是红黑树。

在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。

虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。

同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解），[1.两数之和 (opens new window)](https://programmercarl.com/0001.两数之和.html)中并不需要key有序，选择std::unordered_map 效率更高！

## 字符串

**如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。**

### 反转字符串1

题目：第344题

思路：双指针

### 反转字符串2

题目：第341

我的思路：每次取前2k个，用i=1，2，3去乘2k

作者的思路：直接取每个区间的起点，i=0， 2k，

然后在循环中判断i + k是否超过最后字符串结尾即可。

### 替换空格

剑指Offer 05.替换空格

思路：**其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

这么做有两个好处：

1. 不用申请新数组。
2. 从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。

### 151.翻转字符串里的单词

思路1：保存每个字符串并存入栈结构，最后再出栈，这样存储空间是O(n)

思路2：去除多余的空格、翻转整个字符串、翻转单个字符串，存储空间是O(1)

### 左旋转字符串

题目：剑指Offer58-II.左旋转字符串

思路：（原地修改）旋转整个字符串、旋转左半字符串、旋转右半字符串

### 旋转字符串回顾

此时我们已经反转好多次字符串了，来一起回顾一下吧。

在这篇文章344.反转字符串 ，第一次讲到反转一个字符串应该怎么做，使用了双指针法。

然后发现541. 反转字符串II ，这里开始给反转加上了一些条件，当需要固定规律一段一段去处理字符串的时候，要想想在for循环的表达式上做做文章。

后来在151.翻转字符串里的单词 中，要对一句话里的单词顺序进行反转，发现先整体反转再局部反转 是一个很妙的思路。

最后再讲到本题，本题则是先局部反转再 整体反转，与151.翻转字符串里的单词 类似，但是也是一种新的思路。

### 实现KMP算法

复习KMP算法，和作者的不一样

主要是理解思路

### 重复的子字符串

题目：第459题

思路1：O(n^2)，字串的长度一定是s的整数倍，并且假设字串长度为i，那么任意的j > i，都有s[j] == s[j - i]

思路2：利用两个s拼接在一起，一定能从中间找到s，因为如果是由重复字符串构成的话，中间的一部分一定是s。但是不能两端找到字串s，因为就是由两个s组成的。

时间复杂度为KMP算法O(m+n)，空间复杂度为O(n)

思路3：在由重复子串组成的字符串中，最长相等前后缀不包含的子串就是最小重复子串

KMP算法的next数组其实就是最长前缀和最长后缀的概念，只不过我在实现的时候是求不包括当前字符的前缀长度

前缀和后缀的概念：

前缀：是指不包含最后一个字符的所有以第一个字符开头的连续子串

后缀：是指不包含第一个字符的所有以最后一个字符结尾的连续子串

作者求的是当前字符的前后缀长度，与我不同，所以作者遇到当前字符不同时，需要查找前一个字符的next值，我要找当前字符的next值，其实是一样的.

只不过作者引入了-1，我不想看了。

### 总结

双指针法、翻转再翻转、KMP

## 栈与队列

### 用栈实现队列

题目：232

思路：栈1用于输入，当输出时需要将所有元素入栈2，这样栈1的栈底元素就是栈2的栈顶元素。

收获：peek用到了pop函数，即实现了代码复用。

在代码开发时一定要注意复用，忌讳实现类似的函数，即把一段代码复制粘贴稍微修改。



### 使用队列实现栈

题目：225

思路1：哪个队列不为空就入哪个队列（如果都为空随便入）；出队就是将有元素的队列的前面所有元素入另一个队列，最后一个元素为出队元素

收获：作者提供使用一个队列的思路，即每次出队时候都再次入队。

### 有效的括号

题目：20.有效的括号

思路：使用栈完成匹配

### 删除字符串中的所有相邻重复项

题目：1047

思路：使用栈完成匹配

收获：1.string的构造函数，并且string的长度不计算空字符

2.**递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中**，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。

**在企业项目开发中，尽量不要使用递归**！在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），**造成栈溢出错误（这种问题还不好排查！）**

### 逆波兰表达式求值

题目：150

思路：使用栈存储数据，当遇到运算符时就出栈两个元素并将结果入栈。

收获：1.**逆波兰表达式相当于是二叉树中的后序遍历**。 大家可以把运算符作为中间节点，按照后序遍历的规则画出一个二叉树。

2.stoi、stol、stoll函数：在头文件string中，将字符串转换为int、long、long long类型的整数。

int stoi(const std::string& str, std::size_t* pos = 0, int base = 10);

注意默认base是10。

### 滑动窗口最大值

题目：239. 滑动窗口最大值

思路：我原本的思路是使用一个队列保存窗口元素，因为要求当前队列最大值，所以需要对队列进行排序，但是排序之后就无法按照原始顺序弹出元素。

收获：

1.作者给出的思路是：并不需要保持所有元素，而是保持一个单调队列，即还是按照原始顺序，但是保持最大元素在队列头，并且按照单调递减的顺序保留数据，删除其他元素。这样保持一个单调队列，push和pop方法改为：

1.pop(value):如果要弹出的元素不是头元素，那么队列不做任何操作

2.push(value):入队时与队尾元素相比，如果队尾更小，就从队尾弹出元素，保持是一个单调的状态。并且从队尾进页保持了原始顺序。

这个队列是按照原始顺序进队和出队的，只是由于最大值不同队列内元素个数不同。

2.了解双端队列dequeue

### 前 K 个高频元素

题目：347.前 K 个高频元素

收获：1.优先级队列表示大顶堆、小顶堆

2.使用小顶堆删除最小的，保留下来的就是k个最大的。

### 总结

在栈与队列系列中，我们强调栈与队列的基础，也是很多同学容易忽视的点。

使用抽象程度越高的语言，越容易忽视其底层实现，而C++相对来说是比较接近底层的语言。

我们用栈实现队列，用队列实现栈来掌握的栈与队列的基本操作。

接着，通过括号匹配问题、字符串去重问题、逆波兰表达式问题来系统讲解了栈在系统中的应用，以及使用技巧。

通过求滑动窗口最大值，以及前K个高频元素介绍了两种队列：单调队列和优先级队列，这是特殊场景解决问题的利器，是一定要掌握的。

## 二叉树

### 二叉树简介

满二叉树、完全二叉树、二叉查找树（搜索树）、平衡二叉搜索树

**二叉搜索树是一个有序树**。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

二叉树存储结构：顺序存储（如果双亲结点是i那么左孩子是2\*i + 1，右孩子是2\*i + 2)和链式存储

题目：2两数相加

思路：模拟加法进位

### 二叉树递归遍历

递归的方法：

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

144.二叉树的前序遍历(opens new window)
145.二叉树的后序遍历(opens new window)
94.二叉树的中序遍历

### 二叉树迭代遍历

前序遍历：使用栈实现

前序处理的方式是：根、左、右，因此向将根节点放入栈、右孩子进入栈、最后左孩子进入栈

**访问和处理的顺序是一致的。**前序遍历的访问顺序是中左右，处理的顺序也是中左右。

```
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // 中
            st.pop();
            result.push_back(node->val);
            if (node->right) st.push(node->right);           // 右（空节点不入栈）
            if (node->left) st.push(node->left);             // 左（空节点不入栈）
        }
        return result;
    }
};
```

中序遍历：处理顺序是中左右，但是访问顺序是一直访问到左孩子结点为空时才会访问中结点，接着以右孩子作为新的根结点。

因此借助指针来访问，使用栈处理。

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```

后序遍历：

将前序遍历稍微修改：前序遍历是中左右->中右左->逆序->左右中

即逆序。

```
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->right) st.push(node->right); // 空节点不入栈
        }
        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
        return result;
    }
};
```

### 二叉树统一迭代法

以中序遍历为例，**将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**要处理的结点放入栈之后，需要加上一个空结点。

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode *> st;
        vector<int> res;

        // 根节入栈
        if (root != nullptr) st.push(root);

        while (!st.empty()) {
            TreeNode *node = st.top();

            if (node != nullptr) {
                // 先将这个结点弹出
                st.pop();

                // 尝试将右孩子入栈
                if (node->right != nullptr) st.push(node->right);
                // 将中结点入栈，并且中间结点已经访问过，作为下一次处理的结点需要标记
                st.push(node);
                st.push(nullptr);

                // 最后将左孩子入栈但是不标记
                if (node->left != nullptr) st.push(node->left);
            } else {
                // 如果栈顶是空指针，说明下一个是需要处理的结点
                st.pop();

                // 将需要处理的结点假如列表
                res.push_back(st.top()->val);
                st.pop();
            }
        }

        return res;
    }
};
```

前序遍历和后序遍历只需要改变左右孩子、中间结点进入栈的顺序即可。

### 二叉树层序遍历

思路1：我的思路是为每层后面加一个空结点标识，当遇到空结点说明上一层处理完了，同时也要在队列中加一个空结点标识现在队列中是一层。

作者的思路1：当队列不为空时，每次处理一层，使在每次循环最开始记录当前队列多少元素，即为当前层数。然后使用for循环处理这size个结点即可。

作者的思路2：使用深度优先遍历，递归的方式，每次处理完根节点之后，接着递归处理左右孩子。

递归参数：当前根结点，保存访问记录的列表，当前深度（因为一层使用一个列表表示，因此需要知道当前深度应该加到哪个列表中）

递归终止条件：当前根结点为空

一层递归逻辑：处理当前根结点，接着处理左右孩子。

题目：

102.二叉树的层序遍历
107.二叉树的层次遍历II
199.二叉树的右视图

20230526：

637.二叉树的层平均值
429.N叉树的层序遍历
515.在每个树行中找最大值

20230527：

116.填充每个节点的下一个右侧节点指针
117.填充每个节点的下一个右侧节点指针II
104.二叉树的最大深度
111.二叉树的最小深度

### 翻转二叉树

题目：226

这道题思路很简单：遍历左右结点，把节点的左右孩子互换即可。我使用的是层序遍历

作者提出前、后序都可以，唯独中序遍历不可。

为什么中序遍历不行：画一下图就可以了。

注意，递归中序不可以，但是迭代中序可以。

**复习**：递归遍历（前中后）、迭代遍历的统一写法

递归遍历的前序遍历又称为深度优先遍历，层序遍历称为广度优先遍历

有时间都写一下。

### 阶段总结

二叉树基本概念

二叉树前中后递归遍历

二叉树前中后迭代遍历：由于中序遍历的访问和处理是不一致的（总是先访问到中间结点，才会访问左右孩子，但是处理的时候是先处理左孩子，再处理中间结点），所以需要一个标志（标识应该被处理）。后序遍历就是前序遍历稍微修改一下：中左右->中右左 这样范围访问之后再逆序即可。

二叉树前中后统一迭代遍历方法

二叉树层序遍历

589.N叉树的前序遍历(opens new window)

590.N叉树的后序遍历

### 对称二叉树

101.对称二叉树

思路：不是比较左右结点，而是比较左右子树的外侧和里侧，这样左子树的左孩子与右子树的右孩子比较，左子树的右孩子与右子树的左孩子比较。

递归的方式：

1.递归返回值和参数：参数为两个结点，返回值是bool

2.递归终止条件：这两个结点存在空结点的情况和不存在空结点的情况

3.递归的逻辑：首先排除空间结点情况和均不是空结点但是不相等的情况，剩下的就是两个结点都不为空并且相等。接着外侧和里侧进行比较。



思路2：使用队列，队列里面的前两个结点是要比较的两个结点。

思路3：使用栈也是一样的。

题目：

100.相同的树
572.另一个树的子树

### 二叉树的最大深度

题目：104、559

思路1：递归法

思路2：迭代法（使用层序遍历比较简单）

收获：

本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。

- 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）

**根节点的高度就是二叉树的最大深度**

### 二叉树的最小深度

题目：111

思路问题：

这就重新审题了，题目中说的是：**最小深度是从根节点到最近叶子节点的最短路径上的节点数量。**，注意是**叶子节点**。

什么是叶子节点，左右孩子都为空的节点才是叶子节点！

如果采用以下递归逻辑：

```
int leftDepth = getDepth(node->left);
int rightDepth = getDepth(node->right);
int result = 1 + min(leftDepth, rightDepth);
return result;
```

那么如果一个结点没有左孩子，那么没有左孩子的分支就会作为最小深度。

正确逻辑应该是：

如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度。

反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。

 最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。

思路2：使用迭代方式的层序遍历。只要遇到左右孩子为空的就输出深度。

### 完全二叉树的节点个数

题目：222

思路：采用层序遍历统一每一层的结点个数。

思路2：还是采用普通二叉树遍历方法，不过采用递归的思路。

作者的思路：采用二叉树的思路：需要判断是否为满二叉树（根据左右结点深度是否一致）

如果是满二叉树，就根据公式计算这个完全二叉树的结点数并返回；

如果不是满二叉树，那就接着遍历返回左右子树的结点数之和+根节点的数量1

### 平衡二叉树

题目：110

明确概念：

- 二叉树节点的深度：指从**根节点**到**该节点**的最长简单路径边的条数。
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。

因为求深度可以从上到下去查 所以需要**前序遍历**（中左右），而高度只能从下到上去查，所以只能**后序遍历**（左右中）

在题目求二叉树**最大深度**时采用的是后序遍历，求的是根节点的高度，也就是高度。

平衡二叉树就是左右子树高度不能相差1

因此采用后序遍历。

参数即返回值：参数是一个子树根结点，返回值是子树高度，如果不是平衡子树就返回-1

终止：当遇到空结点时。

逻辑：

求左右子树高度，注意这里如果子树高度为-1，说明子树不是平衡的，那么以这个根节点的树也不是平衡的。

判断左右子树高度是否相差1以内。



20230606：

103：求最大深度使用前序遍历实现



思路2：迭代法：使用一个函数计算当前节点的深度，然后使用后序遍历判断每个节点的左右子树深度是否一致。





### 二叉树的所有路径

题目：257. 二叉树的所有路径

思路：采用前序遍历，使用递归的形式

递归参数：当前根结点、当前路径、装结果

递归终止：当当前结点左右孩子都为空时，将当前路径转换为string保存在结果中。

每一层递归逻辑：先将当前根节点加入路径、然后尝试对当前节点的左右孩子递归，注意递归返回时要回溯，即从路径中弹出左右孩子。



思路2：使用递归，一个栈用于模拟前序遍历，一个栈用于装从根结点到当前节点的路径。

### 总结

对称二叉树：递归比较两个子树的外侧和内侧

二叉树最大深度：深度指的是从根节点到当前节点的结点个数（适合使用前序遍历，因为首先处理处理当前结点深度），高度指的是从当前结点到叶子结点的结点个数（适合后序遍历，先处理子树的高度再处理根的高度）

二叉树最小深度：需要注意的是深度指的是到叶子结点，即左右孩子结点都为空。

完全二叉树结点数量：采用递归方式，如果是满二叉树，即左右孩子深度一样，就利用公式计算，否则就统计左右孩子加上根节点。

是否为平衡二叉树：递归求左右孩子的高度，判断是否相差1

找寻所有路径：前序遍历递归





### 左叶子之和

题目：404

我的思路：采用前序递归遍历
递归参数为当前子树根节点和保存和的变量，无返回值

递归终止条件为：当前子树根节点为空

递归逻辑：先判断当前子树根节点是否存在左孩子（左孩子指的是左结点并且左结点没有孩子），有就求和

接着递归遍历子树根节点的左右孩子子树。

这里体现了处理和访问的关系。

我的思路2：讲递归遍历换为迭代遍历。

作者：

**节点A的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么A节点的左孩子为左叶子节点**

那么**判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。**

作者改进：

终止条件多了一个：

```
if (root->left == NULL && root->right== NULL) return 0; //其实这个也可以不写，如果不写不影响结果，但就会让递归多进行了一层。
```

即如果这个结点本身就是一个叶子结点，那么不用判断了，因为没有左结点。

### 找树左下角的值

题目：513

我的思路：采用层序遍历，保存每一层最左边的节点的值，当层序遍历完成也就是最底层最左边的值。

作者递归的方法：最左下角要求深度必须是最大的，采用递归时需要记录此时的深度。采用前序遍历访问。

需要全局变量：1.最大深度；2.最大深度最左节点的值

递归参数：当前根节点，当前深度，无返回值

递归终止条件：遇到叶子结点，终止条件需要判断当前是否为最大深度，并且更新最大深度，这里必须时大于最大深度才更新全局节点值，保证保存的是最左。

递归处理逻辑：递归遍历左右孩子。注意需要回溯。

### 路径总和

题目：112

我的思路：采用迭代遍历，但是如果使用一个变量记录到一个叶子节点的路径之和，遇到的问题是回溯。如果一个分支结点只有左孩子没有右孩子，并且到这个左孩子的路径之和不能满足要求，那么回溯的时候需要回溯两次。

作者给出的解决方案是栈中保存结点和到这个结点的路径之和。

作者的思路1：采用递归的方式

递归的参数：当前结点，以及一个计数，初始化为目标值，返回值为true或者false

递归的终止条件：遇到叶子结点，此时需要判断计数值是否为0，为0说明找到了一条路径，直接返回true，否咋返回false

递归单层逻辑：分别处理右左孩子



递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先 (opens new window)中介绍）
如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）



题目 113

思路：采用递归，不过不需要返回。

这里遇到的问题是，注意在本层处理路径的回溯，那么返回曾就不需要再处理回溯。

### 从中序与后序遍历序列构造二叉树

- 106.从中序与后序遍历序列构造二叉树

- 105.从前序与中序遍历序列构造二叉树

  我的思路与作者思路基本一致：递归

  递归的参数：前序列表和后序列表，返回值是构建的树的根节点

  递归的终止条件是两个列表都为空（返回空结点）和都为1（返回一个结点构成的树）

  递归的处理逻辑是：根据前序或者后序找到根节点，将中序分成左右子树，递归构建左右子树。

### 最大二叉树

题目：654

思路：采用递归的方式
递归参数：列表，用于本次构建的列表的左、右边界；返回值：构建的树的根节点
递归终点：左右边界中间个数为0（返回空结点）或者中间个数为1（返回单个结点）
每一层递归逻辑：找到最大值，确定左子树和右子树的列表边界，分别递归。

### 总结

左叶子之和：判断一个左叶子必须根据一个根结点来判断，必须是一个左孩子并且自己没有孩子

左下角的值：采用层序很好理解；递归时需要采用一个变量记录最大深度，第一次到达最大深度时并且为叶子结点就是最左。

路径总和：

中序遍历和后序遍历、中序遍历和前序遍历：

最大二叉树



### 合并二叉树

题目617

想不出来。

作者的思路1：递归的参数：两棵树 返回值：合并到子树的根节点；

递归终止条件：如果第一棵树为空就返回第二课；如果第二课树为空就返回第一颗

递归逻辑：此时两个数的根节点都不为空，因此根节点值相加赋给第一课树

接着第一颗树的左孩子等于，第一颗树的左孩子与第二棵树的左孩子组成新的树；

有孩子也一样。

作者的思路2：采用迭代法，适用队列模拟层序遍历，比较队列前两个结点。

首先排除两棵树都为空的情况，进入队列之后就是队列前两个结点不为空，因此将两个结点相加，值赋给第一个结点。

然后如果两个结点的左孩子都不为空就都入队，右孩子都不为空就都入队。

接着如果第一颗数左孩子为空，但是第二棵树左孩子不为空，那么第一个课树的左孩子就是第二棵树的左孩子。

第一棵树的右孩子如果为空就是第二课树的右孩子。

### 搜索二叉树中的搜索

思路1：采用递归的方式
递归的参数为：子树根节点，目标值；递归的返回值：目标结点
递归的终止：当前根节点为空（返回为空）或者当前结点值为目标值（返回当前节点）
递归逻辑：注意，因为是二叉搜索树，因此左子树的节点的值一定比根结点小，右子树的节点的值一定比根节点大，因此可以根据val与根节点的值的比较情况选择向左还是右子树递归搜索。

思路2：采用迭代的方式，**一提到二叉树遍历的迭代法，可能立刻想起使用栈来模拟深度遍历，使用队列来模拟广度遍历。**但是因为二叉树搜索树是有顺序的，所以直接根据值判断需要放的结点是左子树还是右子树即可。

### 验证二叉搜索树

思路1：**二叉搜索树是有序的，采用中序遍历一定会产生一个有序序列。**因此可以中序遍历生成数组，判断数组是否为递增的。

思路2：将思路1改为递归。使用一个全局变量记录上一次的值，上一次的值必须小于中间的值。

递归参数：当前根节点 递归返回值：true 或者false

递归终止：空结点时

递归逻辑：先递归判断左子树是否为二叉搜索树，此时会更新上一次的值；接着判断当前根节点的值是否大于上一次次的值；最后判断右子树是否为二叉搜索树。

思路3：采用迭代法，判断标准与上面一一致。

### 二叉搜索树的最小绝对差

题目：530

思路：二叉搜索树就是有序数组

收获：当初始值不好赋值时，可以使用指针，将指针初始化为空，当空指针时就知道这是第一次操作。

### 二叉搜索树中的众数

题目：501

思路1：递归，需要全局变量，一个max_count记录最大频率，一个pre_node记录上一个结点（主要是为了记住值），一个count记录上个节点的值出现的次数
递归的参数为：当前子树根结点；无返回值
递归的终止：当遇到空结点时
递归的逻辑：先递归处理左子树，最后递归处理右子树，对于当前根节点的处理在中间（中序遍历），中间的处理逻辑为：如果上一个结点为空指针，说明这是第一次；如果当前根节点的值不等于上一个节点的值，则更新当前频率为1 
然后更新pre_node为当前根节点
最后根据次数更新结果数组：如果count==max_count则需要把当前值加进去；如果大于则之前的结果数组里面的值都作废，只添加当前值；如果小于什么都不做。

思路2：采用迭代法。逻辑一样。



收获：如果不是二叉搜索树，那么就需要遍历整个树，把每个值对应的频数记录
这里是二叉树，所以相等的值一定是连续出现的，因此只要相等就可以频数加1，另外需要记录一个最大频数（如果不记录，那就需要首先遍历一次二叉树，将所有数值的频数记录，再进行一个遍历，找到最大频数）。根据最大频数和当前频数进行更新。

### 二叉树的最近公共祖先

题目236

我的思路：从上到下遍历每个结点，判断当前结点是否为两个目标节点的祖先（即分别判断两个目标结点是否在以当前节点为根节点的子树中），如果是祖先，那么就根据深度判断是否更新最近祖先。

作者的思路：采用回溯法，后序遍历是天然的回溯，先处理左右孩子再根据返回值处理根节点。

递归参数：当前根节点，两个目标结点 递归返回值：结点
递归终止：遇到空的根结点（返回空），或者当前根节点就是其中一个目标结点（返回根节点）
递归逻辑：需要接收左子树和右子树的返回结果，如果都不为空，那么说明当前根节点就是最近的祖先；如果其中一个为空，那么就返回另一个，因为表示在其中一个子树中有目标结点，返回给上一层处理；如果都为空说明没有找到，返回空。

收获：判断递归需不需要返回值的逻辑：

如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？

搜索一条边的写法：

```cpp
if (递归函数(root->left)) return ;

if (递归函数(root->right)) return ;
```

搜索整个树写法：

```cpp
left = 递归函数(root->left);  // 左
right = 递归函数(root->right); // 右
left与right的逻辑处理;         // 中 
```

**在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）**。

### 总结

合并两个二叉树：一起操作两个树

搜索二叉树：利用搜索二叉树的有序性，利用中序遍历将搜索二叉树看作是一个有序数组

判断一个二叉树是否为搜索二叉树：即判断一个二叉树在中序遍历下是否满足递增顺序

二叉搜索树的最小绝对差：也是利用二叉搜索树的有序性，需要注意的是初始化不好赋值时可以利用指针，因为空指针可以作为一个标志来使用

二叉搜索树中的众数

求二叉树的公共祖先：利用回溯到方法从底向上遍历

### 二叉搜索树的最近公共祖先

题目：235

关键：如果当前根节点的值位于p与q之间，说明刚好就是公共祖先。是否为最近公共祖先？如果向左子树继续搜索，那么一定不是q（假设为区间右边界）的祖先，同理对于右子树。

可以采用递归或者迭代的方法。

### 二叉搜索树的插入

思路1：递归
递归的参数：当前根节点，需要插入的结点的值  递归的返回值：无
递归的终止条件：隐含在逻辑中
递归逻辑：首先根据当前根节点的值判断应该插入左子树还是右子树；如果在左子树，先判断当前是有左孩子，如果没有左孩子就把这个值当作左孩子（这也就是终止体条件），如果有左孩子那么继续向左孩子递归；如果在右子树也是一样的处理。

思路2：采用迭代法，处理逻辑相同

### 二叉搜索树的删除

题目：450

找到目标结点之后的处理逻辑：
判断：1.如果左右孩子都为空（即叶子结点）则直接删除该结点，需要一个全局变量记录前一个结点
2.如果其中一个不为空，则让父结点继承这个结点；
3.如果两个都不为空，由于二叉搜索树的性质，这个目标节点的左子树全部结点都小于右子树，所以就可以作为右子树最左节点的子树。

遍历方式：递归和迭代。

作者的思路与我一致。

收获：普通二叉树的删除方式：代码中目标节点（要删除的节点）被操作了两次：

- 第一次是和目标节点的右子树最左面节点交换。

- 第二次直接被NULL覆盖了。

  ```c++
  class Solution {
  public:
      TreeNode* deleteNode(TreeNode* root, int key) {
          if (root == nullptr) return root;
          if (root->val == key) {
              if (root->right == nullptr) { // 这里第二次操作目标值：最终删除的作用
                  return root->left;
              }
              TreeNode *cur = root->right;
              while (cur->left) {
                  cur = cur->left;
              }
              swap(root->val, cur->val); // 这里第一次操作目标值：交换目标值其右子树最左面节点。
          }
          root->left = deleteNode(root->left, key);
          root->right = deleteNode(root->right, key);
          return root;
      }
  };
  ```

  ### 二叉搜索树的修剪
  
  题目：669
  
  思路1：递归的参数：当前根结点，左右边界  **返回值：修建完成的子树**
  递归终止：遇到空结点
  递归逻辑：如果当前结点小于边界，那么递归返回这个结点的右子树；如果当前结点大于边界，那么递归但会这个节点的左子树；如果在边界里面，当前结点的左子树等于递归处理的左子树的结果，右子树等于递归处理的右子树的结果
  
  删除过程就是返回时不返回当前结点，如果不删除就是修改当前结点的左右孩子。
  
  思路2：迭代：第一步是找到一个根节点在范围里面（以这个根节点作为最终的根节点）
  第二步是修剪左子树：修建过程双重循环，内部循环是找到一个大于最低边界的结点（如果左子树小于最低边界，那么就让当前根的左子树为左子树的右孩子），外层循环是不断重复使得左子树大于最低边界。
  
  第三步是修剪右子树。

### 将有序数组换转为二叉搜索树

题目：108

思路1：递归，将数组等分为左右两部分，中间作为根节点，左右子树个数相同，高度差就不会超过1
递归的参数：数组，用于构建子树的下界和上界[low,high)；递归的返回值：构建完成的子树
递归的终止：上界等于下界
递归的逻辑：首先找到中间的下标mid，使用nums[mid]创建根节点，然后使用[low,mid)和[mid+1,high)递归构建左子树和右子树；最后返回当前根节点。

思路2：使用迭代方法，每次循环都是创建一个新的结点，然分别以左右区间再次循环。
作者给出的思路是：先创建左孩子和右孩子（如果区间存在的话），然后留到下一次循环时更新（先存入队列），同时也罢相应的左右区间保存到左区间和右区间队列中。

### 把二叉搜索树转换为累加树

题目：538

我的思路：首先求出整棵树的总和，然后采用中序遍历，中间节点的值等于总和不断减去前一个遍历的节点的值（注意sum累减）

作者的思路：采用逆序操作，中序遍历时采用右中左的顺序，然后当前结点加上上一次遍历的结点的值。

采用迭代法就是我的思路中的逆中序遍历，但是只需要一次中序遍历。

采用递归法：递归参数：当前根节点 递归返回值：无
递归终止条件：遇到空结点
递归处理逻辑：先处理右子树，然后处理当前根节点，最后处理左子树。处理当前根节点的逻辑为：如果前一个结点的指针不为空就累加，然后更新pre指针为当前结点。

**收获：**逆序和正序，sum-nums[i]是顺序遍历（i从0开始），刚好是后面所有元素的和，所以使用逆序比较方便。

### 二叉树总结

- 涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。
- 求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。
- 求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。

注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序，[二叉树：找所有路径 (opens new window)](https://programmercarl.com/0257.二叉树的所有路径.html)也用了前序，这是为了方便让父节点指向子节点。

所以求普通二叉树的属性还是要具体问题具体分析。

我的总结就是，对于二叉树，最重要的是基本遍历方法（分为递归和迭代法），所有对于二叉树的处理都是在遍历的基础上实现的。即遍历顺序和处理顺序是息息相关的。

另外就是要注意二叉树的一些性质，利用性质解决问题。

## 回溯

### 回溯的基本理论

回溯是递归的产物。

回溯相当于穷举搜索。

回溯主要解决的问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

回溯算法抽象为树形结构，回溯法解决的是在集合中递归寻找子集，集合的大小构成树的宽度，递归的深度就是树的深度。

**回溯算法模板：**

- 回溯算法的返回值以及参数：返回值一般为void，但是参数需要根据逻辑来定。

  ```c++
  void backtracking(参数)
  ```

- 回溯算法终止条件：由于是树形结构，所以一般是搜索到叶子节点了，也就找到了满足条件的一个答案，将答案存储起来，结束本次递归。

  ```c++
  if (终止条件) {
      存放结果;
      return;
  }
  ```

- 回溯搜索的遍历过程：在集合中搜索，集合的大小就是树的宽度，递归的深度就是树的深度
  <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png" alt="回溯算法理论基础" style="zoom:80%;" />

  ```c++
  for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
      处理节点;
      backtracking(路径，选择列表); // 递归
      回溯，撤销处理结果
  }
  ```

  for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。

  backtracking这里自己调用自己，实现递归。

  大家可以从图中看出**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。

### 组合问题

题目：77

思路：

![77.组合1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195242899.png)

需要两个全局变量，一个表示所有组合的答案，一个表示当前组合。

回溯参数：集合、k值、集合的起点
回溯终止：当当前组合数目达到k值时
回溯逻辑：循环遍历集合中从集合起点开始的集合元素，将其添加进当前组合，然后继续backtracing，因为函数会处理满足要求的组合，函数返回之后从当前组合中删除刚刚加进去的元素（回溯）。

```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```



### **剪枝优化**

以n=4，k=4为例：
![77.组合4](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130194335207-20230310134409532.png)

图中每一个节点（图中为矩形），就代表本层的一个for循环，那么每一层的for循环从第二个数开始遍历的话，都没有意义，都是无效遍历。

**所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置**。

**如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了**。

注意代码中i，就是for循环里选择的起始位置。

接下来看一下优化过程如下：

1. 已经选择的元素个数：path.size();
2. 还需要的元素个数为: k - path.size();
3. 在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历

为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。



### 组合总和III

题目：216

思路：与上面一致。



剪枝优化：

当path里面的总和大于n时，就可以不用再循环了。

### 电话号码的字母组合

题目：17

思路：想想回溯的宽度就是集合的大小，回溯的深度就是数字字符串的长度，每一层回溯的集合就是这一层数字对应的字符串集合。

使用成员变量保存的：1.最终答案；2.回溯路径；3.数字对应的字符串集合

回溯参数：最终path长度、数字字符串、数字字符串下标
回溯终止：当路径达到最终长度
回溯逻辑：取出本层数字对应的字符串，遍历字符串，尝试将每一个字符加到path结尾，然后进行递归。

优化：参数中最终path的长度就是数字字符串的长度，所以不用传递。

### 回溯总结

回溯就是暴力搜索。

回溯算法的整体思想：看作是对于树结构的操作，**for循环横向遍历，递归纵向遍历，回溯不断调整结果集**。

回溯算法剪枝：**for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够 题目要求的k个元素了，就没有必要搜索了**。

### 组合总和

题目：第39题

思路：回溯的参数：待选集合、目标值、起点
回溯的终止：当path总和大于或者等于target时
回溯的逻辑：注意待选集合中的元素可以重复利用，所以起点每次递归时不用加1

剪枝：先对待选集合进行升序排列，那么当出现加上一个集合中的元素超过target时就可以直接终止本层循环（横向）。

### 组合总和II

题目：40题

遇上一题思路类似：关键是去重，这里集合里的元素是会有重复的，**所谓去重，其实就是使用过的元素不能重复选取**。

回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。

**所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重**。

**强调一下，树层去重的话，需要对数组排序！**

![40.组合总和II](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000918.png)

要去重的是“同一树层上的使用过”，如何判断同一树层上元素（相同的元素）是否使用过了呢。

**如果`candidates[i] == candidates[i - 1]` 并且 `used[i - 1] == false`，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]**。

此时for循环里就应该做continue的操作。

![40.组合总和II1](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000954.png)

在图中将used的变化用橘黄色标注上，可以看出在candidates[i] == candidates[i - 1]相同的情况下：

- used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
- used[i - 1] == false，说明同一树层candidates[i - 1]使用过

### 分割回文串

题目：131

思路：

例如对于字符串abcdef：

- 组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个.....。
- 切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段.....。

所以切割问题，也可以抽象为一棵树形结构，如图：

![131.分割回文串](https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg)

递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。

此时可以发现，切割问题的回溯搜索的过程和组合问题的回溯搜索的过程是差不多的。

回溯的参数：字符串集合、划分的界限
回溯的终止条件：当划分的界限为最后一个字符时
回溯的单层逻辑：遍历剩余的字符串，分别尝试以每一个字符串作为最后界限，切分出一个回文，如果能够切分出一个回文，那么就接着递归；如果不能切出一个回文，就增加i值，重新尝试分割。

### 复原IP地址

题目：93

思路：遇上一题分割回文串一样，都是将分割位置作为遍历的变量
![93.复原IP地址](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123203735933.png)

递归参数：字符串、起点位置
递归终止条件：当分割位置超出字符串最后位置时
递归单层逻辑：以start_index为起点位置，逐渐增加分割位置，切割出一个字符串来。如果这个字符串合法，那么就接着递归，从i+1的位置作为新的起始位置；如果不合法或者path中字符串已经超过4个，则说明本层切割都不合法，应该返回到上一层。

### 子集

题目：78

思路：

![78.子集](https://code-thinking.cdn.bcebos.com/pics/78.%E5%AD%90%E9%9B%86.png)

递归参数：总的数组集合，以及剩余集合下标

递归终止条件：当下标超过集合大小时

递归单层逻辑：添加下一个元素，然后递归。注意在递归最开始需要将path添加到result中。

不需要剪枝，每一个路径都是子集。

### 回溯总结

回溯问题：求组合总和：主要是考虑集合中的元素可以重复使用，那么在递归时就不需要将start_index加1；另外这里可以采取排序之后剪枝的操作。

回溯问题：求总和总和3：这里主要是集合元素中会有重复。答案中要求的是树层去重，也就是不能有两个完全一样的答案。树枝是可以有重复元素的，就是path中的元素可以是重复的。

![40.组合总和II1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123202817973.png)

在图中将used的变化用橘黄色标注上，可以看出在candidates[i] == candidates[i - 1]相同的情况下：

- used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
- used[i - 1] == false，说明同一树层candidates[i - 1]使用过

回溯：分割回文串：使用求解组合问题的思路来解决切割问题，将切割的下标作为递归参数传递。

回溯：复原IP地址：同样是将切割问题看作是组合问题。

回溯：求解子集。

### 子集II

题目：90

思路：与上一题子集思路一致，只不过需要增加一步去重操作。去重的原理就是排序之后利用used数组判断树层重复还是树枝重复。

### 递增子序列

题目：491

思路：与上一题求子集思路一致，不过这里去重不是排序之后，因此不能将当前nums[i]与nums【i-1】比较，而是使用一个集合判断当前元素是否使用过。

![491. 递增子序列1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124200229824.png)

在图中可以看出，**同一父节点下的同层上使用过的元素就不能再使用了**

**`unordered_set<int> uset;` 是记录本层元素是否重复使用，新的一层uset都会重新定义（清空），所以要知道uset只负责本层！**

### 全排列

题目：46

思路：采用回溯的思路，每一树层遍历的集合是未被使用过的元素的集合

递归参数：集合
递归终止：当path元素个数与nums元素个数相同时
递归单层逻辑：需要使用一个全局的used数组记录每个元素在递归树中使用情况，全集中的每个元素都是唯一的，排列只能使用一次，所以使用过的元素不能够再次使用。

![46.全排列](https://code-thinking-1253855093.file.myqcloud.com/pics/20201209174225145.png)

- 时间复杂度: O(n!)
- 空间复杂度: O(n)

### 全排列II

题目：47

思路：在上一题的基础上排序之后去重

**拓展**

大家发现，去重最为关键的代码为：

```cpp
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
    continue;
}
```

**如果改成 `used[i - 1] == true`， 也是正确的!**，去重代码如下：

```cpp
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == true) {
    continue;
}
```

这是为什么呢，就是上面我刚说的，如果要对树层中前一位去重，就用`used[i - 1] == false`，如果要对树枝前一位去重用`used[i - 1] == true`。

**对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！**

这么说是不是有点抽象？

来来来，我就用输入: [1,1,1] 来举一个例子。

树层上去重(used[i - 1] == false)，的树形结构如下：

![47.全排列II2](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201406192.png)

树枝上去重（used[i - 1] == true）的树型结构如下：

![47.全排列II3](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201431571.png)

大家应该很清晰的看到，树层上对前一位去重非常彻底，效率很高，树枝上对前一位去重虽然最后可以得到答案，但是做了很多无用搜索。

### 回溯总结

求子集II：排序之后去重

递增子序列：没有排序，但是需要在每一层遍历中判断同一个父节点只能使用剩余集合中的相同元素一次。

排列1：与组合不同的是每次遍历和集合都是全集，所以需要判断这个元素是否之前已经使用过

排列2：与上一题相比全集中会有重复元素，所以排列之后判断相同元素是否在同一层使用过；同时由于遍历全集，即使与前面元素不同，还需要判断路径上是否已经使用过这个元素。

**性能分析：**

子集问题分析：

- 时间复杂度：$O(n × 2^n)$，因为每一个元素的状态无外乎取与不取，所以时间复杂度为$O(2^n)$，构造每一组子集都需要填进数组，又有需要$O(n)$，最终时间复杂度：$O(n × 2^n)$。
- 空间复杂度：$O(n)$，递归深度为n，所以系统栈所用空间为$O(n)$，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为$O(n)$。

排列问题分析：

- 时间复杂度：$O(n!)$，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ..... 1 = n!。每个叶子节点都会有一个构造全排列填进数组的操作（对应的代码：`result.push_back(path)`），该操作的复杂度为$O(n)$。所以，最终时间复杂度为：n * n!，简化为$O(n!)$。
- 空间复杂度：$O(n)$，和子集问题同理。

组合问题分析：

- 时间复杂度：$O(n × 2^n)$，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。
- 空间复杂度：$O(n)$，和子集问题同理。

**一般说道回溯算法的复杂度，都说是指数级别的时间复杂度，这也算是一个概括**



### 重新安排行程

题目：332

思路：主要思路是按照起点找到这个起点对应的所有终点，然后在这一层中遍历所有的可能的终点集合。对于每一个可能的终点集合，更新起点为这个终点，然后递归。

这个题目中需要按照字典序排列，那么就使用map保存每一个起点对应终点，第一个终点就是字典序最小的。

另外需要注意的是每次都是从全集中寻找，所以要判断一张票是否使用过，这里采用记录次数的方法，次数大于0才可以使用。

递归参数：unordered_map<string, map<string, int>> targets：unordered_map<出发机场, map<到达机场, 航班次数>> targets
递归返回值：bool，如果找到一条路径就返回，这个路径一定是字典序最小的。
递归终止条件：当结果中结点个数为票数+1时
递归单层逻辑：与思路一致。

### N皇后

题目：51

思路：以行为递归树的深度，以列为每层需要遍历的集合。限制条件就是用来判断选中位置是否合法。

在判断一个位置是否合法时，我的思路是根据已经放置的位置标记剩余行不可使用的位置。而作者的思路是放置皇后，看这个位置的同列、斜线上是否存在之前放置的皇后。即我的思路是列出一个白名单再判断，作者的思路是先放置再根据当前位置判断。

### 解数独

题目：37

思路：采用递归和回溯的方式

```c++
class Solution {
public:
    bool IsValid(const vector<vector<char>> &board, const int row,
                 const int col, const char c) {
        // 判断同一行是否有字符c
        for (int j = 0; j < 9; ++j) {
            if (board[row][j] == c)
                return false;
        }
        // 判断同列是否有元素
        for (int i = 0; i < 9; ++i) {
            if (board[i][col] == c)
                return false;
        }
        // 判断3*3的方格内是否存在这个元素
        int start_row = (row / 3) * 3;
        int start_col = (col / 3) * 3;
        for (int i = start_row; i < start_row + 3; ++i) 
            for (int j = start_col; j < start_col + 3; ++j) 
                if (board[i][j] == c) return false;
        
        return true;
    }

    bool BackTrace(vector<vector<char>> &board) {
        for (int row = 0; row < 9; ++row) {
            for (int col = 0; col < 9; ++col) {
                if (board[row][col] != '.') continue;

                // 尝试填充1~9
                for (char c = '1'; c <= '9'; ++c) {
                    if (IsValid(board, row, col, c)) {
                        board[row][col] = c; // 填充字符c
                        if (BackTrace(board)) return true;
                        board[row][col] = '.';
                    }
                }
                // 对于(row, col)位置尝试了9个字符都没成功
                return false;
            }
        }

        // 遍历完所有位置但是没有返回false
        // 说明填充均是正确的
        return true;
    }

    void solveSudoku(vector<vector<char>>& board) {
        BackTrace(board);
    }
};
```



## 贪心

**贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。

**说实话贪心算法并没有固定的套路**。

如何验证可不可以用贪心算法呢？

**最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧**。

一般数学证明有如下两种方法：

- 数学归纳法
- 反证法

看教课书上讲解贪心可以是一堆公式，估计大家连看都不想看，所以数学证明就不在我要讲解的范围内了，大家感兴趣可以自行查找资料。

**面试中基本不会让面试者现场证明贪心的合理性，代码写出来跑过测试用例即可，或者自己能自圆其说理由就行了**。

**刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心**。

贪心算法一般分为如下四步：

- 将问题分解为若干个子问题
- 找出适合的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解

### 分发饼干

题目：455

思路：对于孩子i，从饼干中找到一个刚刚满足的他的饼干大小。

作者的思路：将二者都排序，然后遍历饼干，小饼干先满足小胃口的

### 摆动序列

题目：376

解法1：贪心算法：局部最优：删除单调递增的元素，尽量使得出现波峰和波谷

整体最优：波峰和波谷最多

这样最基本的计算增加子序列长度的条件就是：当前一个差值和后一个差值符号相反时就可以增加

另外需要考虑的是：当出现相等的情况时，即

**情况一：上下坡中有平坡**

例如 [1,2,2,2,1]这样的数组，如图：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20230106170449.png)

它的摇摆序列长度是多少呢？ **其实是长度是 3**，也就是我们在删除的时候 要不删除左面的三个 2，要不就删除右边的三个 2。

如图，可以统一规则，删除左边的三个 2：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20230106172613.png)

在图中，当 i 指向第一个 2 的时候，`prediff > 0 && curdiff = 0` ，当 i 指向最后一个 2 的时候 `prediff = 0 && curdiff < 0`。

如果我们采用，删左面三个 2 的规则，那么 当 `prediff = 0 && curdiff < 0` 也要记录一个峰值，因为他是把之前相同的元素都删掉留下的峰值。

所以我们记录峰值的条件应该是： `(preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)`，为什么这里允许 prediff == 0 ，就是为了 上面我说的这种情况。

另外需要考虑的是计算两个差值需要至少三个数，当数组只有两个数时应该如何处理：
**情况二：单独处理两个元素**

可以直接将两个元素的数组列出来，也可以加入到上面的情况中。

例如序列[2,5]，如果靠统计差值来计算峰值个数就需要考虑数组最左面和最右面的特殊情况。

因为我们在计算 prediff（nums[i] - nums[i-1]） 和 curdiff（nums[i+1] - nums[i]）的时候，至少需要三个数字才能计算，而数组只有两个数字。

这里我们可以写死，就是 如果只有两个元素，且元素不同，那么结果为 2。

不写死的话，如何和我们的判断规则结合在一起呢？

可以假设，数组最前面还有一个数字，那这个数字应该是什么呢？

之前我们在 讨论 情况一：相同数字连续 的时候， prediff = 0 ，curdiff < 0 或者 >0 也记为波谷。

那么为了规则统一，针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即 preDiff = 0，如图：

![376.摆动序列1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124174357612.png)

针对以上情形，result 初始为 1（默认最右面有一个峰值），此时 curDiff > 0 && preDiff <= 0，那么 result++（计算了左面的峰值），最后得到的 result 就是 2（峰值个数为 2 即摆动序列长度为 2）

**情况三：单调坡度有平坡**

在版本一中，我们忽略了一种情况，即 如果在一个单调坡度上有平坡，例如[1,2,2,2,3,4]，如图：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20230108171505.png)

图中，我们可以看出，版本一的代码在三个地方记录峰值，但其实结果因为是 2，因为 单调中的平坡 不能算峰值（即摆动）。

之所以版本一会出问题，是因为我们实时更新了 prediff。

那么我们应该什么时候更新 prediff 呢？

我们**只需要在 这个坡度 摆动变化的时候**，更新 prediff 就行，这样 prediff 在 单调区间有平坡的时候 就不会发生变化，造成我们的误判。

### 最大子序和

题目：53

思路1：暴力破解法：元素下标从第一个元素到最后一个元素，分为作为子序列起始元素，遍历起始元素后面的元素，记录最大子序列和。

思路2：贪心算法：局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。

全局最优：选取最大“连续和”

**局部最优的情况下，并记录最大的“连续和”，可以推出全局最优**。

我的理解：可以将整个序列看成是多个子序列，将多个子序列进行组合成一个更大的子序列，那么只有当子序列之和为正时合并才会使得组合而成的子序列的值变大。

```c++
int maxSubArray(vector<int>& nums) {
    int result = INT32_MIN;
    int count = 0;

    for (int i = 0; i < nums.size(); ++i) {
        count += nums[i];
        if (count > result) result = count;

        if (count < 0) count = 0;
    }

    return result;
}
```

### 总结

**贪心的本质是选择每一阶段的局部最优，从而达到全局最优。**

饼干分发：小饼干尽量满足胃口小的

最长摇摆序列：保持相邻两个元素波动，即删除单调坡度上的点

最大子序列和：将序列看成是多个子序列，只有子序列和为正才能参与组合，子序列和为负只会拉低组合序列的和的大小。













