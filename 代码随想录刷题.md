# 代码随想录

## 数组

### 二分查找

704.二分查找

35.搜索插入位置
34.在排序数组中查找元素的第一个和最后一个位置
69.x 的平方根
367.有效的完全平方数

收获：

1.二分查找法如果失败的话就是应该插入的位置。

2.除2可以用右移1表示。

3.$\sqrt{x}$使用二分法搜索表示为:$k^2\le x$，即搜索最大的整数值；

4.需要注意两个int值相乘的取值范围会超过int，应该使用long long。

### 移除元素

27.移除元素

26.删除排序数组中的重复项
283.移动零
844.比较含退格的字符串
977.有序数组的平方

收获：

1.数组双指针的思路。

### 有序数组的平方

收获：

昨天自己做的思路：找到绝对值最小的位置，左右指针从中间相两边，新的数组从小到大增加元素。

作者的思路：左右指针从最左边和最右边开始，新的数组从最后开始增加大的元素。

### 长度最小的子数组

209.长度最小的子数组

904.水果成篮
76.最小覆盖子串

收获：

主要是滑动窗口的应用。

需要思考：1.窗口里面是什么；2.窗口什么时候右移；3.窗口什么时候收缩。

### 螺旋矩阵

59.螺旋矩阵II

这是一种模型行为类型的题，看上去复杂，第一次遇到。

收获：循环不变量，即在一个循环中保持不变的量，比如二分法循环中不变的是左闭右开区间或者左闭右闭区间，比如简单选择排序中不变的是前i个元素是最小的。

### 总结

作者一共介绍了四种题型和方法，分别是二分法、双指针、滑动窗口、模拟操作（循环不变量）

### 数组部分一刷回顾

数组第一种类型：查找数组元素，对于有序数组，采用二分查找法，二分查找法的关键在于确定查找区间是左闭右开开始左闭右闭，如果是左闭右开，那么循环条件就是左边界小于右边界，并且循环终止时left = right；
如果是左闭右闭，那么循环条件就是左边界<=有边界，并且循环终止时left=right+1。
跳出循环的时候，所有元素都已经比较过，并且如果查找失败跳出循环，此时的下标就应该是这个元素被插入的位置：如果是左闭右开，此时left = right，应该把从right到末尾的元素全部后移；如果是左闭右闭，那么此时left = right + 1，应该把从left到末尾的元素全部后移。

数组第二种类型：双指针法，利用快慢指针对数组进行操作



## 链表

### 删除链表元素

题目：203

收获：删除元素应该先保存链表下一个结点的信息

### 设计链表

题目：707

收获：循环的时候注意循环体执行次数和循环判断条件的关系。

### 翻转链表

题目：206

思路就是使用双指针，值得注意的点就是注意删除操作顺序。

收获：重复的操作可以使用递归实现，，即不断对于两个结点进行翻转。

另一种形式的递归：每次都先翻转后面的链表，后面链表翻转完成之后再进行当前结点的翻转，注意这个递归返回的是最后一个节点值。

栈的思路：遍历一遍链表然后入栈，之后出栈即可。

或者采用头插法。

### 两两交换链表中的结点

题目：24

思路：使用双或者三指针，只需要注意更改next的顺序即可。

### 删除链表中的倒数第n个结点

题目：19

思路：第一个指针先走n步，接着第二个指针跟着第一个结点一起走到尾，就会指向第len-n+1也就是倒数第n个结点。

这题是删除倒数第n个，所以稍有变动。

并且虚拟头结点的好处就是对于第一个结点的操作与其他结点一样，没有虚拟头节点对于头结点的操作需要单独处理。

### 链表相交

题目160

思路：1.将链表A+链表B   链表B+链表A，使用两个指针遍历这两个链表，如果存在相交结点，那么一定相遇在空结点之前。

2.链表A+链表B，判断是否存在循环

作者的思路：求两个链表长度，总之与思路1一样

### 环形链表

题目：142

主要思路：1.使用快慢指针寻找相遇点；2.当第一次相遇时，令其中一个指针指向头结点，两个指针同速前进，再次相遇点就是环的起点。

有三个点：头结点、环的起点、相遇点，相遇点一定在环的起点之后（没到环的起点怎么相遇）。

假设相遇点时slow走了k，那么fast一定走了2k，也就是k一定是环的长度的n倍。

假设相遇点距离环的起点的距离为m，那么环的起点点距离头结点的距离为k-m；即从头结点走k-m到达环的起点。

假如从相遇点开始走，走k一定是重新到达相遇点，那么走k-m是到环的起点。

### 总结

链表的基础操作（删除、插入等）、双指针技巧、删除链表的元素可以删除该结点的后一个元素、环型链表的处理



## 哈希表

主要用于需要判断一个元素是否存在一个数组中时。

### 有效的字母异位词

242.有效的字母异位词

383.赎金信

49.字母异位词分组

438.找到字符串中所有字母异位词

收获：hash表（map）的键值可以是任何东西。比如49题中把string作为键，把列表作为值。

438复习了滑动窗口的使用。



### 两个数组的交集

349.两个数组的交集

350.两个数组的交集 II

收获：主要是set和map的使用，其中set好像更慢一点。

### 快乐数

第202题. 快乐数

收获：学会使用unorder_set

### 两数之和

第1题：两数之和

收获：

- 为什么会想到用哈希表：当需要判断一个元素是否存在时
- 哈希表为什么用map：因为数组的下标只能是int，set没有下标，map用于存一个映射。
- 本题map是用来存什么的：key存target - nums1（第一个加数） value存这个数对应的下标
- map中的key和value用来存什么的

### 四数相加

第454题：

收获：要找的是加数 + 加数 + 加数 + 加数 = 0出现的次数，因此map的key应该是加数，value是出现的次数。

### 赎金信

第383

收获：之前做过，这里由于hash表的长度是固定的（26个小写字母），所以使用数组更加合适。**map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的**

### 三数之和

第15

对于自己来说难以理解：1.hash思路有，但是由于题目中要求不能重复，难以完成。（待完成）

2.使用双指针，先把数组排序，然后需要注意的是：（1）.去重的逻辑：去重a：应该判断与之前的元素是否相同，由于是排序之后的，如果相同说明要么都找不到，要么找到也是重复的；去重bc，在找到第一对bc之后，应该重复判断与他们相邻的是否相等，相等就应该去重。（2）.找到之后两个指针同时跳变

### 四数之和

18

思路：就是在三数之和的基础上加层循环

但是需要注意的是：剪枝的一些细节，比如由于target是一个随机值，不能判断第一个元素大于零就直接返回，因为有可能target是小于第一个元素的。

错误：我的思路是两个双指针，错误的地方是：外层如果用双指针，那么当双指针同时增加时，会漏掉什么元素？？？

这个问题与之前遇到的同时增加的

思考：我的思路：从外层选两个，从内层选两个，

作者的思路：从n个中选一个，从剩下的n-1个中选一个，然后双指针选择剩下的两个

注意：两种方式：（1）从n中选一个，从剩下的n-1中选一个，一共有n(n-1)/2中组合

（2）我的两个指针同时从前后增加，那么只有n/2种组合

而题目明显是要求第一种方式选择，不要漏掉组合。

注意：双指针是如何把从n中选两个的时间复杂度变成n的？

（1）从n中选两个不同的，正常思路就是n的平方；

（2）如果采用双指针，O(n^2)的解法优化为 O(n)的解法，因为一次选中不同的两个？

### 总结

**一般来说哈希表都是用来快速判断一个元素是否出现集合里**。

哈希函数是把传入的key映射到符号表的索引上。

接下来是常见的三种哈希结构：

- 数组
- set（集合）
- map（映射）

**使用set的理由：**

**主要因为如下两点：**

- 数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。
- 如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

**使用map的理由：**

- 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
- set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。

C++提供如下三种map：

- std::map
- std::multimap
- std::unordered_map

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

std::unordered_map 底层实现为哈希，std::map 和std::multimap 的底层实现是红黑树。

在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。

虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。

同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解），[1.两数之和 (opens new window)](https://programmercarl.com/0001.两数之和.html)中并不需要key有序，选择std::unordered_map 效率更高！

## 字符串

**如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。**

### 反转字符串1

题目：第344题

思路：双指针

### 反转字符串2

题目：第341

我的思路：每次取前2k个，用i=1，2，3去乘2k

作者的思路：直接取每个区间的起点，i=0， 2k，

然后在循环中判断i + k是否超过最后字符串结尾即可。

### 替换空格

剑指Offer 05.替换空格

思路：**其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

这么做有两个好处：

1. 不用申请新数组。
2. 从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。

### 151.翻转字符串里的单词

思路1：保存每个字符串并存入栈结构，最后再出栈，这样存储空间是O(n)

思路2：去除多余的空格、翻转整个字符串、翻转单个字符串，存储空间是O(1)

### 左旋转字符串

题目：剑指Offer58-II.左旋转字符串

思路：（原地修改）旋转整个字符串、旋转左半字符串、旋转右半字符串

### 旋转字符串回顾

此时我们已经反转好多次字符串了，来一起回顾一下吧。

在这篇文章344.反转字符串 ，第一次讲到反转一个字符串应该怎么做，使用了双指针法。

然后发现541. 反转字符串II ，这里开始给反转加上了一些条件，当需要固定规律一段一段去处理字符串的时候，要想想在for循环的表达式上做做文章。

后来在151.翻转字符串里的单词 中，要对一句话里的单词顺序进行反转，发现先整体反转再局部反转 是一个很妙的思路。

最后再讲到本题，本题则是先局部反转再 整体反转，与151.翻转字符串里的单词 类似，但是也是一种新的思路。

### 实现KMP算法

复习KMP算法，和作者的不一样

主要是理解思路

### 重复的子字符串

题目：第459题

思路1：O(n^2)，字串的长度一定是s的整数倍，并且假设字串长度为i，那么任意的j > i，都有s[j] == s[j - i]

思路2：利用两个s拼接在一起，一定能从中间找到s，因为如果是由重复字符串构成的话，中间的一部分一定是s。但是不能两端找到字串s，因为就是由两个s组成的。

时间复杂度为KMP算法O(m+n)，空间复杂度为O(n)

思路3：在由重复子串组成的字符串中，最长相等前后缀不包含的子串就是最小重复子串

KMP算法的next数组其实就是最长前缀和最长后缀的概念，只不过我在实现的时候是求不包括当前字符的前缀长度

前缀和后缀的概念：

前缀：是指不包含最后一个字符的所有以第一个字符开头的连续子串

后缀：是指不包含第一个字符的所有以最后一个字符结尾的连续子串

作者求的是当前字符的前后缀长度，与我不同，所以作者遇到当前字符不同时，需要查找前一个字符的next值，我要找当前字符的next值，其实是一样的.

只不过作者引入了-1，我不想看了。

### 总结

双指针法、翻转再翻转、KMP

## 栈与队列

### 用栈实现队列

题目：232

思路：栈1用于输入，当输出时需要将所有元素入栈2，这样栈1的栈底元素就是栈2的栈顶元素。

收获：peek用到了pop函数，即实现了代码复用。

在代码开发时一定要注意复用，忌讳实现类似的函数，即把一段代码复制粘贴稍微修改。



### 使用队列实现栈

题目：225

思路1：哪个队列不为空就入哪个队列（如果都为空随便入）；出队就是将有元素的队列的前面所有元素入另一个队列，最后一个元素为出队元素

收获：作者提供使用一个队列的思路，即每次出队时候都再次入队。

### 有效的括号

题目：20.有效的括号

思路：使用栈完成匹配

### 删除字符串中的所有相邻重复项

题目：1047

思路：使用栈完成匹配

收获：1.string的构造函数，并且string的长度不计算空字符

2.**递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中**，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。

**在企业项目开发中，尽量不要使用递归**！在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），**造成栈溢出错误（这种问题还不好排查！）**

### 逆波兰表达式求值

题目：150

思路：使用栈存储数据，当遇到运算符时就出栈两个元素并将结果入栈。

收获：1.**逆波兰表达式相当于是二叉树中的后序遍历**。 大家可以把运算符作为中间节点，按照后序遍历的规则画出一个二叉树。

2.stoi、stol、stoll函数：在头文件string中，将字符串转换为int、long、long long类型的整数。

int stoi(const std::string& str, std::size_t* pos = 0, int base = 10);

注意默认base是10。

### 滑动窗口最大值

题目：239. 滑动窗口最大值

思路：我原本的思路是使用一个队列保存窗口元素，因为要求当前队列最大值，所以需要对队列进行排序，但是排序之后就无法按照原始顺序弹出元素。

收获：

1.作者给出的思路是：并不需要保持所有元素，而是保持一个单调队列，即还是按照原始顺序，但是保持最大元素在队列头，并且按照单调递减的顺序保留数据，删除其他元素。这样保持一个单调队列，push和pop方法改为：

1.pop(value):如果要弹出的元素不是头元素，那么队列不做任何操作

2.push(value):入队时与队尾元素相比，如果队尾更小，就从队尾弹出元素，保持是一个单调的状态。并且从队尾进页保持了原始顺序。

这个队列是按照原始顺序进队和出队的，只是由于最大值不同队列内元素个数不同。

2.了解双端队列dequeue

### 前 K 个高频元素

题目：347.前 K 个高频元素

收获：1.优先级队列表示大顶堆、小顶堆

2.使用小顶堆删除最小的，保留下来的就是k个最大的。

### 总结

在栈与队列系列中，我们强调栈与队列的基础，也是很多同学容易忽视的点。

使用抽象程度越高的语言，越容易忽视其底层实现，而C++相对来说是比较接近底层的语言。

我们用栈实现队列，用队列实现栈来掌握的栈与队列的基本操作。

接着，通过括号匹配问题、字符串去重问题、逆波兰表达式问题来系统讲解了栈在系统中的应用，以及使用技巧。

通过求滑动窗口最大值，以及前K个高频元素介绍了两种队列：单调队列和优先级队列，这是特殊场景解决问题的利器，是一定要掌握的。

## 二叉树

### 二叉树简介

满二叉树、完全二叉树、二叉查找树（搜索树）、平衡二叉搜索树

**二叉搜索树是一个有序树**。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

二叉树存储结构：顺序存储（如果双亲结点是i那么左孩子是2\*i + 1，右孩子是2\*i + 2)和链式存储

题目：2两数相加

思路：模拟加法进位

### 二叉树递归遍历

递归的方法：

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

144.二叉树的前序遍历(opens new window)
145.二叉树的后序遍历(opens new window)
94.二叉树的中序遍历

### 二叉树迭代遍历

前序遍历：使用栈实现

前序处理的方式是：根、左、右，因此向将根节点放入栈、右孩子进入栈、最后左孩子进入栈

**访问和处理的顺序是一致的。**前序遍历的访问顺序是中左右，处理的顺序也是中左右。

```
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // 中
            st.pop();
            result.push_back(node->val);
            if (node->right) st.push(node->right);           // 右（空节点不入栈）
            if (node->left) st.push(node->left);             // 左（空节点不入栈）
        }
        return result;
    }
};
```

中序遍历：处理顺序是中左右，但是访问顺序是一直访问到左孩子结点为空时才会访问中结点，接着以右孩子作为新的根结点。

因此借助指针来访问，使用栈处理。

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```

后序遍历：

将前序遍历稍微修改：前序遍历是中左右->中右左->逆序->左右中

即逆序。

```
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->right) st.push(node->right); // 空节点不入栈
        }
        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
        return result;
    }
};
```

### 二叉树统一迭代法

以中序遍历为例，**将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**要处理的结点放入栈之后，需要加上一个空结点。

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode *> st;
        vector<int> res;

        // 根节入栈
        if (root != nullptr) st.push(root);

        while (!st.empty()) {
            TreeNode *node = st.top();

            if (node != nullptr) {
                // 先将这个结点弹出
                st.pop();

                // 尝试将右孩子入栈
                if (node->right != nullptr) st.push(node->right);
                // 将中结点入栈，并且中间结点已经访问过，作为下一次处理的结点需要标记
                st.push(node);
                st.push(nullptr);

                // 最后将左孩子入栈但是不标记
                if (node->left != nullptr) st.push(node->left);
            } else {
                // 如果栈顶是空指针，说明下一个是需要处理的结点
                st.pop();

                // 将需要处理的结点假如列表
                res.push_back(st.top()->val);
                st.pop();
            }
        }

        return res;
    }
};
```

前序遍历和后序遍历只需要改变左右孩子、中间结点进入栈的顺序即可。

### 二叉树层序遍历

思路1：我的思路是为每层后面加一个空结点标识，当遇到空结点说明上一层处理完了，同时也要在队列中加一个空结点标识现在队列中是一层。

作者的思路1：当队列不为空时，每次处理一层，使在每次循环最开始记录当前队列多少元素，即为当前层数。然后使用for循环处理这size个结点即可。

作者的思路2：使用深度优先遍历，递归的方式，每次处理完根节点之后，接着递归处理左右孩子。

递归参数：当前根结点，保存访问记录的列表，当前深度（因为一层使用一个列表表示，因此需要知道当前深度应该加到哪个列表中）

递归终止条件：当前根结点为空

一层递归逻辑：处理当前根结点，接着处理左右孩子。

题目：

102.二叉树的层序遍历
107.二叉树的层次遍历II
199.二叉树的右视图

20230526：

637.二叉树的层平均值
429.N叉树的层序遍历
515.在每个树行中找最大值

20230527：

116.填充每个节点的下一个右侧节点指针
117.填充每个节点的下一个右侧节点指针II
104.二叉树的最大深度
111.二叉树的最小深度

### 翻转二叉树

题目：226

这道题思路很简单：遍历左右结点，把节点的左右孩子互换即可。我使用的是层序遍历

作者提出前、后序都可以，唯独中序遍历不可。

为什么中序遍历不行：画一下图就可以了。

注意，递归中序不可以，但是迭代中序可以。

**复习**：递归遍历（前中后）、迭代遍历的统一写法

递归遍历的前序遍历又称为深度优先遍历，层序遍历称为广度优先遍历

有时间都写一下。

### 阶段总结

二叉树基本概念

二叉树前中后递归遍历

二叉树前中后迭代遍历：由于中序遍历的访问和处理是不一致的（总是先访问到中间结点，才会访问左右孩子，但是处理的时候是先处理左孩子，再处理中间结点），所以需要一个标志（标识应该被处理）。后序遍历就是前序遍历稍微修改一下：中左右->中右左 这样范围访问之后再逆序即可。

二叉树前中后统一迭代遍历方法

二叉树层序遍历

589.N叉树的前序遍历(opens new window)

590.N叉树的后序遍历

### 对称二叉树

101.对称二叉树

思路：不是比较左右结点，而是比较左右子树的外侧和里侧，这样左子树的左孩子与右子树的右孩子比较，左子树的右孩子与右子树的左孩子比较。

递归的方式：

1.递归返回值和参数：参数为两个结点，返回值是bool

2.递归终止条件：这两个结点存在空结点的情况和不存在空结点的情况

3.递归的逻辑：首先排除空间结点情况和均不是空结点但是不相等的情况，剩下的就是两个结点都不为空并且相等。接着外侧和里侧进行比较。



思路2：使用队列，队列里面的前两个结点是要比较的两个结点。

思路3：使用栈也是一样的。

题目：

100.相同的树
572.另一个树的子树

### 二叉树的最大深度

题目：104、559

思路1：递归法

思路2：迭代法（使用层序遍历比较简单）

收获：

本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。

- 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）

**根节点的高度就是二叉树的最大深度**

### 二叉树的最小深度

题目：111

思路问题：

这就重新审题了，题目中说的是：**最小深度是从根节点到最近叶子节点的最短路径上的节点数量。**，注意是**叶子节点**。

什么是叶子节点，左右孩子都为空的节点才是叶子节点！

如果采用以下递归逻辑：

```
int leftDepth = getDepth(node->left);
int rightDepth = getDepth(node->right);
int result = 1 + min(leftDepth, rightDepth);
return result;
```

那么如果一个结点没有左孩子，那么没有左孩子的分支就会作为最小深度。

正确逻辑应该是：

如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度。

反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。

 最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。

思路2：使用迭代方式的层序遍历。只要遇到左右孩子为空的就输出深度。

### 完全二叉树的节点个数

题目：222

思路：采用层序遍历统一每一层的结点个数。

思路2：还是采用普通二叉树遍历方法，不过采用递归的思路。

作者的思路：采用二叉树的思路：需要判断是否为满二叉树（根据左右结点深度是否一致）

如果是满二叉树，就根据公式计算这个完全二叉树的结点数并返回；

如果不是满二叉树，那就接着遍历返回左右子树的结点数之和+根节点的数量1

### 平衡二叉树

题目：110

明确概念：

- 二叉树节点的深度：指从**根节点**到**该节点**的最长简单路径边的条数。
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。

因为求深度可以从上到下去查 所以需要**前序遍历**（中左右），而高度只能从下到上去查，所以只能**后序遍历**（左右中）

在题目求二叉树**最大深度**时采用的是后序遍历，求的是根节点的高度，也就是高度。

平衡二叉树就是左右子树高度不能相差1

因此采用后序遍历。

参数即返回值：参数是一个子树根结点，返回值是子树高度，如果不是平衡子树就返回-1

终止：当遇到空结点时。

逻辑：

求左右子树高度，注意这里如果子树高度为-1，说明子树不是平衡的，那么以这个根节点的树也不是平衡的。

判断左右子树高度是否相差1以内。



20230606：

103：求最大深度使用前序遍历实现



思路2：迭代法：使用一个函数计算当前节点的深度，然后使用后序遍历判断每个节点的左右子树深度是否一致。





### 二叉树的所有路径

题目：257. 二叉树的所有路径

思路：采用前序遍历，使用递归的形式

递归参数：当前根结点、当前路径、装结果

递归终止：当当前结点左右孩子都为空时，将当前路径转换为string保存在结果中。

每一层递归逻辑：先将当前根节点加入路径、然后尝试对当前节点的左右孩子递归，注意递归返回时要回溯，即从路径中弹出左右孩子。



思路2：使用递归，一个栈用于模拟前序遍历，一个栈用于装从根结点到当前节点的路径。

### 总结

对称二叉树：递归比较两个子树的外侧和内侧

二叉树最大深度：深度指的是从根节点到当前节点的结点个数（适合使用前序遍历，因为首先处理处理当前结点深度），高度指的是从当前结点到叶子结点的结点个数（适合后序遍历，先处理子树的高度再处理根的高度）

二叉树最小深度：需要注意的是深度指的是到叶子结点，即左右孩子结点都为空。

完全二叉树结点数量：采用递归方式，如果是满二叉树，即左右孩子深度一样，就利用公式计算，否则就统计左右孩子加上根节点。

是否为平衡二叉树：递归求左右孩子的高度，判断是否相差1

找寻所有路径：前序遍历递归





### 左叶子之和

题目：404

我的思路：采用前序递归遍历
递归参数为当前子树根节点和保存和的变量，无返回值

递归终止条件为：当前子树根节点为空

递归逻辑：先判断当前子树根节点是否存在左孩子（左孩子指的是左结点并且左结点没有孩子），有就求和

接着递归遍历子树根节点的左右孩子子树。

这里体现了处理和访问的关系。

我的思路2：讲递归遍历换为迭代遍历。

作者：

**节点A的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么A节点的左孩子为左叶子节点**

那么**判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。**

作者改进：

终止条件多了一个：

```
if (root->left == NULL && root->right== NULL) return 0; //其实这个也可以不写，如果不写不影响结果，但就会让递归多进行了一层。
```

即如果这个结点本身就是一个叶子结点，那么不用判断了，因为没有左结点。

### 找树左下角的值

题目：513

我的思路：采用层序遍历，保存每一层最左边的节点的值，当层序遍历完成也就是最底层最左边的值。

作者递归的方法：最左下角要求深度必须是最大的，采用递归时需要记录此时的深度。采用前序遍历访问。

需要全局变量：1.最大深度；2.最大深度最左节点的值

递归参数：当前根节点，当前深度，无返回值

递归终止条件：遇到叶子结点，终止条件需要判断当前是否为最大深度，并且更新最大深度，这里必须时大于最大深度才更新全局节点值，保证保存的是最左。

递归处理逻辑：递归遍历左右孩子。注意需要回溯。

### 路径总和

题目：112

我的思路：采用迭代遍历，但是如果使用一个变量记录到一个叶子节点的路径之和，遇到的问题是回溯。如果一个分支结点只有左孩子没有右孩子，并且到这个左孩子的路径之和不能满足要求，那么回溯的时候需要回溯两次。

作者给出的解决方案是栈中保存结点和到这个结点的路径之和。

作者的思路1：采用递归的方式

递归的参数：当前结点，以及一个计数，初始化为目标值，返回值为true或者false

递归的终止条件：遇到叶子结点，此时需要判断计数值是否为0，为0说明找到了一条路径，直接返回true，否咋返回false

递归单层逻辑：分别处理右左孩子



递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先 (opens new window)中介绍）
如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）



题目 113

思路：采用递归，不过不需要返回。

这里遇到的问题是，注意在本层处理路径的回溯，那么返回曾就不需要再处理回溯。

### 从中序与后序遍历序列构造二叉树

- 106.从中序与后序遍历序列构造二叉树

- 105.从前序与中序遍历序列构造二叉树

  我的思路与作者思路基本一致：递归

  递归的参数：前序列表和后序列表，返回值是构建的树的根节点

  递归的终止条件是两个列表都为空（返回空结点）和都为1（返回一个结点构成的树）

  递归的处理逻辑是：根据前序或者后序找到根节点，将中序分成左右子树，递归构建左右子树。

### 最大二叉树

题目：654

思路：采用递归的方式
递归参数：列表，用于本次构建的列表的左、右边界；返回值：构建的树的根节点
递归终点：左右边界中间个数为0（返回空结点）或者中间个数为1（返回单个结点）
每一层递归逻辑：找到最大值，确定左子树和右子树的列表边界，分别递归。

### 总结

左叶子之和：判断一个左叶子必须根据一个根结点来判断，必须是一个左孩子并且自己没有孩子

左下角的值：采用层序很好理解；递归时需要采用一个变量记录最大深度，第一次到达最大深度时并且为叶子结点就是最左。

路径总和：

中序遍历和后序遍历、中序遍历和前序遍历：

最大二叉树



### 合并二叉树

题目617

想不出来。

作者的思路1：递归的参数：两棵树 返回值：合并到子树的根节点；

递归终止条件：如果第一棵树为空就返回第二课；如果第二课树为空就返回第一颗

递归逻辑：此时两个数的根节点都不为空，因此根节点值相加赋给第一课树

接着第一颗树的左孩子等于，第一颗树的左孩子与第二棵树的左孩子组成新的树；

有孩子也一样。

作者的思路2：采用迭代法，适用队列模拟层序遍历，比较队列前两个结点。

首先排除两棵树都为空的情况，进入队列之后就是队列前两个结点不为空，因此将两个结点相加，值赋给第一个结点。

然后如果两个结点的左孩子都不为空就都入队，右孩子都不为空就都入队。

接着如果第一颗数左孩子为空，但是第二棵树左孩子不为空，那么第一个课树的左孩子就是第二棵树的左孩子。

第一棵树的右孩子如果为空就是第二课树的右孩子。

### 搜索二叉树中的搜索

思路1：采用递归的方式
递归的参数为：子树根节点，目标值；递归的返回值：目标结点
递归的终止：当前根节点为空（返回为空）或者当前结点值为目标值（返回当前节点）
递归逻辑：注意，因为是二叉搜索树，因此左子树的节点的值一定比根结点小，右子树的节点的值一定比根节点大，因此可以根据val与根节点的值的比较情况选择向左还是右子树递归搜索。

思路2：采用迭代的方式，**一提到二叉树遍历的迭代法，可能立刻想起使用栈来模拟深度遍历，使用队列来模拟广度遍历。**但是因为二叉树搜索树是有顺序的，所以直接根据值判断需要放的结点是左子树还是右子树即可。

### 验证二叉搜索树

思路1：**二叉搜索树是有序的，采用中序遍历一定会产生一个有序序列。**因此可以中序遍历生成数组，判断数组是否为递增的。

思路2：将思路1改为递归。使用一个全局变量记录上一次的值，上一次的值必须小于中间的值。

递归参数：当前根节点 递归返回值：true 或者false

递归终止：空结点时

递归逻辑：先递归判断左子树是否为二叉搜索树，此时会更新上一次的值；接着判断当前根节点的值是否大于上一次次的值；最后判断右子树是否为二叉搜索树。

思路3：采用迭代法，判断标准与上面一一致。

### 二叉搜索树的最小绝对差

题目：530

思路：二叉搜索树就是有序数组

收获：当初始值不好赋值时，可以使用指针，将指针初始化为空，当空指针时就知道这是第一次操作。

### 二叉搜索树中的众数

题目：501

思路1：递归，需要全局变量，一个max_count记录最大频率，一个pre_node记录上一个结点（主要是为了记住值），一个count记录上个节点的值出现的次数
递归的参数为：当前子树根结点；无返回值
递归的终止：当遇到空结点时
递归的逻辑：先递归处理左子树，最后递归处理右子树，对于当前根节点的处理在中间（中序遍历），中间的处理逻辑为：如果上一个结点为空指针，说明这是第一次；如果当前根节点的值不等于上一个节点的值，则更新当前频率为1 
然后更新pre_node为当前根节点
最后根据次数更新结果数组：如果count==max_count则需要把当前值加进去；如果大于则之前的结果数组里面的值都作废，只添加当前值；如果小于什么都不做。

思路2：采用迭代法。逻辑一样。



收获：如果不是二叉搜索树，那么就需要遍历整个树，把每个值对应的频数记录
这里是二叉树，所以相等的值一定是连续出现的，因此只要相等就可以频数加1，另外需要记录一个最大频数（如果不记录，那就需要首先遍历一次二叉树，将所有数值的频数记录，再进行一个遍历，找到最大频数）。根据最大频数和当前频数进行更新。

### 二叉树的最近公共祖先

题目236

我的思路：从上到下遍历每个结点，判断当前结点是否为两个目标节点的祖先（即分别判断两个目标结点是否在以当前节点为根节点的子树中），如果是祖先，那么就根据深度判断是否更新最近祖先。

作者的思路：采用回溯法，后序遍历是天然的回溯，先处理左右孩子再根据返回值处理根节点。

递归参数：当前根节点，两个目标结点 递归返回值：结点
递归终止：遇到空的根结点（返回空），或者当前根节点就是其中一个目标结点（返回根节点）
递归逻辑：需要接收左子树和右子树的返回结果，如果都不为空，那么说明当前根节点就是最近的祖先；如果其中一个为空，那么就返回另一个，因为表示在其中一个子树中有目标结点，返回给上一层处理；如果都为空说明没有找到，返回空。

收获：判断递归需不需要返回值的逻辑：

如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？

搜索一条边的写法：

```cpp
if (递归函数(root->left)) return ;

if (递归函数(root->right)) return ;
```

搜索整个树写法：

```cpp
left = 递归函数(root->left);  // 左
right = 递归函数(root->right); // 右
left与right的逻辑处理;         // 中 
```

**在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）**。

### 总结

合并两个二叉树：一起操作两个树

搜索二叉树：利用搜索二叉树的有序性，利用中序遍历将搜索二叉树看作是一个有序数组

判断一个二叉树是否为搜索二叉树：即判断一个二叉树在中序遍历下是否满足递增顺序

二叉搜索树的最小绝对差：也是利用二叉搜索树的有序性，需要注意的是初始化不好赋值时可以利用指针，因为空指针可以作为一个标志来使用

二叉搜索树中的众数

求二叉树的公共祖先：利用回溯到方法从底向上遍历

### 二叉搜索树的最近公共祖先

题目：235

关键：如果当前根节点的值位于p与q之间，说明刚好就是公共祖先。是否为最近公共祖先？如果向左子树继续搜索，那么一定不是q（假设为区间右边界）的祖先，同理对于右子树。

可以采用递归或者迭代的方法。

### 二叉搜索树的插入

思路1：递归
递归的参数：当前根节点，需要插入的结点的值  递归的返回值：无
递归的终止条件：隐含在逻辑中
递归逻辑：首先根据当前根节点的值判断应该插入左子树还是右子树；如果在左子树，先判断当前是有左孩子，如果没有左孩子就把这个值当作左孩子（这也就是终止体条件），如果有左孩子那么继续向左孩子递归；如果在右子树也是一样的处理。

思路2：采用迭代法，处理逻辑相同

### 二叉搜索树的删除

题目：450

找到目标结点之后的处理逻辑：
判断：1.如果左右孩子都为空（即叶子结点）则直接删除该结点，需要一个全局变量记录前一个结点
2.如果其中一个不为空，则让父结点继承这个结点；
3.如果两个都不为空，由于二叉搜索树的性质，这个目标节点的左子树全部结点都小于右子树，所以就可以作为右子树最左节点的子树。

遍历方式：递归和迭代。

作者的思路与我一致。

收获：普通二叉树的删除方式：代码中目标节点（要删除的节点）被操作了两次：

- 第一次是和目标节点的右子树最左面节点交换。

- 第二次直接被NULL覆盖了。

  ```c++
  class Solution {
  public:
      TreeNode* deleteNode(TreeNode* root, int key) {
          if (root == nullptr) return root;
          if (root->val == key) {
              if (root->right == nullptr) { // 这里第二次操作目标值：最终删除的作用
                  return root->left;
              }
              TreeNode *cur = root->right;
              while (cur->left) {
                  cur = cur->left;
              }
              swap(root->val, cur->val); // 这里第一次操作目标值：交换目标值其右子树最左面节点。
          }
          root->left = deleteNode(root->left, key);
          root->right = deleteNode(root->right, key);
          return root;
      }
  };
  ```

  ### 二叉搜索树的修剪
  
  题目：669
  
  思路1：递归的参数：当前根结点，左右边界  **返回值：修建完成的子树**
  递归终止：遇到空结点
  递归逻辑：如果当前结点小于边界，那么递归返回这个结点的右子树；如果当前结点大于边界，那么递归但会这个节点的左子树；如果在边界里面，当前结点的左子树等于递归处理的左子树的结果，右子树等于递归处理的右子树的结果
  
  删除过程就是返回时不返回当前结点，如果不删除就是修改当前结点的左右孩子。
  
  思路2：迭代：第一步是找到一个根节点在范围里面（以这个根节点作为最终的根节点）
  第二步是修剪左子树：修建过程双重循环，内部循环是找到一个大于最低边界的结点（如果左子树小于最低边界，那么就让当前根的左子树为左子树的右孩子），外层循环是不断重复使得左子树大于最低边界。
  
  第三步是修剪右子树。

### 将有序数组换转为二叉搜索树

题目：108

思路1：递归，将数组等分为左右两部分，中间作为根节点，左右子树个数相同，高度差就不会超过1
递归的参数：数组，用于构建子树的下界和上界[low,high)；递归的返回值：构建完成的子树
递归的终止：上界等于下界
递归的逻辑：首先找到中间的下标mid，使用nums[mid]创建根节点，然后使用[low,mid)和[mid+1,high)递归构建左子树和右子树；最后返回当前根节点。

思路2：使用迭代方法，每次循环都是创建一个新的结点，然分别以左右区间再次循环。
作者给出的思路是：先创建左孩子和右孩子（如果区间存在的话），然后留到下一次循环时更新（先存入队列），同时也罢相应的左右区间保存到左区间和右区间队列中。

### 把二叉搜索树转换为累加树

题目：538

我的思路：首先求出整棵树的总和，然后采用中序遍历，中间节点的值等于总和不断减去前一个遍历的节点的值（注意sum累减）

作者的思路：采用逆序操作，中序遍历时采用右中左的顺序，然后当前结点加上上一次遍历的结点的值。

采用迭代法就是我的思路中的逆中序遍历，但是只需要一次中序遍历。

采用递归法：递归参数：当前根节点 递归返回值：无
递归终止条件：遇到空结点
递归处理逻辑：先处理右子树，然后处理当前根节点，最后处理左子树。处理当前根节点的逻辑为：如果前一个结点的指针不为空就累加，然后更新pre指针为当前结点。

**收获：**逆序和正序，sum-nums[i]是顺序遍历（i从0开始），刚好是后面所有元素的和，所以使用逆序比较方便。

### 二叉树总结

- 涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。
- 求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。
- 求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。

注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序，[二叉树：找所有路径 (opens new window)](https://programmercarl.com/0257.二叉树的所有路径.html)也用了前序，这是为了方便让父节点指向子节点。

所以求普通二叉树的属性还是要具体问题具体分析。

我的总结就是，对于二叉树，最重要的是基本遍历方法（分为递归和迭代法），所有对于二叉树的处理都是在遍历的基础上实现的。即遍历顺序和处理顺序是息息相关的。

另外就是要注意二叉树的一些性质，利用性质解决问题。

## 回溯

### 回溯的基本理论

回溯是递归的产物。

回溯相当于穷举搜索。

回溯主要解决的问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

回溯算法抽象为树形结构，回溯法解决的是在集合中递归寻找子集，集合的大小构成树的宽度，递归的深度就是树的深度。

**回溯算法模板：**

- 回溯算法的返回值以及参数：返回值一般为void，但是参数需要根据逻辑来定。

  ```c++
  void backtracking(参数)
  ```

- 回溯算法终止条件：由于是树形结构，所以一般是搜索到叶子节点了，也就找到了满足条件的一个答案，将答案存储起来，结束本次递归。

  ```c++
  if (终止条件) {
      存放结果;
      return;
  }
  ```

- 回溯搜索的遍历过程：在集合中搜索，集合的大小就是树的宽度，递归的深度就是树的深度
  <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png" alt="回溯算法理论基础" style="zoom:80%;" />

  ```c++
  for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
      处理节点;
      backtracking(路径，选择列表); // 递归
      回溯，撤销处理结果
  }
  ```

  for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。

  backtracking这里自己调用自己，实现递归。

  大家可以从图中看出**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。

### 组合问题

题目：77

思路：

![77.组合1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195242899.png)

需要两个全局变量，一个表示所有组合的答案，一个表示当前组合。

回溯参数：集合、k值、集合的起点
回溯终止：当当前组合数目达到k值时
回溯逻辑：循环遍历集合中从集合起点开始的集合元素，将其添加进当前组合，然后继续backtracing，因为函数会处理满足要求的组合，函数返回之后从当前组合中删除刚刚加进去的元素（回溯）。

```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```



### **剪枝优化**

以n=4，k=4为例：
![77.组合4](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130194335207-20230310134409532.png)

图中每一个节点（图中为矩形），就代表本层的一个for循环，那么每一层的for循环从第二个数开始遍历的话，都没有意义，都是无效遍历。

**所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置**。

**如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了**。

注意代码中i，就是for循环里选择的起始位置。

接下来看一下优化过程如下：

1. 已经选择的元素个数：path.size();
2. 还需要的元素个数为: k - path.size();
3. 在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历

为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。



### 组合总和III

题目：216

思路：与上面一致。



剪枝优化：

当path里面的总和大于n时，就可以不用再循环了。

### 电话号码的字母组合

题目：17

思路：想想回溯的宽度就是集合的大小，回溯的深度就是数字字符串的长度，每一层回溯的集合就是这一层数字对应的字符串集合。

使用成员变量保存的：1.最终答案；2.回溯路径；3.数字对应的字符串集合

回溯参数：最终path长度、数字字符串、数字字符串下标
回溯终止：当路径达到最终长度
回溯逻辑：取出本层数字对应的字符串，遍历字符串，尝试将每一个字符加到path结尾，然后进行递归。

优化：参数中最终path的长度就是数字字符串的长度，所以不用传递。

### 回溯总结

回溯就是暴力搜索。

回溯算法的整体思想：看作是对于树结构的操作，**for循环横向遍历，递归纵向遍历，回溯不断调整结果集**。

回溯算法剪枝：**for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够 题目要求的k个元素了，就没有必要搜索了**。

### 组合总和

题目：第39题

思路：回溯的参数：待选集合、目标值、起点
回溯的终止：当path总和大于或者等于target时
回溯的逻辑：注意待选集合中的元素可以重复利用，所以起点每次递归时不用加1

剪枝：先对待选集合进行升序排列，那么当出现加上一个集合中的元素超过target时就可以直接终止本层循环（横向）。

### 组合总和II

题目：40题

遇上一题思路类似：关键是去重，这里集合里的元素是会有重复的，**所谓去重，其实就是使用过的元素不能重复选取**。

回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。

**所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重**。

**强调一下，树层去重的话，需要对数组排序！**

![40.组合总和II](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000918.png)

要去重的是“同一树层上的使用过”，如何判断同一树层上元素（相同的元素）是否使用过了呢。

**如果`candidates[i] == candidates[i - 1]` 并且 `used[i - 1] == false`，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]**。

此时for循环里就应该做continue的操作。

![40.组合总和II1](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000954.png)

在图中将used的变化用橘黄色标注上，可以看出在candidates[i] == candidates[i - 1]相同的情况下：

- used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
- used[i - 1] == false，说明同一树层candidates[i - 1]使用过

### 分割回文串

题目：131

思路：

例如对于字符串abcdef：

- 组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个.....。
- 切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段.....。

所以切割问题，也可以抽象为一棵树形结构，如图：

![131.分割回文串](https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg)

递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。

此时可以发现，切割问题的回溯搜索的过程和组合问题的回溯搜索的过程是差不多的。

回溯的参数：字符串集合、划分的界限
回溯的终止条件：当划分的界限为最后一个字符时
回溯的单层逻辑：遍历剩余的字符串，分别尝试以每一个字符串作为最后界限，切分出一个回文，如果能够切分出一个回文，那么就接着递归；如果不能切出一个回文，就增加i值，重新尝试分割。

### 复原IP地址

题目：93

思路：遇上一题分割回文串一样，都是将分割位置作为遍历的变量
![93.复原IP地址](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123203735933.png)

递归参数：字符串、起点位置
递归终止条件：当分割位置超出字符串最后位置时
递归单层逻辑：以start_index为起点位置，逐渐增加分割位置，切割出一个字符串来。如果这个字符串合法，那么就接着递归，从i+1的位置作为新的起始位置；如果不合法或者path中字符串已经超过4个，则说明本层切割都不合法，应该返回到上一层。

### 子集

题目：78

思路：

![78.子集](https://code-thinking.cdn.bcebos.com/pics/78.%E5%AD%90%E9%9B%86.png)

递归参数：总的数组集合，以及剩余集合下标

递归终止条件：当下标超过集合大小时

递归单层逻辑：添加下一个元素，然后递归。注意在递归最开始需要将path添加到result中。

不需要剪枝，每一个路径都是子集。

### 回溯总结

回溯问题：求组合总和：主要是考虑集合中的元素可以重复使用，那么在递归时就不需要将start_index加1；另外这里可以采取排序之后剪枝的操作。

回溯问题：求总和总和3：这里主要是集合元素中会有重复。答案中要求的是树层去重，也就是不能有两个完全一样的答案。树枝是可以有重复元素的，就是path中的元素可以是重复的。

![40.组合总和II1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123202817973.png)

在图中将used的变化用橘黄色标注上，可以看出在candidates[i] == candidates[i - 1]相同的情况下：

- used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
- used[i - 1] == false，说明同一树层candidates[i - 1]使用过

回溯：分割回文串：使用求解组合问题的思路来解决切割问题，将切割的下标作为递归参数传递。

回溯：复原IP地址：同样是将切割问题看作是组合问题。

回溯：求解子集。

### 子集II

题目：90

思路：与上一题子集思路一致，只不过需要增加一步去重操作。去重的原理就是排序之后利用used数组判断树层重复还是树枝重复。

### 递增子序列

题目：491

思路：与上一题求子集思路一致，不过这里去重不是排序之后，因此不能将当前nums[i]与nums【i-1】比较，而是使用一个集合判断当前元素是否使用过。

![491. 递增子序列1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124200229824.png)

在图中可以看出，**同一父节点下的同层上使用过的元素就不能再使用了**

**`unordered_set<int> uset;` 是记录本层元素是否重复使用，新的一层uset都会重新定义（清空），所以要知道uset只负责本层！**

### 全排列

题目：46

思路：采用回溯的思路，每一树层遍历的集合是未被使用过的元素的集合

递归参数：集合
递归终止：当path元素个数与nums元素个数相同时
递归单层逻辑：需要使用一个全局的used数组记录每个元素在递归树中使用情况，全集中的每个元素都是唯一的，排列只能使用一次，所以使用过的元素不能够再次使用。

![46.全排列](https://code-thinking-1253855093.file.myqcloud.com/pics/20201209174225145.png)

- 时间复杂度: O(n!)
- 空间复杂度: O(n)

### 全排列II

题目：47

思路：在上一题的基础上排序之后去重

**拓展**

大家发现，去重最为关键的代码为：

```cpp
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
    continue;
}
```

**如果改成 `used[i - 1] == true`， 也是正确的!**，去重代码如下：

```cpp
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == true) {
    continue;
}
```

这是为什么呢，就是上面我刚说的，如果要对树层中前一位去重，就用`used[i - 1] == false`，如果要对树枝前一位去重用`used[i - 1] == true`。

**对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！**

这么说是不是有点抽象？

来来来，我就用输入: [1,1,1] 来举一个例子。

树层上去重(used[i - 1] == false)，的树形结构如下：

![47.全排列II2](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201406192.png)

树枝上去重（used[i - 1] == true）的树型结构如下：

![47.全排列II3](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201431571.png)

大家应该很清晰的看到，树层上对前一位去重非常彻底，效率很高，树枝上对前一位去重虽然最后可以得到答案，但是做了很多无用搜索。

### 回溯总结

求子集II：排序之后去重

递增子序列：没有排序，但是需要在每一层遍历中判断同一个父节点只能使用剩余集合中的相同元素一次。

排列1：与组合不同的是每次遍历和集合都是全集，所以需要判断这个元素是否之前已经使用过

排列2：与上一题相比全集中会有重复元素，所以排列之后判断相同元素是否在同一层使用过；同时由于遍历全集，即使与前面元素不同，还需要判断路径上是否已经使用过这个元素。

**性能分析：**

子集问题分析：

- 时间复杂度：$O(n × 2^n)$，因为每一个元素的状态无外乎取与不取，所以时间复杂度为$O(2^n)$，构造每一组子集都需要填进数组，又有需要$O(n)$，最终时间复杂度：$O(n × 2^n)$。
- 空间复杂度：$O(n)$，递归深度为n，所以系统栈所用空间为$O(n)$，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为$O(n)$。

排列问题分析：

- 时间复杂度：$O(n!)$，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ..... 1 = n!。每个叶子节点都会有一个构造全排列填进数组的操作（对应的代码：`result.push_back(path)`），该操作的复杂度为$O(n)$。所以，最终时间复杂度为：n * n!，简化为$O(n!)$。
- 空间复杂度：$O(n)$，和子集问题同理。

组合问题分析：

- 时间复杂度：$O(n × 2^n)$，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。
- 空间复杂度：$O(n)$，和子集问题同理。

**一般说道回溯算法的复杂度，都说是指数级别的时间复杂度，这也算是一个概括**



### 重新安排行程

题目：332

思路：主要思路是按照起点找到这个起点对应的所有终点，然后在这一层中遍历所有的可能的终点集合。对于每一个可能的终点集合，更新起点为这个终点，然后递归。

这个题目中需要按照字典序排列，那么就使用map保存每一个起点对应终点，第一个终点就是字典序最小的。

另外需要注意的是每次都是从全集中寻找，所以要判断一张票是否使用过，这里采用记录次数的方法，次数大于0才可以使用。

递归参数：unordered_map<string, map<string, int>> targets：unordered_map<出发机场, map<到达机场, 航班次数>> targets
递归返回值：bool，如果找到一条路径就返回，这个路径一定是字典序最小的。
递归终止条件：当结果中结点个数为票数+1时
递归单层逻辑：与思路一致。

### N皇后

题目：51

思路：以行为递归树的深度，以列为每层需要遍历的集合。限制条件就是用来判断选中位置是否合法。

在判断一个位置是否合法时，我的思路是根据已经放置的位置标记剩余行不可使用的位置。而作者的思路是放置皇后，看这个位置的同列、斜线上是否存在之前放置的皇后。即我的思路是列出一个白名单再判断，作者的思路是先放置再根据当前位置判断。

### 解数独

题目：37

思路：采用递归和回溯的方式

```c++
class Solution {
public:
    bool IsValid(const vector<vector<char>> &board, const int row,
                 const int col, const char c) {
        // 判断同一行是否有字符c
        for (int j = 0; j < 9; ++j) {
            if (board[row][j] == c)
                return false;
        }
        // 判断同列是否有元素
        for (int i = 0; i < 9; ++i) {
            if (board[i][col] == c)
                return false;
        }
        // 判断3*3的方格内是否存在这个元素
        int start_row = (row / 3) * 3;
        int start_col = (col / 3) * 3;
        for (int i = start_row; i < start_row + 3; ++i) 
            for (int j = start_col; j < start_col + 3; ++j) 
                if (board[i][j] == c) return false;
        
        return true;
    }

    bool BackTrace(vector<vector<char>> &board) {
        for (int row = 0; row < 9; ++row) {
            for (int col = 0; col < 9; ++col) {
                if (board[row][col] != '.') continue;

                // 尝试填充1~9
                for (char c = '1'; c <= '9'; ++c) {
                    if (IsValid(board, row, col, c)) {
                        board[row][col] = c; // 填充字符c
                        if (BackTrace(board)) return true;
                        board[row][col] = '.';
                    }
                }
                // 对于(row, col)位置尝试了9个字符都没成功
                return false;
            }
        }

        // 遍历完所有位置但是没有返回false
        // 说明填充均是正确的
        return true;
    }

    void solveSudoku(vector<vector<char>>& board) {
        BackTrace(board);
    }
};
```

## 分治与递归、动态规划、贪心

**分治法解决思路：**

- 分解：将一个大问题分解成多个小问题（可以分解成两个问题或者多个问题
- 递归：递归解决每个小问题
- 合并：由子问题的解（小问题一定有边界条件）合并出大问题的解

比如斐波那契数列，假如要计算F(4)，可以将这个问题分解为
1.计算F(3)和F(2);
2.计算F(3)分解为计算F(2)和F(1);计算F(2)分解为计算F(1)和F(0);
3.得出子问题的解之后就可以组合出大问题的解。



**动态规划解题思路：**

基本性质：1.在分治法中会出现**子问题重叠**的现象。比如上面的例子中，会重复求F(2)与F(1)等。
2.最优子结构性质：原问题的最优解一定包含了子问题的最优解

基本步骤：
1、定义子问题，分析**最优解**的结构特征；
2、找出最优解对应的**最优值**，并递归地定义最优值；
3、以自底向上的方式计算出**最优值**；
4、根据计算**最优值**时得到的信息，构造最优解

比如求解斐波那契数列，求解F(n)，表示最优解，同时代表了最优值。那么F(n) = F(n - 1) + F(n - 2)。
于是就可以自底向上计算问题。f(1),f(2),f(3)...f(n)

**动态规划与分治法比较：**
1.对于子问题的划分：分治法常常对半分，动态规划是划分成n-1
2.求解过程：分治法采用递归，动态规划采用自底向上



## 贪心

**贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。

**说实话贪心算法并没有固定的套路**。

如何验证可不可以用贪心算法呢？

**最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧**。

一般数学证明有如下两种方法：

- 数学归纳法
- 反证法

看教课书上讲解贪心可以是一堆公式，估计大家连看都不想看，所以数学证明就不在我要讲解的范围内了，大家感兴趣可以自行查找资料。

**面试中基本不会让面试者现场证明贪心的合理性，代码写出来跑过测试用例即可，或者自己能自圆其说理由就行了**。

**刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心**。

贪心算法一般分为如下四步：

- 将问题分解为若干个子问题
- 找出适合的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解

### 分发饼干

题目：455

思路：对于孩子i，从饼干中找到一个刚刚满足的他的饼干大小。

作者的思路：将二者都排序，然后遍历饼干，小饼干先满足小胃口的

### 摆动序列

题目：376

解法1：贪心算法：局部最优：删除单调递增的元素，尽量使得出现波峰和波谷

整体最优：波峰和波谷最多

这样最基本的计算增加子序列长度的条件就是：当前一个差值和后一个差值符号相反时就可以增加

另外需要考虑的是：当出现相等的情况时，即

**情况一：上下坡中有平坡**

例如 [1,2,2,2,1]这样的数组，如图：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20230106170449.png)

它的摇摆序列长度是多少呢？ **其实是长度是 3**，也就是我们在删除的时候 要不删除左面的三个 2，要不就删除右边的三个 2。

如图，可以统一规则，删除左边的三个 2：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20230106172613.png)

在图中，当 i 指向第一个 2 的时候，`prediff > 0 && curdiff = 0` ，当 i 指向最后一个 2 的时候 `prediff = 0 && curdiff < 0`。

如果我们采用，删左面三个 2 的规则，那么 当 `prediff = 0 && curdiff < 0` 也要记录一个峰值，因为他是把之前相同的元素都删掉留下的峰值。

所以我们记录峰值的条件应该是： `(preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)`，为什么这里允许 prediff == 0 ，就是为了 上面我说的这种情况。

另外需要考虑的是计算两个差值需要至少三个数，当数组只有两个数时应该如何处理：
**情况二：单独处理两个元素**

可以直接将两个元素的数组列出来，也可以加入到上面的情况中。

例如序列[2,5]，如果靠统计差值来计算峰值个数就需要考虑数组最左面和最右面的特殊情况。

因为我们在计算 prediff（nums[i] - nums[i-1]） 和 curdiff（nums[i+1] - nums[i]）的时候，至少需要三个数字才能计算，而数组只有两个数字。

这里我们可以写死，就是 如果只有两个元素，且元素不同，那么结果为 2。

不写死的话，如何和我们的判断规则结合在一起呢？

可以假设，数组最前面还有一个数字，那这个数字应该是什么呢？

之前我们在 讨论 情况一：相同数字连续 的时候， prediff = 0 ，curdiff < 0 或者 >0 也记为波谷。

那么为了规则统一，针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即 preDiff = 0，如图：

![376.摆动序列1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124174357612.png)

针对以上情形，result 初始为 1（默认最右面有一个峰值），此时 curDiff > 0 && preDiff <= 0，那么 result++（计算了左面的峰值），最后得到的 result 就是 2（峰值个数为 2 即摆动序列长度为 2）

**情况三：单调坡度有平坡**

在版本一中，我们忽略了一种情况，即 如果在一个单调坡度上有平坡，例如[1,2,2,2,3,4]，如图：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20230108171505.png)

图中，我们可以看出，版本一的代码在三个地方记录峰值，但其实结果因为是 2，因为 单调中的平坡 不能算峰值（即摆动）。

之所以版本一会出问题，是因为我们实时更新了 prediff。

那么我们应该什么时候更新 prediff 呢？

我们**只需要在 这个坡度 摆动变化的时候**，更新 prediff 就行，这样 prediff 在 单调区间有平坡的时候 就不会发生变化，造成我们的误判。

### 最大子序和

题目：53

思路1：暴力破解法：元素下标从第一个元素到最后一个元素，分为作为子序列起始元素，遍历起始元素后面的元素，记录最大子序列和。

思路2：贪心算法：局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。

全局最优：选取最大“连续和”

**局部最优的情况下，并记录最大的“连续和”，可以推出全局最优**。

我的理解：可以将整个序列看成是多个子序列，将多个子序列进行组合成一个更大的子序列，那么只有当子序列之和为正时合并才会使得组合而成的子序列的值变大。

```c++
int maxSubArray(vector<int>& nums) {
    int result = INT32_MIN;
    int count = 0;

    for (int i = 0; i < nums.size(); ++i) {
        count += nums[i];
        if (count > result) result = count;

        if (count < 0) count = 0;
    }

    return result;
}
```

### 总结

**贪心的本质是选择每一阶段的局部最优，从而达到全局最优。**

饼干分发：小饼干尽量满足胃口小的

最长摇摆序列：保持相邻两个元素波动，即删除单调坡度上的点

最大子序列和：将序列看成是多个子序列，只有子序列和为正才能参与组合，子序列和为负只会拉低组合序列的和的大小。

### 买卖股票的最佳时机II

题目：122

我的思路：买入股票之后，只要股票价格在涨，就不卖出；当股票价格下跌时就立即卖出。

特殊情况是整个序列都是递增的，不会出现下降，这个时候需要判断是否为最后一个元素

```
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int profit = 0;
        int in, out;
        in = prices[0];
        for (int i = 1; i < prices.size(); ++i) {
            if (prices[i - 1] <= prices[i] && i != prices.size() - 1) {
                continue;
            } else if (prices[i - 1] <= prices[i] && i == prices.size() - 1) {
                profit += prices[i] - in;
                break;
            } else {
                out = prices[i - 1];
                profit += out - in;

                in = prices[i];
            }
        }

        return profit;
    }
};
```

作者的思路：**如果想到其实最终利润是可以分解的，那么本题就很容易了！**

如何分解呢？

假如第 0 天买入，第 3 天卖出，那么利润为：prices[3] - prices[0]。

相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。

**此时就是把利润分解为每天为单位的维度，而不是从 0 天到第 3 天整体去考虑！**

那么根据 prices 可以得到每天的利润序列：(prices[i] - prices[i - 1]).....(prices[1] - prices[0])。

如图：

![122.买卖股票的最佳时机II](https://code-thinking-1253855093.file.myqcloud.com/pics/2020112917480858-20230310134659477.png)

**局部最优：收集每天的正利润，全局最优：求得最大利润**。

局部最优可以推出全局最优，找不出反例，试一试贪心

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int profit = 0;
        for (int i = 1; i < prices.size(); i++) {
            profit += max(prices[i] - prices[i - 1], 0);
        }

        return profit;
    }
};
```

### 跳跃游戏

题目：55

思路1：贪心算法
每次可以跳跃的最大距离是nums[i]，这表示下一步可以走的距离是[i+1, i+nums[i]]，如果nums[i]为0，表示永远不可能到达重点。
局部最优：跳跃到下一步最大距离最大的位置，这样下一次可供选择的跳跃点更多，这里注意应该是覆盖范围更大。
整体最优：所有的覆盖范围累加如果能够超越边界就可以跳出去。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230203105634.png" alt="img" style="zoom: 50%;" />

### 跳跃游戏II

题目：45

思路1：每一步尽可能的多走，但是不能有多远就跳多远，因为这样就不能确定下一步能够到达哪里。

注意覆盖范围内是一步可以跳到的，因此更新下一步的覆盖范围时也是尽可能使得下一步的覆盖范围达到最大。

总体思路是：计算当前可以到达的最大范围，这是一步可以到达的范围；那么然后比较这些范围内下一步可以到达的范围，选择下一步最大范围的跳，这样能够保证以最小步数来扩充范围。跳跃之后判断点是否超过终点，超过终点就结束。

**这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖**。

如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。

如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201201232309103.png" alt="45.跳跃游戏II" style="zoom:67%;" />

从图中可以看出来，就是移动下标达到了当前覆盖的最远距离下标时，步数就要加一，来增加覆盖距离。最后的步数就是最少步数。

这里还是有个特殊情况需要考虑，当移动下标达到了当前覆盖的最远距离下标时

- 如果当前覆盖最远距离下标不是是集合终点，步数就加一，还需要继续走。
- 如果当前覆盖最远距离下标就是是集合终点，步数不用加一，因为不能再往后走了。

### K次取反后最大化的数组和

题目：1005

我的思路：
设负数个数为neg，则首先应该把负数编程正数才能使得和最大，所以整体思路为：
如果neg 大于等于 k：那么把所有的负数变成正数就可以；
如果neg 小于k：判断是否存在0：如果存在0，那么剩下的次数全变化0即可；否则接着判断剩下次数的奇偶：如果是偶数，那么可以将一个正数来回变化偶数次，不影响最后结果；如果是奇数，那么前面的偶数次可以用来做反复变化，最后一次将最小的正数编程负数即可。

真正实施代码：

```c++
int largestSumAfterKNegations(vector<int>& nums, int k) {
        // 升序排列
        sort(nums.begin(), nums.end());

        // 首先处理负数
        int i;
        for (i = 0; i < nums.size(); ++i) {
            if (k == 0) break; // 次数用完退出

            if (nums[i] < 0) {
                // 消耗一次变化次数
                --k;
                nums[i] = -nums[i];
            } else if (nums[i] == 0){
                k = 0;
                break; // 当遇到非负数时退出循环
            } else {
                break;
            }
        }

        // 此时K表示所有的负数都被消耗
        if (k > 0) {
            if (k % 2 == 0) {
                // 此时无需再处理数组
                ;
            } else {
                // 重新排序选择最小的整数取反即可
                sort(nums.begin(), nums.end());
                nums[0] = -nums[0];
            }
        }


        int ans = 0;
        for (int j = 0; j < nums.size(); ++j)
                ans += nums[j];

        return ans;
    }
```

时间复杂度O(nlogn)，即主要是排序消耗的时间；空间复杂度O(1)



作者思路：

- 第一步：将数组按照绝对值大小从大到小排序，**注意要按照绝对值的大小**
- 第二步：从前向后遍历，遇到负数将其变为正数，同时K--
- 第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完
- 第四步：求和

这里优化了判断当负数处理完之后判断是否有0的存在，直接反复处理最小的元素即可。

### 贪心周总结

股票问题：把一段时间的利润拆分成这几天每一天的利润。即用一天价格减去前一天的价格做差。

这样贪心的思路就是：只收集正利润，即上涨的利润。全局最优：得到最大利润

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2020112917480858.png" alt="122.买卖股票的最佳时机II" style="zoom:50%;" />

跳跃游戏I：问题转换为覆盖范围，即每次跳跃取最大步数是这一步目前的最大覆盖范围。

局部最优：每次都取最大范围。

整体最优：整体最大覆盖范围是否能够到达终点。



跳跃游戏II：当前最大覆盖范围：一步内可以到达的地方。如果当前最大覆盖范围没有到达终点，那么就需要再走一步，扩大覆盖范围。新走的一步也要使得覆盖范围最大，即保证下一步的覆盖范围最大。即在当前覆盖范围内可走的下标 i + nums[i] 就是走到下一步 i 的覆盖范围。



K次取反之后最大化的数组和：局部最优：让绝对值最大的负数先变成正数。然后再让绝对值最小的正数变成负数。



### 加油站

题目：134

我的思路：如果各个站点的加油站 剩油量rest[i]相加之和大于等于零，说明总油量减去总消耗大于等于零那么一定可以跑完一圈。

但是不知道起点怎么求。

作者给了思路：

每个加油站的剩余量rest[i]为gas[i] - cost[i]。

i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，**因为这个区间选择任何一个位置作为起点，到i这里都会断油**，那么起始位置从i+1算起，再从0计算curSum。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230117165628.png" alt="img" style="zoom:50%;" />

那么为什么一旦[0，i] 区间和为负数，起始位置就可以是i+1呢，i+1后面就不会出现更大的负数？

如果出现更大的负数，就是更新i，那么起始位置又变成新的i+1了。

那有没有可能 [0，i] 区间 选某一个作为起点，累加到 i这里 curSum是不会小于零呢？ 如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230117170703.png" alt="img" style="zoom:50%;" />

如果 curSum<0 说明 区间和1 + 区间和2 < 0， 那么 假设从上图中的位置开始计数curSum不会小于0的话，就是 区间和2>0。

区间和1 + 区间和2 < 0 同时 区间和2>0，只能说明区间和1 < 0， 那么就会从假设的箭头初就开始从新选择其实位置了。

**那么局部最优：当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置**。

时间复杂度O(n)，空间复杂度O(1)

### 分发糖果

题目：135

我的思路：从前向后遍历，当左孩子小于右孩子时，右孩子糖果等于左孩子糖果+1；（那么如果左孩子大于右孩子呢？理论上应该是左孩子糖果等于右孩子+1，但是遍历顺序是从前向后，所以此时没办法确定右孩子的糖果数目）

接着从后向前遍历，此时就能够根据右孩子糖果数确定左孩子糖果数，此时如果左孩子大于右孩子，那么此时左孩子有两个选择，一个选择是右孩子+1，另一个选择是上一步中求得的这个孩子应该有的糖果数。应该选择较大的，这样既能保证大于左边又能保证大于右边。

时间复杂度O(n)，空间复杂度O(n)

采用了两次贪心的策略：

- 一次是从左到右遍历，只比较右边孩子评分比左边大的情况。
- 一次是从右到左遍历，只比较左边孩子评分比右边大的情况。

这样从局部最优推出了全局最优，即：相邻的孩子中，评分高的孩子获得更多的糖果。

### 柠檬水找零

题目：860

思路：

- 情况一：账单是5，直接收下。
- 情况二：账单是10，消耗一个5，增加一个10
- 情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5

账单是20的情况，为什么要优先消耗一个10和一个5呢？

**因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！**

所以局部最优：遇到账单20，优先消耗美元10，完成本次找零。全局最优：完成全部账单的找零。

### 根据身高重建队列

题目：406

思路：

遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。

**如果两个维度一起考虑一定会顾此失彼**。

对于本题相信大家困惑的点是先确定k还是先确定h呢，也就是究竟先按h排序呢，还是先按照k排序呢？

如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。

那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面,，后续根据k值选择插入位置，防止小的k值还不存在就插入大的k值下标），让高个子在前面。

**此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！**

那么只需要按照k为下标重新插入队列就可以了，为什么呢？

以图中{5,2} 为例：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201216201851982.png" alt="406.根据身高重建队列" style="zoom:50%;" />

按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。

所以在按照身高从大到小排序后：

**局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性**

**全局最优：最后都做完插入操作，整个队列满足题目队列属性**

例子：

排序完的people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]

插入的过程：

- 插入[7,0]：[[7,0]]
- 插入[7,1]：[[7,0],[7,1]]
- 插入[6,1]：[[7,0],[6,1],[7,1]]
- 插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]
- 插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]
- 插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]

时间复杂度O(nlogn + n^2)，后面的时间复杂度是指遍历一遍所有的元素，然后根据k选择插入位置

空间复杂度O(n)

### 贪心周总结

加油站：这道题首先想要能够走完一圈，每一站的加油量减去消耗量之和（就是总油量要大于总消耗量），走完一圈一定是正的。

其次是判断起点的问题，将每一站的差值从第0站开始进行累加，当累加为负数时，说明起始位置到这一站之间都不能作为起点，因为不管是哪一个作为起点，到这里都会却油。所以必须从后面一站开始。接着重新进行累加，继续更新。

贪心的思想体现在：累加的差值如果小于0，那么至少从下一个开始。



分发糖果：这个问题的关键在于：如果从左向右比，那么一定是根据前者才能更新后者，所以只能更新后者，更新后者的情况就是当后者评分大于前者时，此时后者应该比前者多1个。（为什么不能当前者评分大于后者时，更新前者为后者糖果数目+1呢？因为此时后者的糖果数并不是最终结果，如果在后续操作中后者糖果发生改变，那么这一步对于前者的修改就是不正确的。）

在从左向右比之后，此时所有后者大于前者的人都已经更新。

接着需要从右向左进行比较，此时可以根据后者更新前者，具体更新逻辑为，如果前者的评分大于后者，那么前者的糖果数应该取上一步更新的糖果数和后者+1中较大值。

贪心的思想体现在：从左向右：只要后者大于前者，那么后者就为前者+1；从右向左，如果前者大于后者，那么前者就必须比后者多。



买柠檬水找零：贪心的思想体现在，尽可能先使用10源进行找零，因为10元只能对于20元进行找零，而5元既可以对10元找零，也可以对20元找零。



根据身高重建队列：存在两个维度，应该先使得一个维度有序，然后再考虑另一个维度。

这里先按照身高从大到小排序（身高相同的话则k小的站前面），这样能够保证高个子在前面。

然后根据第二个维度k值，将其放入第k个下标对应的位置。

（为什么k小的站前面？主要是因为进行重新插入时，从前向后处理。如果先处理K大的，那么有可能对于一个队列来说超出目前队列的长度）

贪心体现在：k值表示前面正好有k个大于或者等于这个身高的人。那么已经按照身高排序，然后按照身高从高向低处理，插入到第k个位置，至少能够保证前面有k个人大于或等于该身高。即使后续前面再插入新元素，新元素一定是比该身高低。（因为后处理的元素比先处理的元素身高低）





### 用最少数量的箭引爆气球

题目：452

我的思路（存在缺陷）：对于一个气球来说，想要引爆的射箭位置就是[L, H]，那么如果想要一次引爆多个气球，就需要从他们的交集位置射出，所以我的思路就是遍历所有气球位置，使得尽量从交集位置射出。

但是问题是：气球顺序会影响两个位置范围结合求子集的顺序，这样会使得

```c++
[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]
```

比如上面的气球顺序，当[7,12],[3,8]相遇，那么子集范围就确定为[7,8]，不能达到最小箭的数目
<img src="D:\RegularFile\LeetCode-c++\pic\452.jpg" alt="452" style="zoom: 33%;" />

这里明显是6可以解决除了最后一个所有的气球，但是如果采用上面的思路，就需要3个箭头。

但是如果排序之后再使用上面算法，可以通过，但是时间复杂度是O(max(nlogn, n^2))



作者的思路：

局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少。

如果把气球排序之后，从前到后遍历气球，被射过的气球仅仅跳过就行了，没有必要让气球数组remove气球，只要记录一下箭的数量就可以了。**为了让气球尽可能的重叠，需要对数组进行排序**。

**如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭**。

以题目示例： [[10,16],[2,8],[1,6],[7,12]]为例，如图：（方便起见，已经排序）

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123101929791.png" alt="452.用最少数量的箭引爆气球" style="zoom:50%;" />

时间复杂度O(nlogn)，快速排序；空间复杂度O(1)

### 无重叠区间

题目：435

思路：贪心：发现重叠的区间就移除较大的区间

与上一题一样，先进行排序，然后依次比较相邻两个区间：已知后者的左端点一定大于等于前者的左端点，如果后者的左端点大于等于前者的右端点，说明后者整体区间在前者后面，无重叠；否则说明存在交集，应该将右边界更大的删除，以更小的右边界作为切割点。

时间复杂度O(nlogn)，快速排序；空间复杂度O(1)



另一种思路：按照右边界排序，从左至右计算不重叠的区间个数，总区间个数减去不重叠的区间个数就是需要移除的区间个数。

这里记录非交叉区间的个数还是有技巧的，如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230201164134.png" alt="img" style="zoom:50%;" />

区间，1，2，3，4，5，6都按照右边界排好序。

当确定区间 1 和 区间2 重叠后，如何确定是否与 区间3 也重贴呢？

就是取 区间1 和 区间2 右边界的最小值，因为这个最小值之前的部分一定是 区间1 和区间2 的重合部分，如果这个最小值也触达到区间3，那么说明 区间 1，2，3都是重合的。

接下来就是找大于区间1结束位置的区间，是从区间4开始。**那有同学问了为什么不从区间5开始？别忘了已经是按照右边界排序的了**。

区间4结束之后，再找到区间6，所以一共记录非交叉区间的个数是三个。

总共区间个数为6，减去非交叉区间的个数3。移除区间的最小数量就是3。

### 划分字母区间

题目：763

我的思路：遍历所有元素，对于每一个元素求其最后一次出现的下标作为max_end，一个分区的长度以内部所有元素中最大的max_end作为分区右边界。

```c++
int FindMaxend(const string &s, char c) {
    // 返回c在s中最后一次出现的位置下标
    for (int i = s.size() - 1; i >= 0; --i) {
        if (s[i] == c) return i;
    }

    // c一定在s中，否则出错
    exit(-1);
}

vector<int> partitionLabels(string s) {
    if (s.size() == 0) return vector<int>(0);
    int max_end = 0; // 表示当前

    // 假设s不为空，初始化第一个字符的max_end
    max_end = FindMaxend(s, s[0]);
    int count = 1; // 初始化第一个分区的长度
    vector<int> ans;
    // 从第二个元素开始
    for (int i = 1; i < s.size(); ++i) {
        if (i <= max_end) {
            // 说明还在上一个分区内
            count++; // 分区长度加1
        } else {
            // 说明这是一个新的分区
            // 应该保留上一次的长度
            ans.push_back(count);

            count = 1; // 从这个新的元素开始计数
        }

        // 更新max_end
        max_end = max(max_end, FindMaxend(s, s[i]));
    }
    // 每一段的更新逻辑是遇到下一段才会更新
    // 最后一段不会遇到下一段，所以没有更新
    ans.push_back(count);

    return ans;
}
```

时间复杂度O(n^2)，空间复杂度O(n)。这里的n是进行函数调用栈的空间消耗



作者的思路：与上面基本一致，但是作者首先使用一个hash表计算出所有元素的最后一次的下标，这个时间复杂度为O(n)；

然后一个细节是当 i == max_end时就可以记录当前分区长度了，这样就不需要循环结束之再统计最后一个分区的长度

```c++
vector<int> partitionLabels(string s) {
    // 使用一个hash表记录每一个字母最后出现的位置
    // 题目中说明左右字母均是小写
    int hash_table[26] = {0};
    for (int i = 0; i < s.size(); ++i) 
        hash_table[s[i] - 'a'] = i;

    int count = 0;  // 记录每一个分区的长度
    int max_end = 0; // 每一个分区的最大右边界
    vector<int> ans;
    for (int i = 0; i < s.size(); ++i) {
        // 更新max_end右边界
        max_end = max(max_end, hash_table[s[i] - 'a']);
        count++;

        if (i == max_end) {
            // 当前字母就是同一分区最后一个元素
            // 记录该分区长度
            ans.push_back(count);

            // 长度归零
            count = 0;
        }
    }

    return ans;
}
```

时间复杂度O(n)；空间复杂度O(1)，固定hash表的长度

### 合并区间

题目：56

我的思路：这道题与“用最少的数量的箭引爆气球”和”无重叠区间“类似，都是先排序使得左右边界中的一个边界有序，然后根据另一个边界判断是否出现重叠。

这道题出现重叠时需要将以更小的左边界和更大的右边界合并两个区间。

以左边界排序，然后根据右边界的情况判断是否重叠：已知排序之后前者的左边界 小于等于 后者的左边界，如果后者的左边界大于（注意这里等于也是重叠）前者的右边界，说明后者整体在前者的后面，无重叠现象，此时不需要处理；否则，就应该以前者的左边界作为新区间的左边界，以max(前者的右边界, 后者的右边界)作为新区间的右边界。



时间复杂度O(nlogn)，快速排序的时间；空间复杂度O(n)，需要一个ans数组



作者的思路：与上面基本一致，不一样的是一点细节：作者直接把第一个区间加入答案中，当发现重叠时，就直接在答案的最后一个区间上进行修改；无重叠的话就直接把当前区间加入答案数组。

而我的思路是比较连续两个区间，如果出现重叠区间，就把合并后的区间赋给后者，然后继续参与比较；只有当遇到不重叠时，才把前者加入答案（也就是之前几个区间合并后的结果）。这样做的坏处就是最后一个区间需要在循环结束之后再添加。

### 贪心周总结

用最少的箭引爆气球、无重叠区间、合并区间：这三道题都类似，第一步就是先使得一个维度有序，这里采用的都是使得左边界从小到大排列；然后从前到后根据比较相邻两个区间的右边界判断是否出现重叠；最后根据重叠与否做出不同的行为。



划分字母区间：尽量保证一个分区的右边界为区间内元素最后一次出现的位置。

这道题给我的收获是：如果在处理一个循环时需要根据原始数据进行某些操作，考虑是否可以提前进行这些操作。

也就是在n循环中做时间复杂度为n的操作，可以优化为先做时间复杂度为n的操作得到需要的数据，然后再进行n循环。

### 单调递增的数字

题目：738

我的思路：题目的要求是尽可能接近目标n，并且小于等于目标n。尽可能大的话从高位开始，每一位尽可能与n的每一位保持一致。
另外还需要保证答案满足每一位递增，所以需要维持两个值：cur表示n当前位置的数字，min_val表示答案这个位置数字的最小值。

只有当cur>= min_val时，才可以直接让最终答案的这一位为cur；

否则的话，需要让答案前一位减去1，剩余所有位均为9。



减去1之后有可能会使得小于更前面的数字，所以在根据每一位的数字恢复答案时，当前位置数字如果小于前面的，应该使得当前数字为9，另前一位数字减去1.

时间复杂度O(n)，包括使用栈保存每一位数字、遍历栈中每一位数字求存储结果每一位的栈、遍历结果栈得到最终答案；

空间复杂度O(n)



作者思路：不同的是从后向前遍历，这样一次循环就可以直接处理。另外，将数字转换成字符串更容易处理。

### 监控二叉树

题目：968

思路：摄像头可以覆盖上中下三层，如果把摄像头放在叶子节点上，就浪费的一层的覆盖。

所以把摄像头放在叶子节点的父节点位置，才能充分利用摄像头的覆盖面积。

为什么不从头结点开始看起呢，为啥要从叶子节点看呢？

因为头结点放不放摄像头也就省下一个摄像头， 叶子节点放不放摄像头省下了的摄像头数量是指数阶别的。

**所以我们要从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！**

所以确定采用后续遍历。

接着是计算摄像头个数：递归的处理就是返回结点的状态。

分别有三个数字来表示结点状态：

- 0：该节点无覆盖
- 1：本节点有摄像头
- 2：本节点有覆盖

**因为在遍历树的过程中，就会遇到空节点，那么问题来了，空节点究竟是哪一种状态呢？ 空节点表示无覆盖？ 表示有摄像头？还是有覆盖呢？**

回归本质，为了让摄像头数量最少，我们要尽量让叶子节点的父节点安装摄像头，这样才能摄像头的数量最少。

那么空节点不能是无覆盖的状态，这样叶子节点就要放摄像头了，空节点也不能是有摄像头的状态，这样叶子节点的父节点就没有必要放摄像头了，而是可以把摄像头放在叶子节点的爷爷节点上。

**所以空节点的状态只能是有覆盖，这样就可以在叶子节点的父节点放摄像头了**

主要有如下四类情况：

- 情况1：左右节点都有覆盖

左孩子有覆盖，右孩子有覆盖，那么此时中间节点应该就是无覆盖的状态了。

- 情况2：左右节点至少有一个无覆盖的情况

如果是以下情况，则中间节点（父节点）应该放摄像头：

- left == 0 && right == 0 左右节点无覆盖
- left == 1 && right == 0 左节点有摄像头，右节点无覆盖
- left == 0 && right == 1 左节点有无覆盖，右节点摄像头
- left == 0 && right == 2 左节点无覆盖，右节点覆盖
- left == 2 && right == 0 左节点覆盖，右节点无覆盖

这个不难理解，毕竟有一个孩子没有覆盖，父节点就应该放摄像头。

此时摄像头的数量要加一，并且return 1，代表中间节点放摄像头。

- 情况3：左右节点至少有一个有摄像头

如果是以下情况，其实就是 左右孩子节点有一个有摄像头了，那么其父节点就应该是2（覆盖的状态）

- left == 1 && right == 2 左节点有摄像头，右节点有覆盖
- left == 2 && right == 1 左节点有覆盖，右节点有摄像头
- left == 1 && right == 1 左右节点都有摄像头

- 情况4：头结点没有覆盖

以上都处理完了，递归结束之后，可能头结点 还有一个无覆盖的情况。

时间复杂度O(n)

空间复杂度O(n)，递归栈消耗时间





## 动态规划

动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。

所以动态规划中每一个状态一定是由上一个状态推导出来的。贪心没有状态推导，而是从局部直接选最优的。

解题步骤：

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

如何debug：
**找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的**

### 斐波那契数

题目：509

思路1：
1、确定dp数组以及下标的含义：
dp[i]的定义是：第i个数的斐波那契数值是dp[i]
2、确定递推公式
**状态转移方程 dp[i] = dp[i - 1] + dp[i - 2]**
3、dp数组如何初始化

```
dp[0] = 0;
dp[1] = 1;
```

4、确定遍历顺序
从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的。
5、举例推导dp数组按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：

0 1 1 2 3 5 8 13 21 34 55

时间复杂度O(n)，空间复杂度O(n)

实际上只需要维护两个数值就可以，不需要整个状态数组。所以空间复杂度为O(1)

思路2：采用递归的方式，从上到下计算

```c++
class Solution {
public:
    int fib(int N) {
        if (N < 2) return N;
        return fib(N - 1) + fib(N - 2);
    }
};
```

时间复杂度O(2^n)，空间复杂度O(n)，包括了实现递归所占用的系统栈的空间

#### 递归的时间复杂度

面试题：求x的n次方

最直观：一个for循环

```c++
int function1(int x, int n) {
    int result = 1;  // 注意 任何数的0次方等于1
    for (int i = 0; i < n; i++) {
        result = result * x;
    }
    return result;
}
```

时间复杂度是O(n)

一种递归：

```c++
int function2(int x, int n) {
    if (n == 0) {
        return 1; // return 1 同样是因为0次方是等于1的
    }
    return function2(x, n - 1) * x;
}
```

递归算法的时间复杂度本质上是要看: **递归的次数 \* 每次递归中的操作次数**。

每次n-1，递归了n次时间复杂度是O(n)，每次进行了一个乘法操作，乘法操作的时间复杂度一个常数项O(1)，所以这份代码的时间复杂度是 n × 1 = O(n)。

另一种递归：

```c++
int function3(int x, int n) {
    if (n == 0) return 1;
    if (n == 1) return x;

    if (n % 2 == 1) {
        return function3(x, n / 2) * function3(x, n / 2)*x;
    }
    return function3(x, n / 2) * function3(x, n / 2);
}
```

我们来分析一下，首先看递归了多少次呢，可以把递归抽象出一棵满二叉树。刚刚同学写的这个算法，可以用一棵满二叉树来表示（为了方便表示，选择n为偶数16），如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201209193909426.png" alt="递归算法的时间复杂度" style="zoom: 33%;" />

当前这棵二叉树就是求x的n次方，n为16的情况，n为16的时候，进行了多少次乘法运算呢？

这棵树上每一个节点就代表着一次递归并进行了一次相乘操作，所以进行了多少次递归的话，就是看这棵树上有多少个节点。

这么如果是求x的n次方，这个递归树有多少个节点呢，如下图所示：(m为深度，从0开始)

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200728195531892.png" alt="递归求时间复杂度" style="zoom:67%;" />

**时间复杂度忽略掉常数项`-1`之后，这个递归算法的时间复杂度依然是O(n)**

最后一种递归：

```c++
int function4(int x, int n) {
    if (n == 0) return 1;
    if (n == 1) return x;
    int t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来
    if (n % 2 == 1) {
        return t * t * x;
    }
    return t * t;
}
```

再来看一下现在这份代码时间复杂度是多少呢？

依然还是看他递归了多少次，可以看到这里仅仅有一个递归调用，且每次都是n/2 ，所以这里我们一共调用了log以2为底n的对数次。

**每次递归了做都是一次乘法操作，这也是一个常数项的操作，那么这个递归算法的时间复杂度才是真正的O(logn)**。

### 爬楼梯

题目：70

思路1：每次可以选择爬1或者2个台阶

1。确定dp数组以及下标含义
dp[i]表示到达第i个阶梯的方法，

2.确定递推公式
dp[i] = dp[i - 1] + dp[i - 2]，表示登上第i-1层阶梯的方法之和再走一个阶梯，以及先登上第i- 2层阶梯的方法之和再走两个阶梯

3.初始化

由题意可知：dp[1] = 1；dp[2] = 2

4.遍历方式：后者必须依赖于前面两个元素，所以必须从前向后遍历

5.举例子

dp[1] = 1
dp[2] = 2
dp[3] = 3 = dp[1] + dp[2]
dp[4]: 1 1 1 1; 1 1 2; 1 2  1;  2 1 1; 2 2 一共5种，等于dp[3] + dp[2]

思路2：采用分治或者说是递归的方式，同样由递推公式可得dp[i] = dp[i - 1] + dp[i - 2]，那么可以将一个大问题分解成小问题，递归解决小问题，小问题到达边界条件之后合并解决大问题。

时间复杂度O(2\^n)：每计算一个F(n)都需要把这个结点分成两个结点，可以看作是一颗满二叉树，这个满二叉树的高度是n，于是可以得知一共有2^n级别个结点，这些结点都是一次递归操作，每次递归中的操作是O(1)级别的。

会超时。

### 使用最小花费爬楼梯

题目：746

思路：采用动态规划方式

1.dp数组即下标含义：
dp[i]表示到达第i层阶梯的最小花费

2.dp数组递推公式：
到达dp[i]有两种方式：（1）先到到达i-2，然后使用第i-2层的花费之后走两层到达第i层；（2）先到达第i-1层，然后使用第i-1层的花费之后走一层达到第i层。因此要使得dp[i]最小，就需要选择这两种方式中较小的一种。

另外需要注意的是，达到第i层不是终点，终点应该是走过所有楼梯，所以是第i+1层。

3.dp数组初始化：
可以从第0层或者第1层开始，所以到达这两层的最小花费是直接到达，即dp[0] = dp[1] = 0

4.遍历顺序：
因为i依赖于i-2和i-1，所以从前向后遍历

5.举例子尝试：
cost = [10,15,20]

(1)dp[0] = dp [1] = 0;

(2)dp[2]：选择有两种：第一种选择是：dp[0] + cost[0] = 10；第二种选择是：d[1] + cost[1] = 15；

(3)dp[3]：选择有两种：第一种选择是：dp[1] + csot[1] = 15；第二种选择是：dp[2] + cost[2] = 35;

所以最小花费是从下标1开始，走两层到达顶部（也就是第3层）

时间复杂度O(n)，空间复杂度O(1)，这里只需要保留前两次数据即可。

### 不同路径

题目：62

思路1：动态规划。怎么想出来的：尝试使用回溯的方法，到达一个点（i,j），剩余可以走的路径只有向右或者向下。发现子问题会存在重复，于是考虑到动态规划。想要到达（m,n），必须先到达（m-1,n）或者（m,n-1），因此可以将一个大问题划分成子问题。

1.dp数组以及下标含义：
这里dp数组是二维的，dp[i]\[j]表示到达（i,j）的路径数目

2.dp数组递推公式：
想要到达（i，j），要么（1）先到达（i-1，j）再向下移动一格；要么（2）先到达（i，j-1）再向右移动一格。于是可以得到
dp[i]\[j] = dp[i-1]\[j] + dp[i]\[j-1]

3.dp数组初始化：
第一行和第一列的元素都为1（dp[0]\[0]不应该存在，因为如果起点就是终点的话路径应该为0）

4.遍历顺序：
每一个元素依赖于上面的元素和左边的元素，所以按行从左向右遍历

5.举例子测试：假如m=3，n=2

首先初始化：第一行和第一列都是1，即dp(0,1) = 1, dp(1, 0) = 1, dp(2, 0) = 1

接着进行遍历（遍历从第二行的第二列开始）：dp(1, 1) = dp(0, 1) + dp(1, 0) = 2

接着遍历第三行：dp(2, 1) = dp(1, 1) + dp(2, 0) = 2 + 1 = 3

时间复杂度O(m*n)，因为是遍历二维数组；空间复杂度O(m\*n)，整个dp数组所占用的空间。是否可以优化？



思路2：采用回溯的方式，每层回溯可以遍历的集合就是左和下。

使用一个全局遍历记录总的路径个数

递归的参数：终点(m,n)，当前位置(row,col)；没有返回值
递归的终止条件：当行或者列超出范围时，这时已经不是合理的范围；另外就是当前位置到达终点时也需要记录一个路径，并且返回
递归的单层逻辑：只能行增加或者列增加继续递归。

时间复杂度O(2^(m+n-1))，有递归树可以看出，每一个结点有两条孩子，是一颗满二叉树，这棵树的深度其实就是m+n-1（深度按从1开始计算）。空间复杂度就是时间复杂度，每一层都是一层递归栈。



思路3：组合数学：从（1，1）到达（m，n），不管是什么走法（每一步只能向左或者向右），一定是向下走m-1步，向右走n-1步，一共是m+n-2步。

由于每次要么下要么右，并且必须有m-1个是向下，所以相当于在m+n-2次中有m-1个是向下操作（剩下的自然只能是向右）。

所以是组合数C

计算组合数的算法：



分子分母都是m个数相乘。不能先算出分子再算出分母，放置int类型溢出。所以采用边算边除以分母的方式：

```c++
// 使用组合数
    int uniquePaths(int m, int n) {
        long long numerator = 1; // 分子
        int denominator = m - 1; // 分母
        int count = m - 1;
        int t = m + n - 2; // 起点
        
        while (count--) {
            numerator *= (t--);
            // 当可以整除分母时
            // 由于是组合数，所以分子一定可以把所有的分母都给整除掉
            while (denominator != 0 && numerator % denominator == 0) {
                numerator /= denominator;
                denominator--;
            }

        }

        return numerator;
    }
```

时间复杂度O(m)

### 不同路径II

题目：63

思路1：采用深度优先搜索，每次可以选择搜索的集合就是右和下，如果是障碍物就不能搜索。

时间复杂度是O(2^(m +n -1))，感觉会超时

思路2：与上一题一样使用动态规划
1.dp数组以及下标含义：
dp[i]\[j]表示到达（i，j）可能的路径个数

2.dp数组递推公式：
遇上一题一样，想要到达（i，j），必须先到达（i-1，j）或者（i，j-1），所以
dp[i]\[j] = dp[i-1]\[j] + dp[i]\[j-1]
但是这里需要判断是否为障碍物。如果（i，j）是障碍物，那么这里的dp没有意义，就使用0表示；如果（i-1，j）或者（i，j-1）是障碍物，那么就不添加是障碍物的dp。如果都是障碍物，那么dp[i]\[j]就是0.

3.dp数组初始化：
（0，0）无意义，题目也说明不会只存在一个格子；
首先初始化第一行：（0，1）为1，然后依次向后初始化：如果第一行没有出现障碍物，那么全是1；如果出现障碍物，那么障碍物之后的都是0.
接着初始化第一列：（1，0）为1，然后依次向下初始化：如果第一列没有出现障碍物，那么全是1；如果出现障碍物，那么障碍物以下的都是0.

4.遍历顺序：
因此每一个元素都依赖于上面和左面，所以按行从左向右开始遍历

5.举例子：
示例1正确。

### 整数拆分

题目：343

思路1：采用动态规划

1.dp数组以及下标定义：
dp[i]表示i被拆分之后最大乘积。

2.dp数组递推公式：
j从1到i-1开始遍历，得到dp[i]的方式有两种：（1）j * (i - j)；（2）j * dp[i - j]（相当于拆分 i - j）；通过比较这些值中最大的来确定dp[i]
因此递推公式为：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))
这里有dp[i]的原因是不断更新dp[i]的值，所以也参与到比较中

3.初始化：
i从2开始，每次j从1遍历到i / 2就可以，~~因为当 j 超过 i / 2之后，就开始重复~~

因为拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的。

例如 6 拆成 3 * 3， 10 拆成 3 * 3 * 4。 100的话 也是拆成m个近似数组的子数 相乘才是最大的。

只不过我们不知道m究竟是多少而已，但可以明确的是m一定大于等于2，既然m大于等于2，也就是 最差也应该是拆成两个相同的 可能是最大值。

那么 j 遍历，只需要遍历到 n/2 就可以，后面就没有必要遍历了，一定不是最大值。

至于 “拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的” 这个我就不去做数学证明了，感兴趣的同学，可以自己证明。

4.遍历顺序：
后者依赖于前者，所以从前向后遍历



时间复杂度O(n^2)，因为是双层循环；空间复杂度O(n)

### 不同的二叉搜索树

题目：96

思路1：动态规划

1.dp数组以及下标的含义：
dp[i]表示由i个结点组成互不相同的二叉搜索树的个数

2.dp数组递推公式：
j 从1遍历到 i ，表示以 j 值作为二叉搜索树的根节点。由于二叉搜索树根节点的左子树所有元素必须比根节点小，所以小于j的元素在左子树，大于j的元素在右子树。那么以结点 j 为根节点的二叉搜索树的个数就等于左子树种类数 与 右子树种类数的乘积。即dp[j] = dp[j - 1] * dp[i - j]。如果左子树节点数或者右子树节点数为0，那么应该为1，所以决定了dp[0]为1

所以只需要 j 从1遍历到n分别作为根节点求出dp[j] ，再把所有的dp[j]累加在一起就可以得到dp[i]

3.数组初始化：
上面可以得到，当j-1 == 0 或者i - j == 0即左子树或者右子树节点数为0时，为了方便与另一颗子树做乘法，所以dp[0] 应该为1；
另外dp[1] 为1.

4.遍历顺序：
dp数组第i个元素依赖于：从j-1到i-j（j取值为[1,i]），即依赖于dp[0]到dp[i - 1]，所以必须是从前向后遍历

5.举例子
n为3的例子正确

时间复杂度O(n^2）因为是双层循环；空间复杂度O(n)，因为第i个依赖于前i-1个，所以空间没办法优化。

### 动态规划总结

动态规划问题两个特征：（1）子问题会重叠；（2）原问题的最优解一定包含了子问题的最优解，这样才能由子问题状态一步步转移到原问题。

**斐波那契数：**（1）子问题会发生重叠：比如计算F(n)需要计算两个子问题F(n-1)和F(n-2)；这里面会发生问题重叠，因为计算F(n-1)同样需要计算F(n-2)和F(n-3)，于是F(n-2)发生重叠

（2）子问题的最优解就是方程得到的确定值，同时也是上一层问题的确定值。

状态转移方程就是dp[i] = dp[i - 1] + dp[i - 2]



**爬楼梯：**（1）子问题重叠：爬到n层楼梯的方法数目为F(n)，爬到n层楼梯需要先爬到n-1层再走一步，或者爬到n-2层再走2步；这里会发生重叠，因为爬到n-1层需要先爬到n-2层再走一步，或者先爬到n-3层再走2步。这里F(n-2)就会计算两次。

（2）分解成两个子问题的方法个数因为最后一步的不同而不同，求和即为原问题的解。

状态转移方程就是：dp[i] = dp[i - 1] + dp[i - 2]



**使用最小花费爬楼梯：**（1）子问题重叠：也是达到第n层需要先到达第n-1层或者n-2层，想要到达n-1层需要先到达n-2层或者n-3层。

（2）子问题的最优解包含在原问题的最优解：到达n-1层的最小花费，加上第n-1层花费；到达第n-2层的最小花费，加上第n-2层的花费。从这两者中选择一个小的作为第n层最小花费。

状态转移方程是：dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])



**不同路径：**（1）子问题重叠：想要到达[i, j] ，必须先到达[i - 1, j] 或者[i, j - 1]。而想要到达[i - 1, j]，需要先到达[i - 2, j] 或者[i - 1, j - 1]；同理，想要到达[i, j - 1] 需要到达[i - 1, j - 1] 或者[i, j - 2]，此时[i- 1, j - 1]重叠。

（2）子问题的最优解包含在原问题的最优解中：子问题到达[i - 1, j] 之后再向下走一格；子问题到达[i. j - 1]之后再想右走一格子。这两种到达[i, j] 的方式因为最后一步不同而不同，所以相加得到原问题的解。

状态转移方程：dp[i]\[j] = dp\[i - 1][j] + dp\[i][j - 1]

需要注意以下边界的初始化。



**不同路径II：**与上一题一样。不同的地方在于存在障碍物，如果是障碍物，那么dp[i]\[j]就为0，表示没有方法到达障碍物。

状态转移方程：dp[i]\[j] = dp\[i - 1][j] + dp\[i][j - 1]。如果后面的两个中有一个是障碍物，障碍物为0，不影响计算。



**整数拆分：**（1）子问题重叠：假设原问题的拆分之后的最大乘积是dp[i]，那么子问题为：(j 从1 ~ i-1)要么拆分成两个：j 和i - j；要么拆分成多个：j和dp[i - j] （即对i-j进行拆分的最大乘积，最少为2项）。在求dp[i - j ]时，需要求dp[i - 1]、dp[i - 2]等等，就会发生重叠。

（2）子问题的最优解推导出原问题的最优解：dp[i] 需要从：（1）j * (i - j)；（2）j * dp[i - j]（相当于拆分 i - j）；通过比较这些值中最大的来确定dp[i]

状态转移方程：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))



**不同的二叉搜索树：**

j 从1遍历到 i ，表示以 j 值作为二叉搜索树的**根节点**。由于二叉搜索树根节点的左子树所有元素必须比根节点小，所以小于j的元素在左子树，大于j的元素在右子树。那么以结点 j 为根节点的二叉搜索树的个数就等于左子树种类数 与 右子树种类数的乘积。即dp[j] = dp[j - 1] * dp[i - j]。如果左子树节点数或者右子树节点数为0，那么应该为1，所以决定了dp[0]为1

所以只需要 j 从1遍历到n分别作为根节点求出dp[j] ，再把所有的dp[j]累加在一起就可以得到dp[i]

（1）子问题重叠：比如求dp[2]，就必须求dp[0]、dp[1]；dp[1]、dp[0]；求dp[3]就会需要求dp[0]~dp[2]，所以存在子问题重叠

（2）最优解：原问题的最优解是通过子问题的最优解推导出来的。



### 01背包理论基础

**问题描述：**有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

1.dp数组以及下标的含义：
对于背包问题，有一种写法， 是使用二维数组，即**dp\[i]\[j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少**。

2.确定递推公式：

```
再回顾一下dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。

那么可以有两个方向推出来dp[i][j]，

1.不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)
2.放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值

所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
```

3.初始化：
首先从dp\[i]\[j]的定义出发，如果背包容量j为0的话，即dp[i]\[0]，无论是选取哪些物品，背包价值总和一定为0。
即第一列为0

状态转移方程 dp[i][j] = max(dp[i - 1]\[j], dp[i - 1]\[j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。那么很明显当 j < weight[0]的时候，dp[0]\[j] 应该是 0，因为背包容量比编号0的物品重量还小。当j >= weight[0]时，dp[0]\[j] 应该是value[0]，因为背包容量放足够放编号0物品。

4.遍历顺序：
更新时依赖于左上方的元素，因此可以按照行（即按照背包重量），也可以按照列（按照物品）



**优化数组空间：**在使用二维数组的时候，递推公式：dp[i]\[j] = max(dp[i - 1]\[j], dp[i - 1]\[j - weight[i]] + value[i]);

**其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i]\[j] = max(dp[i]\[j], dp[i]\[j - weight[i]] + value[i]);**

**与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了**，只用dp[j]（一维数组，也可以理解是一个滚动数组）。

这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。

1.dp数组以及定义：
在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。

2.递推公式：

dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。

dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）

此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1]\[j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，

所以递归公式为：

```text
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```

3.数组初始化：
当j为0时，也就是数组第一个元素，应该为0.（因为容量为0的背包什么也不能装）
下标不为0应该如何初始化？dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。**这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了**。

4.遍历顺序：代码如下：

```text
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

**这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！**

二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。

为什么呢？

**倒序遍历是为了保证物品i只被放入一次！**。但如果一旦正序遍历了，那么物品0就会被重复加入多次！

举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15

如果正序遍历

dp[1] = dp[1 - weight[0]] + value[0] = 15

dp[2] = dp[2 - weight[0]] + value[0] = 30

此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。

为什么倒序遍历，就可以保证物品只放入一次呢？

倒序就是先算dp[2]

dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）

dp[1] = dp[1 - weight[0]] + value[0] = 15

所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。

**那么问题又来了，为什么二维dp数组历的时候不用倒序呢？**

因为对于二维dp，dp[i]\[j]都是通过上一层即dp[i - 1]\[j]计算而来，本层的dp[i]\[j]并不会被覆盖！

（如何这里读不懂，大家就要动手试一试了，空想还是不靠谱的，实践出真知！）

**再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？**

不可以！

因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。

倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。

![image-20230911195544569](D:\RegularFile\LeetCode-c++\pic\01背包.jpg)

（这里如果读不懂，就再回想一下dp[j]的定义，或者就把两个for循环顺序颠倒一下试试！）

**所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！**，这一点大家一定要注意。

### 分割等和子集

题目：416

思路：使得两个子集元素和相等，也就是使得其中一个子集的元素和为 sum/2

所以可以看成是背包的体积是 sum/2，并且如果背包正好装满，则说明找到了元素和为sum/2的子集

1.确定dp数组含义：
dp[j]表示容量为j的背包最大的权重

2.dp数组递推公式：
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);这里重量和价值都是元素的数值

3.初始化：
dp[0]为0，其它各元素也为0

4.遍历顺序：
外层循环是物品，内层循环从里向外遍历背包

5.测试

对于nums = [1,5,11,5]是可以的。



时间复杂度O(n^2)；空间复杂度O(n)

### 最后一块石头的重量II

题目：1049

作者的思路：如何转换成一个01背包问题：本题其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，**这样就化解成01背包问题了**。背包的重量就是石头总重量的一半。

dp数组的定义与上一题一样。

### 目标和

题目：494

我的思路：假设所有元素之和为sum；假设表达式选中一些元素为正，和为p，那么另一些为负的元素的和为-(sum - p)。

想让这个表达式为target，可以得到p = (target+sum) / 2，也就是背包的体积。问题转换为装满体积为p的背包，有几种方法。

向下取整有没有影响？如果是奇数的话不可能有解；另外如果target的绝对值已经大于sum，说明所有元素同符号都不可能达到sum，也无解。

这道题不一样，之前都是求能够装进背包的最大重量，这道题求的是装满体积为p的背包有几种方法。

1.dp数组以及定义：
dp[j]标识从所有元素中装满重量为j的背包的方法个数。

2.递推公式：
每一个元素的重量为nums[i]，假设背包重量为j，那么nums[i] + j凑成一个新的重量，此时dp[nums[i] + j] 就可以有 dp[j]种不同的方式。

反过来思考，就是dp[j] = dp[j - nums[i]]的累加，也就是所有的dp[j- nums[i]]累加起来。

3.初始化：从递推公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递推结果将都是0。

这里有录友可能认为从dp数组定义来说 dp[0] 应该是0，也有录友认为dp[0]应该是1。

其实不要硬去解释它的含义，咱就把 dp[0]的情况带入本题看看应该等于多少。

如果数组[0] ，target = 0，那么 bagSize = (target + sum) / 2 = 0。 dp[0]也应该是1， 也就是说给数组里的元素 0 前面无论放加法还是减法，都是 1 种方法。

所以本题我们应该初始化 dp[0] 为 1。

可能有同学想了，那 如果是 数组[0,0,0,0,0] target = 0 呢。

其实 此时最终的dp[0] = 32，也就是这五个零 子集的所有组合情况，但此dp[0]非彼dp[0]，dp[0]能算出32，其基础是因为dp[0] = 1 累加起来的。

dp[j]其他下标对应的数值也应该初始化为0，从递推公式也可以看出，dp[j]要保证是0的初始值，才能正确的由dp[j - nums[i]]推导出来。

4.确定遍历顺序：
同样是外循环遍历物品，内循环倒序遍历重量。

5.测试：



时间复杂度O(n^2)，空间复杂度O(大整数)

本题还是有点难度，大家也可以记住，在**求装满背包有几种方法**的情况下，递推公式一般为：

```cpp
dp[j] += dp[j - weight[i]];
```

后面我们在讲解完全背包的时候，还会用到这个递推公式！

### 一和零

题目：474

思路：这里每个物品相当于是一个二进制字符串，物品的“重量”有两个维度，一个是0的个数，一个是1的个数。每个物品的价值都是1。
背包的容量有两个维度，一个是0个总数，一个是1的总数。

放入物品使得价值最高，也就是放进去的物品最多。

1.定义dp数组以及下标含义
dp[i]\[j]表示0的容量为i，1的容量为j的背包最高的价值，也就是最大的二进制字符串个数

2.递推公式：

```
dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
```

3.初始化：
全部为0

4.遍历顺序：
逆序遍历两个维度的重量



时间复杂度O(kmn)，空间复杂度O(mn)

### 完全背包理论

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。

01背包和完全背包唯一不同就是体现在遍历顺序上。

01背包的核心代码

```cpp
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次（这是因为外层循环是物品，内层循环是背包重量，如果是二维数组，那么每一层只会累计使用一次物品 i ）。

而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：

```cpp
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

![image-20230915211852582](D:\RegularFile\LeetCode-c++\pic\完全背包.jpg)



另外一个很重要的问题：**为什么遍历物品在外层循环，遍历背包容量在内层循环？**
对于01背包问题一定是物品在外循环，重量在内循环。这是因为重量必须是逆序遍历，如果逆序遍历的重量在外循环，那么内循环是物品，递推公式是：

```
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```

对于重量 j ，相当于内层循环遍历所有的物品，找到装入一个物品能够使得价值最高。

**在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的。**因为重量不需要逆序，只要保证dp

[j]能够根据之前的dp计算出来即可。

### 零钱兑换II

题目：518

思路：典型的完全背包问题

1.定义dp数组以及下标
dp[j]表示将容量为 j 的完全背包装满的方法数

2.确定递推公式
dp[j] += dp[j - weight[i]]，后者表示容量为 j - weight[i]的背包装满的方法，现在又装进一个物品 i，将所有的容量能够新装如一个物品 i 的方法相加即可得到。

3.初始化：
dp[0]表示将背包容量为0，那么应该只有一种方法，就是什么都不装。如果dp[0]为0的话，后面累加均为0。比如dp[1]最多只能装下一个重量为1的元素，所以等于dp[0]；而dp[2]可以装下重量为1或者2的元素，所以是dp[0] + dp1[1]。

4.确定遍历顺序：
外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况，**此时是组合数**。
如果把两个for交换顺序，**此时dp[j]里算出来的就是排列数。**
（外层是物品时，使用完i - 1号物品之后，以后都不会再尝试使用1号物品；内层是物品时，对于背包0 ~ target，每次都会尝试使用所有物品，也就是会出现前面的结果是{1，5}，后面一次的结果可能是{5，1}）

时间复杂度O(mn)，m是重量，n是物品数量；空间复杂度O(m)

### 动态规划总结

主要介绍了两种背包，第一种是01背包，即存在 i 种物品，重量是weight[i]，价值是value[i]。背包的能够承受的最大重量是MaxWeight，每个物品只有1个，如何选择物品使得总价值最大。第二种是完全背包，区别在于物品的个数是无限个。

对于01背包的问题分类：
1.使得价值最高：这一类问题往往需要进行转换，搞清楚背包的重量是什么。比如分割等和子集、最后一块石头的重量II，背包的重量可以看作是总和的一半。
2.求满足背包重量的组合数（方法数）：这里是求刚好把背包装满的方法。关键的递推公式是：dp[j] += dp[j - weight[i]];

对于完全背包的问题分类：
1.使得价值最高：与01背包不同的是遍历顺序，01背包要求外层循环必须是物品数，内层循环是重量且必须是逆序（从二维数组考虑，右下角元素依赖于左上角元素，如果从左向右遍历，那么左边元素依次被覆盖）。而完全背包对于内外层循环没有要求，且不能逆序。
2.求满足背包的组合数和排列数：求组合数就是让物品在外层循环，求排列数就是让重量在外层循环。（这样考虑，物品在外层循环时，内层更新所有的重量，轮到下一个物品时不会再装上一个物品；物品在内层循环时，对于每一种重量，都会使用所有的物品放进去尝试。）比如零钱兑换II种求的是方法个数，也就是组合数，所以物品必须在外层遍历。

### 组合总和IV

题目：377

思路：与之前讨论的一样，对于完全背包的排列数问题。外层循环是重量，内层循环是物品。

这里需要注意的是，题目保证答案是32位无符号整数。

时间复杂度O(target * n)；空间复杂度O(target)

### 爬楼梯

题目：70

思路  ：将其看作是一个完全背包问题，物品只有两个，就是1和2，背包重量是n，求刚好组成n的排列数。

时间复杂度O(n)，空间复杂度O(n)。



之前采取dp[i] = dp[i - 1] + dp[i - 2]的时间复杂度是O(n)，空间复杂度是O(1)

以及采取分治法，也就是递归的方法，时间复杂度是O(2\^n)，因为将每个问题分成两个子问题，知道问题的规模是1或者2，所以可以看作是一个二叉树，每个结点的时间复杂度是O(n)，大致2\^n个结点。

### 零钱兑换

题目：322

思路：每种物品的数量无限，所以是一个完全背包问题。

1.定义dp数组和下标定义
dp[j]表示重量为 j 的背包装满后最小的物品个数。

2.确定递推公式：
dp[j] = min（dp[j]，dp[j - amount[i]] + 1）。表示重量为j - amount[i]的背包加上目前物品的重量，刚好是重量j的背包，但是多加了一个物品个数。

3.初始化：
dp[0]表示重量为0的背包需要的硬币个数为0；对于其它重量来说，应该初始化为一个比较大的数字。

4.遍历顺序：
本题求钱币最小个数，**那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数**。
**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。
**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。



时间复杂度O(amount * n)；空间复杂度O(amount)

### 完全平方数

题目：279

思路：物品是小于等于n的完全平方数，背包重量是n，求装满背包的最小的物品数量。

与上一题一致。

时间复杂度O(n ^ (3/2))，空间复杂度O(n)

### 总结

主要有两种类型：

完全背包（即物品数为无限个）：
1.组合与排列数：**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。
2.求装满背包使用最少的物品个数：递推公式为dp[j] = min（dp[j]，dp[j - amount[i]] + 1）



### 单词拆分

题目：139

思路1：背包就是字符串s，物品就是单词，能否组成字符串，就是物品能否将背包装满。

1.定义dp数组和下标
dp[i] 表示字符串长度为 i 时能否由字典中的单词构成

2.确定递推公式：
如果dp[i] 是true，那么如果[i + 1, j]这个长度区间中的子串 出现在字典中，那么dp[j] 一定是true

更新的时候应该是从前向后更新dp数组，所以想要更新dp[j] ，必须确定dp[i] ，也就是字符数量少于 j 的背包。

3.初始化：
dp[0]表示长度为0的字符串，一定可以由字典组成，所以是true

4.遍历顺序：
因为求的是物品的排列形式，所以背包在外面，物品在内循环

```c++
bool wordBreak(string s, vector<string>& wordDict) {
    // 使用无序集合方便在其中查找单词
    unordered_set<string> wordSet(wordDict.begin(), wordDict.end());

    // 定义dp数组和初始化
    vector<bool> dp(s.size() + 1, false);
    dp[0] = true;

    // 外层循环遍历背包
    // i表示背包长度
    for (int i = 1; i <= s.size(); i++) {
        // 内层循环遍历背包后面的物品
        // s[0, j)表示背包中的字符串
        // s[j, i)表示背包后面的字串
        for (int j = 0; j < i; j++) {
            string back = s.substr(j, i - j);
            if (wordSet.find(back) != wordSet.end() &&
                dp[j] == true) {
                dp[i] = true;
            } 
        } // end of for j in range[0, i)

    } // end of for i in range[1, s.size()]

    return dp[s.size()];
}
```

时间复杂度O(n^3)，包括两层循环以及在返回字串的副本的复杂度O(n）；空间复杂度O(n)



另一种思路：回溯法：类似于回文串切割：
<img src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" alt="131.分割回文串" style="zoom:50%;" />

只有当前面切割的字符串能够在单词表中查找到时，才进行递归切割。

1.递归的参数以及返回值：
参数包括总的字符串、起点、以及单词表，返回值表示能否切割

2.递归终止条件
当起点到达字符串长度时，说明前面都已匹配成功。

3.单层处理逻辑：
从起点开始向后遍历组成字符串，即s[start_index, i]，如果这一段字串能够在单词表找到，并且以i + 1为起点进行递归，如果也返回true，说明可以由单词表构成，所以返回true。回溯的过程就是没有递归没有返回true时，i 仍然是旧值，新的子串是从s[start_index, i]到s[start_index, i + 1]

```c++
bool BackTrace(const string &s, const int start_index, const unordered_set<string> &word_set) {
    // 递归终止条件
    if (start_index >= s.size()) return true;

    // 单层处理逻辑
    for (int i = start_index; i < s.size(); ++i) {
        string str = s.substr(start_index, i - start_index + 1);
        if (word_set.find(str) != word_set.end() && BackTrace(s, i + 1, word_set))
            return true;
    }

    return false;
}


bool wordBreak(string s, vector<string>& wordDict) {
    // 使用无序集合方便在其中查找单词
    unordered_set<string> wordSet(wordDict.begin(), wordDict.end());

    // 回溯
    return BackTrace(s, 0, wordSet);

}
```

时间复杂度O(2^n)



### 多重背包理论

多种背包与01背包和完全背包的区别就是：多种背包中物品 i 的数量是Mi。

解决方法就是将Mi个 物品 i 作为Mi个相同的物品 i ，也就是一个01背包问题：背包最大重量为10。

物品为：

|       | 重量 | 价值 | 数量 |
| ----- | ---- | ---- | ---- |
| 物品0 | 1    | 15   | 2    |
| 物品1 | 3    | 20   | 3    |
| 物品2 | 4    | 30   | 2    |

问背包能背的物品最大价值是多少？

和如下情况有区别么？

|       | 重量 | 价值 | 数量 |
| ----- | ---- | ---- | ---- |
| 物品0 | 1    | 15   | 1    |
| 物品0 | 1    | 15   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品2 | 4    | 30   | 1    |
| 物品2 | 4    | 30   | 1    |

毫无区别，这就转成了一个01背包问题了，且每个物品只用一次。

### 背包问题总结

**整体步骤：**

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

**递推公式：**
问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])
问装满背包有几种方法：dp[j] += dp[j - nums[i]]
问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j])

**遍历顺序：**
01背包：二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。
一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历

完全背包：纯完全背包的一维dp数组实现，先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。**如果求排列数就是外层for遍历背包，内层for循环遍历物品**

### 打家劫舍

题目：198

思路：由于每家最多偷盗一次，所以这是一个01背包问题。在不受限制的情况下可以将所有目标均偷盗，所以背包重量最大为个数。

每个物品的价值就是每一家的金额数。

1.定义dp数组和下标
dp[i] 表示偷盗前 i 家时最大的金额，其中 i 表示物品下标

2.递推公式：
想要确定dp[i]，有两种方式：第一种是选择第 i 家，就不能选择第i - 1家，那么此时金额为 dp[i - 2] + nums[i]；第二种方式是不选择第 i 家，因为不偷第 i 家，所以此时金额就是dp[i - 1]

3.dp数组初始化
dp[0] = nums[0]

dp[1] = max(nums[0], nusm[1])

4.确定遍历顺序：
由于依赖于前面的数据，因此只能从前向后



时间复杂度O(n)；空间复杂度O(n)，实际上可以优化为只保存为前两个数据，不需要整个dp数组。

### 打家劫舍II

题目：213

思路：由于是循环的数组，第一个和最后一个相邻，不能同时选择

所以关键在于二者的状态：

第一种：二者都不在选择中，即从第二个到倒数第二个，这样二者都不会选

第二种：第一个不在选择中，即从第二个到最后一个，这样可以选最后一个（即选择最后一个，不选择第一个），也可以不选最后一个（这种情况下就是二者都不选，与第一种情况相同）

第三种：最后一个不在选择中，即从第一个到倒数第二个（选择第一个，不选择最后一个），这样可以选第一个，也可以不选第一个（同情况一）

上述第二种和第一种就已经包含了二者的三种状态。

dp数组与上一题一致，不同的是物品的范围。

时间复杂度O(n)，相当于做两次n；空间复杂度O(n)，dp数组消耗空间

### 打家劫舍III

题目：337

思路1：

1.定义dp数组和下标含义
dp(cur)：表示以cur为根节点的树的最大值，这个最大值有两种可能，（1）不选cur，那么就需要知道左孩子和右孩子的最大值；（2）选则cur，那就不能选择左孩子和右孩子，只能选择左子树且去除左孩子的最大值，和右子树且取出右孩子的最大值

因此返回值是一个vector，这样就能保存{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱}，进而计算出根结点的最大值

2.递推公式如1所述

3.初始化：
即对于空结点或者没有孩子的结点的树来说。
首先是空结点，那么：（1）不偷当前结点的最大值：0；（2）偷当前结点的最大值为0
其次是没有左孩子和右孩子的结点，那么（1）不偷当前结点的最大值：0；（2）偷当前结点的最大值，当前结点的值
然后是只有一个孩子的结点，那么（1）不偷当前结点的最大值：这个孩子的值；（2）偷当前结点的最大值，max(当前结点的值, 孩子的值)
最后有两个孩子的结点，那么（1）不偷当前结点的最大值：左子树最大值+右子树最大值；（2）当前结点的最大值：当前结点的值+不偷左子树的根节点的最大值+不偷右子树的根节点的最大值  

上面几种情况存在重叠，其中第2、3与第4种情况重叠

4.遍历顺序：
采用后序遍历，先计算左右子树的返回值，再由此计算当前的返回值

5.单层逻辑如3所述

时间复杂度O(n)，相当于遍历一遍二叉树的所有节点；空间复杂度O(logn)，系统递归调用栈



思路2：

暴力递归：

```c++
int rob(TreeNode* root) {
    if (root == NULL) return 0;
    if (root->left == NULL && root->right == NULL) return root->val;
    // 偷父节点
    int val1 = root->val;
    if (root->left) val1 += rob(root->left->left) + rob(root->left->right); // 跳过root->left，相当于不考虑左孩子了
    if (root->right) val1 += rob(root->right->left) + rob(root->right->right); // 跳过root->right，相当于不考虑右孩子了
    // 不偷父节点
    int val2 = rob(root->left) + rob(root->right); // 考虑root的左右孩子
    return max(val1, val2);
}
```

对于每一个结点来说，都需要计算一遍以这个结点为根的子树的所有结点的最大值，这里面一定会存在大量的**子问题重叠**，并且父节点的最优解是由孩子结点和孙子结点两个子问题的最优解计算出来（原问题的最优解包含子问题的最优解）。解决方法就是需要保存一下曾经计算过的子问题的解，作者这里给出了一种使用map保存中间结果的方法。

与上面使用动态规划的方法其实本质上是一样的，**动态规划本身就是自底向上计算，这样就能利用前者计算后者的解**。
而传统的二叉树必然是自顶向下**遍历**，所以采用后序遍历实现自底向上**访问**所有结点，这样能把子问题的解作为结果传递给更大的问题。

```c++
unordered_map<TreeNode* , int> umap; // 记录计算过的结果
```



### 总结

**打家劫舍：**这里的限制是对于一个数组来说，不能偷相邻的两家，所以使得递推公式中，要么偷第 i 家，不能偷第i - 1家；要么偷第 i - 1家，不偷第 i 家。选择价值更大的。

**打家劫舍II：**数组成环，所以需要考虑最后一个和第一个的关系，即只能从都不考虑、考虑起点不考虑终点、不考虑起点考虑终点中选择最大的一个

**打家劫舍III：**对于二叉树的动态规划，这里动态规划的思想是自底向上，所以采用后序遍历；因为二叉树的遍历涉及到递归，且不能提前知道有多少个节点，所以只能将后者依赖的值作为递归函数的返回值传递。（这里貌似也可以使用后序遍历的非递归形式，只不过由于不能提前知道节点数，所以dp数组的大小不能提前确定）







### 买卖股票的最佳时机

题目：121

思路1：采用暴力解法：双层循环，外层循环是表示某一天买入，内层循环尝试后面的一天卖出，计算最大的差值就是利润。

时间复杂度O(n^2)；空间复杂度O(1)



思路2：贪心算法：取局部状态下（比如当前只有n个数字，第n + 1个数字比前n个数字中最小值都要小），最左边的最小值和最右边的最大值（就是前n个数字中的最左最小值和最右最大值）。
整体最大值：从所有局部状态下选取最大的值。

从左向右遍历，维护一个最小值；维护一个结果值，只有当price[i] - 最小值比结果值大时才更新。

时间复杂度O(n)；空间复杂度O(1)



思路3：动态规划

1.定义dp数组和下标：
dp[i]\[0]表示第 i 天**持有**股票所得最多现金，假如前一天没有持有股票，但是今天持有股票，说明今天购入股票，此时现金为:
 -prices[i]
dp[i]\[1]表示第 i 天**不持有**股票所得最大现金。
（我的思路：定义dp[i]为第 i 天所得最多现金，由于只能购买和卖出一次，这里的问题就是不知道哪一天购入的股票，因此也就无法得知哪一天卖出能够或得最大利润。作者记录之前一天的两种状态，有和没有股票，这样就能判断是哪一天买入，从而计算哪一天卖出。）

2.定义递推公式：

对于dp[i]\[0]。表示第 i 天持有股票所得最大现金：
如果第 i - 1天不持有股票，那么第 i 天持有股票，说明是第 i 天购入股票，此时dp[i]\[0] = -prices[i]
如果第 i - 1天持有股票，那么第 i 天也持有股票，说明不是第 i 天购入的，且第 i 天也没有卖出，那么金钱维持不变。dp[i]\[0] = dp[i - 1]\[0]

max(-prices[i], dp[i - 1]\[0])

对于dp[i]\[1]，表示第 i 天不持有股票所得最大现金：
如果第 i - 1天不持有股票，那么第 i 天也不持有股票，此时没有变化，dp[i]\[1] = dp[i - 1]\[1]
如果第 i - 1天持有股票，但是第 i 天不持有股票，说明是第 i 天卖出股票，此时获得收益，dp[i]\[1] = dp[i - 1]\[0] + prices[i]

max(dp[i - 1]\[1], dp[i - 1]\[0] + prices[i])

3.初始化：
dp[0]\[0]表示第0天持有股票所得最大现金，此时只有可能是第 0 天买的股票，不可能是前一天推出来的，所以是 -prices[0]

dp[0]\[1]表示第0天不持有股票所得最大现金，不可能有前一天，所以此时不持有股票就是0

4.遍历顺序：
由于后者依赖于前者，只能从前向后

5.测试：[7,1,5,3,6,4] **本题中不持有股票状态所得金钱一定比持有股票状态得到的多**



时间复杂度O(n)， 空间复杂度O(n)，由于只依赖于前面的dp数组的两个值，所以可以改为时间复杂度为O(1)的算法。



PS:**另一种定义**：在这个问题中，我们可以定义一个状态 `dp[i]`，表示第 `i` 天**卖出股票**所能获取的最大利润。

接下来，我们考虑状态 `dp[i]` 和前一天的状态 `dp[i-1]` 之间的关系。当我们在第 `i` 天卖出股票时，我们可以选择在前面的某一天买入股票，使得利润最大化。因此，我们需要找到在前 `i` 天中的最低股票价格 `min_price`，然后计算当前的利润 `prices[i] - min_price`。

状态转移方程可以表示为：`dp[i] = max(dp[i-1], prices[i] - min_price)`，其中 `dp[i-1]` 表示在第 `i-1` 天时卖出股票的最大利润，`prices[i]` 是第 `i` 天的股票价格，`min_price` 是前 `i` 天中的最低股票价格。

通过不断地更新 `min_price` 和计算 `dp[i]`，我们可以得到最终的最大利润，即 `dp[n-1]`，其中 `n` 是价格数组的长度。

### 买卖股票的最佳时机 II

题目：122

思路1：贪心：因为可以买卖任意次数，但是只能同时持有一个股票，所以可以考虑前一天买入，后一天卖出，这样，这样就能得到每一天的利润。选择利润为正的相加。

假如第 0 天买入，第 3 天卖出，那么利润为：prices[3] - prices[0]。

相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。

**此时就是把利润分解为每天为单位的维度，而不是从 0 天到第 3 天整体去考虑！**

那么根据 prices 可以得到每天的利润序列：(prices[i] - prices[i - 1]).....(prices[1] - prices[0])。



思路2：动态规划：
(作者是怎么想出来的：
动态规划需要找到原问题和子问题存在的关系。必须定义好原问题和子问题。
如果定义原问题是第n天能够获得的最多的利润，那么子问题就是第n-1天、第n-2天能够获得的最多的利润。
那么原问题和子问题之间有什么关系呢？或者应该如何根据子问题得到原问题呢？假设已经知道子问题的答案，那么想要求第n天的最大利润，目前只知道第n天的价格，不清楚目前是否持有股票，假如之前没有持有股票，那么此时可以选择持有或者不持有股票；假如之前持有股票，那么此时可以选择继续持有股票或者不持有股票。

经过上面分析，可以发现原问题需要维持两种状态，即持有或者不持有股票。)

1.定义dp数组和下标：
dp[i]\[0]：表示第 i 天持有股票的最大利润。
dp[i]\[1]：表示第 i 天不持有股票的最大利润。

2.递推公式：
对于dp[i]\[0]：
假如前一天不持有股票，此时持有股票，那么此时应该为：dp[i - 1]\[1] - prices[i]；
假如前一天持有股票，此时也持有股票，那么此时应该保持不变：dp[i - 1]\[0]；
则dp[i]\[0] = max(dp[i - 1]\[1] - prices[i], dp[i - 1]\[0])

对于dp[i]\[1]：
如果前一天不持有股票，此时也选择不持有股票，那么此时应该为：dp[i - 1]\[1]；
如果前一天持有股票，此时选择不持有股票，那么此时应该为：dp[i]\[0] + prices[i]；
则dp[i]\[1] = max(dp[i - 1]\[1]，dp[i]\[0] + prices[i])

3.初始化：
对于dp[0]\[0]：表示第0天持有股票，因为不存在前一天，所以一定是当前购入股票，因此是 -prices[0];
对于dp[0]\[1]：表示第0天不持有股票，所以应该为0。

4.遍历顺序：
因为后者依赖于前者，所以是从前向后

5.测试用例：
[7,1,5,3,6,4]

**最后一定是不持有能够获得最大利润。**

时间复杂度O(n)；空间复杂度O(n)，实际上后者只依赖于前者的两个数据，所以可以改为O(1)

### 买卖股票的最佳时机III

题目：123

作者的思路：之前的动态规划数组，对于一天有两种状态，持有或者不持有股票。而由于本题限制只能买卖两次，那么对于一天来说，一共有：不操作（0）、第一次买入（1）、第一次卖出（2）、第二次买入（3）、第二次卖出（4）五种状态。

1.定义dp数组和下标含义：
dp[i]\[j]：j = 0，1，2，3，4：表示第 i 天处于哪种状态下持有的金钱数目

2.递推公式：
对于dp[i]\[0]：表示第 i 天处于什么也没干的状态，即前面几天即没买入也没卖出，那么一定是0；

对于dp[i]\[1]：表示第 i 天处于第一次买入状态（即有可能是前 i - 1天的任何一天买入，也有可能是第 i 天第一次买入：
如果是前 i - 1天买入，那么第 i 天什么也没做，所以是dp[i - 1]\[1]；
如果是第 i 天第一次买入，那么是从前一天什么也没干的状态到买入状态，即dp[i - 1]\[0] - prices[i]；
所以dp[i]\[1] = max(dp[i - 1]\[1]，dp[i - 1]\[0] - prices[i])

对于dp[i]\[2]：表示第 i 天处于第一次卖出状态：
如果是前 i - 1天中的某一天卖出的，那么第 i 天就什么也没干，继续沿用之前的金钱，即dp[i - 1]\[2]；
如果是第 i 天卖出，那么表示前 i - 1 天的状态一定是第一次买入，所以为dp[i - 1]\[1] + prices[i]；
所以dp[i]\[2] = max(dp[i - 1]\[2], dp[i - 1]\[1] + prices[i])

对于dp[i]\[3]：表示第 i 天处于第二次买入状态：
如果是前 i - 1天中某天买入的，那么第 i 天什么都没干，继续沿用之前的金钱，即dp[i - 1]\[3]；
如果是第 i 天买入的，说明前面一定处于第一次卖出状态，所以为dp[i - 1]\[2] - prices[i]；
所以dp[i]\[3] = max(dp[i - 1]\[3], dp[i - 1]\[2] - prices[i])

对于dp[i]\[4]：表示第 i 天处于第二次卖出状态：
如果是前 i - 1天中的某一天卖出的，那么第 i 天什么都没干，即dp[i - 1]\[4]；
如果是第 i 天卖出的，那么前面一定处于第二次买入状态，所以dp[i - 1]\[3] + prices[i]；
所以dp[i]\[4] = max(dp[i - 1]\[4], dp[i - 1]\[3] + prices[i])

3.初始化：
dp[0]\[0]：什么都不做的状态一定是0，包括dp[i]\[0]都应该是0；
dp[0]\[1]：第一天就买入，那么一定是 -prices[i]；
dp[0]\[2]：第一天就卖出，一定是买入之后又卖出，所以是0；
dp[0]\[3]：第一天就第二次买入，说明一定是第一次买入和卖出之后又买入，因此也是-prices[i]；
dp[0]\[4]：第一天就第二次卖出，说明一定是第一次买入和卖出之后，第二次买入又卖出，因此是0。

4.遍历顺序：
后者依赖于前者，一定是从前向后仰。

5.举例子：以输入[1,2,3,4,5]为例

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201228181724295-20230310134201291.png" alt="123.买卖股票的最佳时机III" style="zoom:67%;" />

大家可以看到红色框为最后两次卖出的状态。

现在最大的时候一定是卖出的状态，而两次卖出的状态现金最大一定是最后一次卖出。如果想不明白的录友也可以这么理解：如果第一次卖出已经是最大值了，那么我们可以在当天立刻买入再立刻卖出。所以dp[4][4]已经包含了dp[4][2]的情况。也就是说第二次卖出手里所剩的钱一定是最多的。

时间复杂度O(n)；空间复杂度O(n)

### 买卖股票的最佳时机IV

题目：188

思路：与上一题类似，上一题是最多买卖2次，这里是最多买卖k次，因此只是每一天的状态数目不同。

1.确定dp数组和下标定义：
dp[i]\[2 * j + 1]表示第 i 天处于第 j 次买入状态拥有的金钱数目；
dp[i]\[2 * j + 2]表示第 i 天处于第 j 次卖出状态拥有的金钱数目；
其中 j 的范围是 [0, k)

2.递推公式：

```c++
// 更新第 j 次的买入状态
dp[i][j * 2 + 1] = max(dp[i - 1][j * 2 + 1], dp[i][j * 2] - prices[i]);
// 更新第 j 次的卖出状态
dp[i][j * 2 + 2] = max(dp[i - 1][j * 2 + 2], dp[i][j * 2 + 1] + prices[i]);
```

3.初始化：

```
dp[0][j * 2 + 1]：买入状态都为 -prices[i]，表示在一天内前面j-1次都买入之后又卖出，第j次买入；
dp[0][j * 2 + 1]：卖出状态都为0，表示第一天前面j-1次都买入之后又卖出，第j次也是买入又卖出，因此没有花钱。
```

4.遍历顺序：
从前向后



时间复杂度O(n * k)；空间复杂度O(n * k)

### 买卖股票的最佳时机含冷冻期

题目：309

思路：这里可以多次进行买和卖，但是卖出之后第二天不能买，因此需要细分一天的状态，尤其是处理卖出股票和冷冻期状态。需要保持的状态有：持有股票的状态，卖出股票状态（前面卖出而非今天卖出），今天卖出股票状态，冷冻期状态。区分出两种卖出状态是为了方便更新冷冻期状态，冷冻期状态只能由昨天是卖出状态来更新，因此将卖出区分为前几天卖出和今天卖出。

1.定义dp数组和下标含义：
dp[i]\[0]：表示第 i 天处于持有股票状态；
dp[i]\[1]：表示第 i 天处于卖出股票状态（昨天卖出已经由冷冻期表示，因此这里只能是前一天卖出或者前两天卖出）；
dp[i]\[2]：表示第 i 天处于今天卖出状态；
dp[i]\[3]：表示第 i 天处于冷冻期状态（昨天卖出）

2.递推公式：

对于dp[i]\[0]：
如果是前面买入，那么表示第 i 天没有进行操作，所以为dp[i - 1]\[0]；
如果是今天买入，说明前面处于卖出状态（前一天卖出或者前两天卖出）或者冷冻期状态（昨天卖出），所以要么是dp[i - 1]\[1] - prices[i]，要么是dp[i - 1]\[3] - prices[0]；
所以dp[i]\[0] = max(dp[i - 1]\[0], dp[i - 1]\[1] - prices[i], dp[i - 1]\[3] - prices[0])

对于dp[i]\[1]：（不能是昨天卖出）
如果是前天卖出的股票，那么昨天一定是冷冻期，所以是dp[i - 1]\[3]；
如果是前两天卖出的股票，那么昨天一定是处于第二种状态（要么前一天卖出，要么前两天卖出），所以就是dp[i - 1]\[1]；
所以dp[i]\[1] = max(dp[i - 1]\[3], dp[i - 1]\[1])

对于dp[i]\[2]：
表示第 i 天卖出，那么第 i - 1天一定是持有股票状态，所以dp[i]\[2] = dp[i - 1]\[0] + prices[i]

对于dp[i]\[3]：
表示第 i 天处于冷冻期，那么第 i - 1 天一定是处于”当天卖出状态“，所以dp[i]\[3] = dp[i - 1]\[2]

3.初始化：
对于dp[0]\[0]，表示第0天买入，则为 -prices[i]；
对于dp[0]\[1]，表示非第0天卖出，这里很难从定义上理解，只能从递推公式上看需要这个值为多少，如果i为1，第1天买入股票，那么递归公式中需要计算 dp[i - 1][1] - prices[i] ，即 dp[0][1] - prices[1]，那么大家感受一下 dp[0][1] （即第0天的状态二）应该初始成多少，只能初始为0。想一想如果初始为其他数值，是我们第1天买入股票后 手里还剩的现金数量是不是就不对了。
对于dp[0]\[2]，表示第0天买入之后又卖出，那么此时为0；
对于dp[0]\[3]，同dp[0]\[1]

4.遍历顺序：
从前向后



时间复杂度O(n)；空间复杂度O(n)

### 买卖股票的最佳时机含手续费

题目：714

思路：这里买卖股票次数没有限制，但是每买卖一次就需要一次手续费，也就是在买入或者卖出时需要多支付一笔钱。

1.定义dp数组和下标含义：
dp[i]\[0]：表示第 i 天持有股票时拥有的金钱数目；
dp[i]\[1]：表示第 i 天不持有股票时拥有的金钱数目。

2.递推公式：

对于dp[i]\[0]：
如果前一天不持有股票，那么一定是第 i 天购入股票，所以为：dp[i - 1]\[1] - prices；
如果前一天持有股票，那么低 i 天什么都没做，所以为：dp[i - 1]\[0]
所以dp[i]\[0] = max(dp[i - 1]\[1] - prices, dp[i - 1]\[0])

对于dp[i]\[1]：
如果前一天不持有股票，那么第 i 天也不持有股票说明什么都没做，所以为：dp[i - 1]\[1]；
如果前一天持有股票，那么第 i 天不持有说明第 i 天卖出，另外卖出时说明一笔交易完成，需要付一笔手续费，所以为：dp[i - 1]\[0] + pricesp[i] - fee；
所以dp[i]\[1] = max(dp[i - 1]\[1], dp[i - 1]\[0] + pricesp[i] - fee)

3.初始化：
对于dp[0]\[0]：表示第 0天持有，由于没有前一天，一定是当天买入的，所以为 -prices[i];
对于dp[0]\[1]：表示第 0 天不持有，可能是没有买入没有卖出，此时为0；也有可能是买入之后卖出，多付一笔交易费fee；因此最大金额一定是不操作

4.遍历顺序：
后者依赖于前者，从前向后

5.举例子：
[1, 3, 2, 8, 4, 9], fee = 2



时间复杂度O(n)；空间复杂度O(n)

### 股票问题总结

<img src="https://code-thinking.cdn.bcebos.com/pics/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.jpg" alt="股票问题总结" style="zoom: 50%;" />

**买卖股票的最佳时机：**股票只能买卖一次，问最大利润。

【贪心解法】

取最左最小值，取最右最大值，那么得到的差值就是最大利润，代码如下：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int low = INT_MAX;
        int result = 0;
        for (int i = 0; i < prices.size(); i++) {
            low = min(low, prices[i]);  // 取最左最小价格
            result = max(result, prices[i] - low); // 直接取最大区间利润
        }
        return result;
    }
};
```

【动态规划】

- dp[i]\[0] 表示第i天持有股票所得现金。
- dp[i]\[1] 表示第i天不持有股票所得现金。

如果第i天持有股票即dp[i]\[0]， 那么可以由两个状态推出来

- 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1]\[0]
- 第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i] 所以dp[i][0] = max(dp[i - 1]\[0], -prices[i]);

如果第i天不持有股票即dp[i]\[1]， 也可以由两个状态推出来

- 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1]\[1]
- 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1]\[0] 所以dp[i]\[1] = max(dp[i - 1]\[1], prices[i] + dp[i - 1]\[0])



**买卖股票的最佳时机II**：可以多次买卖股票，问最大收益。

【贪心解法】

收集每天的正利润便可，代码如下：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        for (int i = 1; i < prices.size(); i++) {
            result += max(prices[i] - prices[i - 1], 0);
        }
        return result;
    }
};
```

- 时间复杂度：O(n)
- 空间复杂度：O(1)

【动态规划】

dp数组定义：

- dp[i]\[0] 表示第i天持有股票所得现金
- dp[i]\[1] 表示第i天不持有股票所得最多现金

如果第i天持有股票即dp[i]\[0]， 那么可以由两个状态推出来

- 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1]\[0]
- 第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1]\[1] - prices[i]

**注意这里和上一题唯一不同的地方，就是推导dp[i]\[0]的时候，第i天买入股票的情况**。

在上一题中，因为股票全程只能买卖一次，所以如果买入股票，那么第i天持有股票即dp[i]\[0]一定就是 -prices[i]。

而本题，因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润。



**买卖股票的最佳时机III**：最多买卖两次，问最大收益。

一天一共就有五个状态，

1. 没有操作
2. 第一次买入
3. 第一次卖出
4. 第二次买入
5. 第二次卖出



**买卖股票的最佳时机IV**：最多买卖k笔交易，问最大收益。

使用二维数组 dp[i][j] ：第i天的状态为j，所剩下的最大现金是dp[i][j]

j的状态表示为：

- 0 表示不操作
- 1 第一次买入
- 2 第一次卖出
- 3 第二次买入
- 4 第二次卖出
- .....

除了0以外，偶数就是卖出，奇数就是买入。



**最佳买卖股票时机含冷冻期**：可以多次买卖但每次卖出有冷冻期1天。

dp[i][j]：第i天状态为j，所剩的最多现金为dp[i][j]。

具体可以区分出如下四个状态：

- 状态一：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）
- 卖出股票状态，这里就有两种卖出股票状态
  - 状态二：两天前（前天或者前两天）就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态
  - 状态三：今天卖出了股票
- 状态四：今天为冷冻期状态，表示一定是昨天卖出的股票



**买卖股票的最佳时机含手续费**：可以多次买卖，但每次有手续费。

**本题和买卖股票的最佳时机II的区别就是这里需要多一个减去手续费的操作**。

### 最长递增子序列

题目：300

思路：动态规划的两个典型特征，（1）子问题重叠；（2）最优子结构
如何定义原问题能够使得满足这两个性质呢？

**dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度**

为什么一定表示 “以nums[i]结尾的最长递增子序” ，因为我们在 做 递增比较的时候，如果比较 nums[j] 和 nums[i] 的大小，那么两个递增子序列一定分别以nums[j]为结尾 和 nums[i]为结尾， 要不然这个比较就没有意义了，不是尾部元素的比较那么 如何算递增呢。

1.定义dp数组和下标定义：
如上

2.确定递推公式：
位置 i 的最长子序列一定是有前面的子问题推出，所以只要是比nums[i]小的尾元素，都可以作为 i 的子问题。如果都比nums[i]大或者等于nums[i]，那么长度只能为1。所以递推公式为：

```
if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
```

3.初始化：
至少都为1

4.遍历顺序：
从前向后

这里注意，dp[i]表示的是以nums[i]为最后一个元素的最长子序列，所以最终的结果是找所有dp中最大的。

时间复杂度O(n^2)；空间复杂度O(n)



### 最长连续递增序列

题目：674

思路1：遍历数组，记录每一个递增子序列长度，保存下最长的记录。

```c++
int findLengthOfLCIS(vector<int>& nums) {
    if (nums.size() == 0) return 0;

    int result = 0;
    int count = 1; // 表示遍历时递增子序列长度
    int last = nums[0];

    // 遍历数组
    for (int i = 1; i < nums.size(); ++i) {
        if (last < nums[i]) {
            // 如果递增长度加1
            count++;
            last = nums[i];
        } else {
            // 此时不再是连续递增
            // 记录最长长度
            count > result ? result = count : result;

            count = 1; // 更新递增子序列长度
            last = nums[i];
        }
    }

    // 比较最后一个递增子序列长度
    count > result ? result = count : result;

    return result;
}
```

时间复杂度O(n)；空间复杂度O(1)



思路2：动态规划：这一题与上一题不一样的是子序列必须是连续的，不能是间隔的。

1.定义dp数组和下标：
dp[i] 表示以 nums[i] 为最后一个元素的连续递增子序列的长度

为什么这么定义？所有的连续递增子序列一定有一个尾部元素，那么分别以每个元素为尾部元素，一定可以找到所有的递增子序列。取最长的就是要找的目标。

2.递推公式：
对于dp[i] 来说，至少它自身构成了一个“连续递增序列”，如果想要构成一个以nums[i]为尾部元素的递增序列，那么nums[i]必须大于nums[i - 1]，否则就不是一个连续的序列。所以递推公式为：

```
if (nums[i] > nums[i - 1]) dp[i] = dp[i - 1] + 1
```

3.初始化：
以每个元素为尾部元素的子序列长度至少是1

4.遍历顺序：
从前向后

5.例子：
[1,3,5,4,7]

时间复杂度O(n)；空间复杂度O(n)

### 最长重复子数组

题目：718

思路1：暴力解法：认为子数组指的是原数组中连续的一段数组序列，而不是间隔的子数组概念。
外层循环遍历第一个数组的所有元素作为子数组起点，中间循环遍历第二个数组与外层循环一样的元素作为起点，内层循环尝试比较二者后面的元素是否一一对应，记录下最长的长度。

~~优化：假设三层循环分别是i，j，k。如果已经找到了一段公共的子数组，那么此时第一个数组的[i, i + k]和第二个数组的[j,j + k]这一段都已经比较过了，所以不用再次比较；因此下一次循环时 i 直接从 i + k + 1开始~~
不正确，因为第二个数组中可能有多个与第一个数组起点相同的元素，比较完[i, i + k]和[j,j + k]之后，无法保证会不会存在以[i+1, i+k]为起点的元素在第二个数组中有比[j+1, j+k]这段序列更长的子序列，即在第二个数组中存在另一个 m ，使得[(i+1~i+k的其中一个元素), i+K]与[m, m+k]更长

优化：修改上面的优化，下一次循环时 j 从j+k+1开始，因为第二个数组是从前向后便利的，即使有多个与外层循环起点相同的元素，j前面的也已经比较过了；即使在[j+1, j+k]这一段中有与外层循环相同的起点元素，**到i+k+1和j+k+1也一定是不同的，所以长度不会超过k**，所以可以从j+k+1开始寻找外层循环的起点元素。
不正确，对于测试用例：
[0,0,0,0,0,0,1,0,0,0]
[0,0,0,0,0,0,0,1,0,0]
假设此时第一个数组的起点是第一个元素，那么当j为0时，比较到 第7个元素时不同，此时最大长度为6；根据上面的优化，此时j应该跳到7开始比较，但是实际上j为1开始比较才是最大长度9。这里的问题是，上面加粗的一段话，所以j下次循环时应该从与外层起点相同的元素开始，不能跳跃。

时间复杂度O(n^3)；空间复杂度O(1)

超时。

思路2：动态规划

定义原问题的关键在于使得原问题能够与子问题建立关系。
我的思考过程：使用dp[i]表示以nums[i]作为最后一个元素的的最大子数组长度，但是这样无法比较两个数组.

所以采用二维数组表示两个号字符串的所有比较情况。

1.定义dp数组和下标含义：
dp[i]\[j]表示以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i]\[j]

(为什么不定义成 以下标i为结尾的A，和以下标j 为结尾的B，最长重复子数组长度？如果定义 dp[i]\[j]为 以下标i为结尾的A，和以下标j 为结尾的B，那么 第一行和第一列要进行初始化，如果nums1[i] 与 nums2[0] 相同的话，对应的 dp[i]\[0]就要初始为1， 因为此时最长重复子数组为1。 nums2[j] 与 nums1[0]相同的话，同理。)

2.递推公式：
对于dp[i]\[j]是要由前面的推出，如果nums[i - 1] == nums[j - 1]，那么（注意i 和 j 都要从1开始）

```
p[i][j] = dp[i - 1][j - 1] + 1
```

3.初始化：
dp[i]\[0]（第一列）和dp[0]\[j]（第一行）都是没有意义的，因为i 和 j 都从1开始。但是由于需要 + 1所以都初始化为0

4.遍历顺序：
需要两层循环，只要保证两层循环都是从前向后即可。

5.测试例子：
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021011215282060.jpg" alt="718.最长重复子数组" style="zoom:50%;" />



时间复杂度O(n*m)；空间复杂度O(nxm)

### 最长公共子序列

题目：1143

思路：参考上一题的思路，定义dp[i]\[j]表示长度为[0, i]的字符串A，和长度为[0, j]字符串B最长公共子序列的长度

2.递推公式：
如果A[i] == B[j]，那么找到了一个公共元素，此时应该为dp[i - 1]\[j - 1] + 1。
如果A[i] != B[j]，那么就需要从A的[0, i - 1]与B的[0, j]的最长子序列，和A的[0, i]与B的[0, j - 1]的最长子序列中选择一个较大的。所以为max(dp[i - 1]\[j]，dp[i]\[j - 1])

3.初始化：
dp[i]\[0]表示长度为[0, i]的字符串A，可长度为下标 0 的字符串B的最长公共字串，那就是如果发现相等后面就都为1，否则就为0；
dp[0]\[j]同理。

4.遍历顺序：
后者依赖于左上、左边、上面元素，所以从左到右的顺序、从上到下的顺序。

5.例子：

<img src="D:\RegularFile\LeetCode-c++\pic\1143.jpg" alt="image-20231008203610077" style="zoom:33%;" />

时间复杂度O(nm)；空间复杂度O(nm)

### 不相交的线

题目：1035

~~思路1~~错误思路：暴力法：

按顺序遍历第一个数组，在第二个数组中寻找相同的元素。由于不能有交叉，所以只能从上一次在第二个数组中找到相同元素的位置向后查找。

不正确：原因在于不应该按顺序配对，因为有可能第一个数组第一个元素直接与第二个数组的最后一个元素相等，这样直接屏蔽了所有可能性。不能做到最大连线数。

思路：动态规划：**本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！**

1.定义dp数组和下标含义：
dp[i]\[j]表示长度为[0, i]的第一个数组和长度为[0, j]的第二个数组的最大连线数目

2.递推公式：
如果第一个数组的A[i] == 第二个数组B[j]，那么此时连线数目应该加1，能够保证不会出现交叉，所以为dp[i - 1]\[j - 1] + 1；
如果不等，让长度为[0, i - 1]的第一个数组与长度为[0, j]的第二个数组比较，寻找最大连线数目；在让长度为[0, i]的第一个数组和长度为[0, j - 1]的第二个数组比较，寻找最大连线数目。此时取二者较大的哪一个。即max(dp[i - 1]\[j], dp[i]\[j - 1])

3.初始化：
dp[i]\[0]表示长度为[0, i]的第一个数组与长度为只有一个元素的第二个数组的最大连线数目，如果发现 A[i] == B[0]，那么下标 i 之后的数组至少都会有 i 与第二个数组的第一个元素有连线，所以后面都为1；
dp[0]\[j]同理。

4.遍历顺序：
从前向后（内循环）；从上到下（外循环）

5.例子：
<img src="C:\Users\10985\AppData\Roaming\Typora\typora-user-images\image-20231008211703858.png" alt="image-20231008211703858" style="zoom:50%;" />

时间复杂度O(nm)；空间复杂度O(nm)

### 最大子数组和

题目：53

思路1：题目要求子数组必须是一段连续部分。

暴力解法：从前向后遍历数组，分别以每一个元素作为起点，然后向后遍历元素，记录最大值。
时间复杂度O(n ^ 2)。

思路2：贪心算法：将整个序列看成是很多段子序列，只将连续和为正的子序列添加，因为如果有一段子序列为负，那么加上这一段一定变小。（之前已经实现过）

时间复杂度O(n)

思路3：动态规划：

1.定义dp数组和下标：
dp[i]表示以 i为最后一个元素的连续子数组的最大和。

2.确定递推公式：
要么dp[i - 1] + nums[i]，要么只能是nums[i]。
因此递推公式就是max(dp[i - 1] + nums[i], nums[i])

3.初始化：
dp[0]只能是第一个元素

4.遍历顺序：
从前向后

5.例子：

时间复杂度O(n)；空间复杂度O(n)，但是由于只依赖与前面一个元素，所以可以降到O(1)

### 子数组、子序列问题总结

不连续：

**最长递增子序列：**给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。这里子序列是非连续的。
这里将原问题定义为以第 n 个字符为结尾元素的子序列的长度，这样定义是为了方便递推，所有的自问题就是分别以[0, n - 1]下标对应的字符作为结尾元素的子序列长度，例如如果已经知道以第 n - 1个字符为结尾i元素的子序列长度，那么只需判断第 n 个字符与第 n - 1个字符的关系，就可以判断是否将长度加 1.那么遍历以第[0, n -1]个字符结尾的子序列长度，以最大的作为原问题的解。

如果将原问题定义为n个字符的数组最长的子序列长度，那么是没有办法从子问题中推出原问题的，因为连最后一个元素是什么都不知道，现在增加一个元素，怎么知道是否是递增的呢。

递推公式：

```
if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
```



**最长公共子序列：**给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。
这里将原问题定义为：dp[i]\[j]表示长度为[0, i]的S串和长度为[0, j]的T串之间的最长公共子序列长度。这样子问题就是所有长度小于 i 和长度小于 j 的S串和T串的最长公共子序列长度。

递推公式：如果S[i] 与T[j]相等，那么明显是在[0, i - 1]的S串和[0, j - 1]的T串的最长公共子序列长度上加1；
如果不等，那么考虑长度为[0, i - 1]的S串与[0, j]的T串的最长公共子序列，和长度为[0, i]的S串与[0, j - 1]的T串的最长公共子序列，取二者中较大的。

```
if (text1[i - 1] == text2[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1] + 1;
} else {
    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
}
```



**不相交的线：**

绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且直线不能相交！

直线不能相交，这就是说明在字符串A中 找到一个与字符串B相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，链接相同数字的直线就不会相交。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210914145158.png" alt="img" style="zoom:50%;" />

**本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！**



连续：

**最长连续递增自序列：**给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。这里的子序列必须是连续的。

将原问题定义为以下标i为结尾的连续递增的子序列长度为dp[i]。这样定义也是因为能够从子问题推出原问题。

如果定义时没有确定结尾元素的位置，那么无法通过新元素与结尾元素的比较确定子序列是否需要加1.

递推公式：这里因为是连续，所以只能从第 n - 1的子问题上推出，其它的子问题就算添加第 n个元素也是不连续的。

```
dp[i] = dp[i - 1] + 1
```



**最长重复子数组：**给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。题目中说的子数组，其实就是连续子序列。

原问题定义为：dp[i]\[j]以下标i结尾的A，和以下标j为结尾的B，最长重复子数组长度，其实类似于连续递增子序列的思路，这样就可以通过比较A[i]和B[j]是否相同来判断连续相同子序列长度是否应该加1.

```
if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
```





**最大子序和：**给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和

因为是连续，需要最后一个元素的位置信息，所以原问题定义为包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]。

因为是连续子序列和，要么将第 i 个元素加入dp[i - 1]的子序列和，要么就只能重新还是计算子序列，也就是nums[i]

```
dp[i] = max(dp[i - 1] + nums[i], nums[i])
```







### 判断子序列

题目：392

思路1：暴力双指针法：从前向后遍历字符串s，遍历字符串t查找。

时间复杂度最差就是遍历t串中所有元素。空间复杂度O(1)



思路2：之前曾经做过求两个字符串的最大公共子序列的长度，如果最终求出的最大长度为S串的长度，说明S串就是T串的子序列。

1.定义dp数组和下标：
dp[i]\[j]表示长度为[0, i]的S串和长度为[0, j]的T串的最大公共子序列的长度

2.递推公式：
如果S[i] == T[j]，那么长度应该为dp[i - 1]\[j - 1] + 1；
如果不等，那么长度应该从：长度为[0, i - 1]的S串和长度为[0, j]的T串的最长公共子序列长度，长度为[0, i]的S串和长度为[0, j - 1]的T串的最长公共子序列长度，二者中选择较大的。

3.初始化：
对于dp[i]\[0]，如果找到S[i] == T[0]，那么长度大于等于 i 的S串都应该至少有一个字符与T串相等；
dp[0]\[j]同理。

4.遍历顺序：
从左到右，从上到下。

时间复杂度O(nm)，实际上是小于这个值的，这里做了优化是外层循环遍历的是T串，这样如果能够T串早就能够满足S串，就会提前返回结果；空间复杂度O(nm)

思路3：同样是动态规划，但是作者的定义方式不同：与上面类似，均是求出子序列长度最后等于S串长度说明就是可以找到

1.dp数组和下标含义：
dp[i]\[j]表示以S[i]为结尾元素字符串和以T[i]为结尾元素的字符串相同的子序列长度

2.递推公式：
如果S[i] == T[i=j]，那么最长序列长度应该加1，即dp[i - 1]\[j - 1] + 1；
否则，说明T[i]不在S串中，应该删除这个元素，即dp[i]\[j - 1]；

3.初始化：（这里做一下优化，i表示T串）
与上面一致。

4.遍历顺序：
选择外层循环遍历T串，这样如果提前能够找到S串作为子序列，那么就可以提前结束。



时间复杂度O(nm)；空间复杂度O(nm)

### 不同的子序列

题目：115

思路1：~~仍然采用双指针思路，只是遍历完T串之后计数一次，然后从头开始。~~

这是错误的，因为题目中并不是先找到一个T串之后再从剩下的序列中再次尝试找T串。

思路2：动态规划

1.定义dp数组和下标含义：
dp[i]\[j]表示以S[i]结尾的S串子序列与以T[j]结尾的T串（注意不应该是T串子序列，而是以整个T串），T串在S串的子序列中出现的个数

2.递推公式：
如果S[i] == T[j]，那么可以使用S[i]进行匹配，那么个数为dp[i - 1]\[j  -1]；也可以使用S[i - 1]进行匹配，那么个数为dp[i - 1]\[j]。比如bagg和bag，既可以使用S串第四个元素g，也可以使用S串的第三个元素g匹配bag的g。所以是dp[i - 1]\[j - 1] + dp[i - 1]\[j]

如果不等，那么只能尝试使用S[i - 1]进行匹配，即相当于删除S[i]元素。所以是dp[i - 1]\[j]

3.初始化：
每次需要用到左上角和上边元素，因此第一行和第一列必须初始化。
对于dp[i]\[0]，如果出现S[i] == T[0]，那么此时dp[i]\[0]应该是上一次出现相等的次数 + 1，中间不等的部分就是上一次相等的次数；
对于dp[0]\[j]，表示长度只有1的S串可以任意删除元素，与[0, j]的T串进行匹配，T串长度大于S串，因此不可能出现在S串中，均为0.

4.遍历顺序：
从前向后，从上到下



时间复杂度O(nm)；空间复杂度O(nm)

补充：对结果取模10^9 + 7的操作

首先int的范围是2 * 10 ^ 9，其次取模的操作应该是这种形式：

```
count = (count + n) % static<int>(1e9 + 7)
```

等式右边两个int相加需要不超过一个int

### 两个字符串的删除操作

题目：583

思路：动态规划

1.定义dp数组和下标含义：
dp[i]\[j]：表示长度为[0, i]的S串与长度为[0, j]的T串相同所需最小步数。

2.递推公式：
如果S[i] == T[j]，那么不需要进行删除操作，只需要令[0, i - 1]和[0, j - 1]相等即可，所以为dp[i - 1]\[j - 1]：
如果不等，那么有两种方式：第一种是删除S串的最后一个元素，即令[0, i - 1]与[0, j]相等，此时为dp[i - 1]\[j] + 1，第二种方式是删除T串的最后一个元素，即令[0, i]与[0, j - 1]相等，此时为dp[i]\[j - 1] + 1，取两种方式中最小的。
PS:应该还存在一种情况，就是删除S串的最后一个元素和删除T串的最后一个元素，即dp[i - 1]\[j - 1] + 2。但是这种情况可以这么理解：dp[i  - 1]\[j]表示不考虑S串的最后一个元素，如果再删除一个T串的最后一个元素，那么相当于同时删除了S串和T串的最后一个元素，即为dp[i - 1]\[j] + 1。

3.初始化：
首先是dp[0]\[0]，表示只有一个元素的S串和T串，如果相等，那么无需操作，即为0；否则需要删除S串的一个元素，删除T串唯一元素，让两者都成为空串就像等，即为2；
其次是对于dp[i]\[0]，表示长度为[0, i]的S串与只有一个元素的T串变成相等需要的操作数，假如当前S串下标为 i ，如果S[i]与T[0]相等，就需要删除S串中前面的所有元素，dp[i]\[0] = i；如果不等，就是dp[i + 1]\[0] + 1，表示删除这个i之后与T串相等的操作数。

 4.遍历顺序：
从上到下，从左到右



时间复杂度O(nm)；空间复杂度O(nm)



思路2：另一种动态规划：
只要求出两个字符串的**最长公共子序列长度**即可，那么除了最长公共子序列之外的字符都是必须删除的，最后用两个字符串的总长度减去两个最长公共子序列的长度就是删除的最少步数。

### 编辑距离

题目：72

思路：动态规划

这一题与上一题类似，对于原问题的定义都是类似的。问题是，如何理解动态数组的定义之后得到递推公式。

1.定义dp数组和下标含义：
dp[i]\[j]：表示长度为[0, i]的S串与长度为[0, j]的T串相同所需最小步数。

2.递推公式：
如果S[i] == T[j]，那么对于这个位置的字符不用再调整，只需要调整S串的[0, i - 1]部分和T串的[0, j - 1]部分，使得两者相同，那么长度为[0, i]的S串和长度为[0, j]的T串自然就相等了（将原问题转换为子问题），即dp[i - 1]\[j - 1]；
如果不等，那么可以采取三种操作：删除、插入、替换：
首先是删除：因为是让S串变成T串，所以如果第 i 个字符与T的第 j 个字符不等，那就尝试删除第 i 个字符，调整[0, i - 1]使得与[0, j]相等（换一个方向理解，自下而上去理解，就是如果经过调整之后[0, i - 1]S串与[0, j]T串相等，那么再删除第 i 个字符就可以使得[0, i]S串与T串相等），所以是dp[i - 1]\[j] + 1;
接着是添加：这里需要换一个角度理解，S串添加一个元素才能与T串相等，其实就是T串删除一个元素之后与S串相等。例如S串为a，T串为ab，那么S串添加一个字符的操作之后与T串相等，其实就相当于T串删除一个元素之后与S串相等。所以为dp[i]\[j - 1] + 1。自下而上理解就是，如果长度为[0, i]的S串经过调整之后与[0, j - 1]的T串已经相等，那么对于长度为[0, j]的T串来说只需再删除最后一个元素即可。
最后是替换：如果最后一个元素不相等，只需要令S串的最后一个元素替换成T串的最后一个元素即可，也就是假如经过调整之后[0, i - 1]已经与[0, j - 1]相等，那么只需再做一次替换操作就可以使得长度为[0, i]与长度为[0, j]相等，所以是dp[i - 1]\[j - 1] + 1。

3.初始化：
从递推公式可以看出依赖于左上、左边和上边元素，因此需要初始化第一行、第一列。
首先是dp[0]\[0]，如果相等就是0，否则就是执行一步替换操作为1。
首先是第一列：dp[i]\[0]，表示长度为[0, i]的S串最少经过多少次调整与一个字符T[0]相等。如果S[i]与T[0]相等，那么把[0, i-i]全部删除，操作数是 i；如果不等，那就只能从上面一个元素推出，也就是多进行一步删除操作。
最后是第一行：dp[0]\[j]，如果S[0]与T[j]相等，那么需要添加[0, j - 1]一共 j 个元素；如果不等，只能从前一个元素推出，多添加一个元素。

4.遍历顺序：
从前向后，从上到下



时间复杂度O(nm)；空间复杂度O(nm)

### 编辑距离总结

**判断子序列：**给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
这一道题原问题定义为S[0, i]和T[0, j]的子序列长度。如果最后一个字符相等，那么相同子序列长度加1；否则在T串中删除最后一个元素（自下而上理解，就是已知[0, i]与[0, j - 1]的最长子序列长度，如果S[i]与S[j]不相等，那么[0, i]和[0, j]的最长子序列与子问题相同）
状态转移方程：

```c++
if (t[i] == s[j]) dp[i][j] = dp[i - 1][j - 1] + 1;
else dp[i][j] = dp[i - 1][j];
```

**不同的子序列：**给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。
原问题定义不变。

```
当s[i - 1] 与 t[j - 1]相等时，dp[i][j]可以有两部分组成。
一部分是用s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]。
一部分是不用s[i - 1]来匹配，个数为dp[i - 1][j]。 相当于删除S串的最后一个元素。
这里可能有同学不明白了，为什么还要考虑 不用s[i - 1]来匹配，都相同了指定要匹配啊。
例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。
当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。
所以当s[i - 1] 与 t[j - 1]相等时，dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];


当s[i - 1] 与 t[j - 1]不相等时，dp[i][j]只有一部分组成，不用s[i - 1]来匹配，即：dp[i - 1][j]
所以递推公式为：dp[i][j] = dp[i - 1][j];

状态转移方程为：
if (s[i - 1] == t[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
} else {
    dp[i][j] = dp[i - 1][j];
}
```

**两个字符串的删除操作：**给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最少步数，每步可以删除任意一个字符串中的一个字符。
与上一题相比，就是两个字符串都可以进行删除操作



**编辑距离：**给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

```c++
if (word1[i - 1] == word2[j - 1])
    不操作
if (word1[i - 1] != word2[j - 1])
    增
    删
    换
```

### 回文子串

题目：647

思路1：暴力法：即遍历每一个字串，也就是使用双循环找到不同起点和不同终点的字串，再判断是否为回文串，这样时间复杂度为O(n ^ 3），大概率会超时

思路2：动态规划

1.确定dp数组：

如果定义原问题为以下标为 i 字符结尾的回文子串的数目，那么很难找到递归关系。

分析问题，如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230102170752.png" alt="img" style="zoom:67%;" />

我们在判断字符串S是否是回文，那么如果我们知道 s[1]，s[2]，s[3] 这个子串是回文的，那么只需要比较 s[0]和s[4]这两个元素是否相同，如果相同的话，这个字符串s 就是回文串。

那么此时我们是不是能找到一种递归关系，也就是判断一个子字符串（字符串的下表范围[i,j]）是否回文，依赖于，子字符串（下表范围[i + 1, j - 1]）） 是否是回文。

所以为了明确这种递归关系，我们的dp数组是要定义成一位二维dp数组。

布尔类型的dp[i]\[j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i]\[j]为true，否则为false。

2.递推公式：

如果S[i]与S[j]不等，那么一定不是回文串；
如果相等：首先判断 i 是否与 j 相等，也就是同一个字符，如果是就是回文字串；
接着判断i 与 j是否相差1，如果相差为1，那么也是回文串；
最后相差大于1的时候，需要根据dp[i + 1]\[j - 1]判断是否为回文串。

3.初始化：

初始化为false

4.遍历顺序：

由于依赖于左下角的元素，左移必须从下到上，从左到右

**注意因为dp[i]\[j]的定义，所以j一定是大于等于i的，那么在填充dp[i]\[j]的时候一定是只填充右上半部分**。

时间复杂度O(n ^ 2)；空间复杂度O(n ^ 2)



思路3：双指针法

动态规划的空间复杂度是偏高的，我们再看一下双指针法。

首先确定回文串，就是找中心然后向两边扩散看是不是对称的就可以了。

**在遍历中心点的时候，要注意中心点有两种情况**。

一个元素可以作为中心点，两个元素也可以作为中心点。

那么有人问了，三个元素还可以做中心点呢。其实三个元素就可以由一个元素左右添加元素得到，四个元素则可以由两个元素左右添加元素得到。

所以我们在计算的时候，要注意一个元素为中心点和两个元素为中心点的情况。

**这两种情况可以放在一起计算，但分别计算思路更清晰，我倾向于分别计算**，代码如下：

```cpp
class Solution {
public:
    int countSubstrings(string s) {
        int result = 0;
        for (int i = 0; i < s.size(); i++) {
            result += extend(s, i, i, s.size()); // 以i为中心
            result += extend(s, i, i + 1, s.size()); // 以i和i+1为中心
        }
        return result;
    }
    int extend(const string& s, int i, int j, int n) {
        int res = 0;
        while (i >= 0 && j < n && s[i] == s[j]) {
            i--;
            j++;
            res++;
        }
        return res;
    }
};
```

- 时间复杂度：O(n^2)
- 空间复杂度：O(1)

### 回文子序列

题目：516

思路：动态规划

1.dp数组定义
**字符串s在[i, j]范围内最长的回文子序列的长度为dp[i]\[j]**。

2.递推公式：
这里因为是子序列而不是字串，不要求连续，所以递推公式有所区别
如果 S[i]等于S[j]那么长度加2，即dp[i + 1]\[j - 1] + 2；
如果不等，说明同时加上两个字符不能增加长度，所以尝试单独加上一个：即dp[i]\[j] = max(dp[i + 1]\[j], dp[i]\[j - 1]);

3.初始化：首先要考虑当i 和j 相同的情况，从递推公式：dp[i]\[j] = dp[i + 1]\[j - 1] + 2; 可以看出 递推公式是计算不到 i 和j相同时候的情况。所以需要手动初始化一下，当i与j相同，那么dp[i]\[j]一定是等于1的，即：一个字符的回文子序列长度就是1。

其他情况dp[i][j]初始为0就行，这样递推公式：dp[i]\[j] = max(dp[i + 1]\[j], dp[i]\[j - 1]); 中dp[i]\[j]才不会被初始值覆盖。

4.遍历顺序：
从下到上，从左到右

时间复杂度O(n ^ 2)；空间复杂度O(n ^ 2)

### 动态规划总结

**动态规划基础：**
斐波那契数
爬楼梯
使用最小花费爬楼梯
不同路径
不同路径还不够，要有障碍！
整数拆分
不同的二叉搜索树



**背包问题：**
<img src="https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.png" alt="背包问题大纲" style="zoom: 50%;" />



**打家劫舍系列**



**股票系列：**
<img src="https://code-thinking.cdn.bcebos.com/pics/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.jpg" alt="股票问题总结" style="zoom:50%;" />



**子序列系列：**
<img src="https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.jpg" alt="img" style="zoom:50%;" />






## 图论

- dfs是可一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。
- bfs是先把本节点所连接的所有节点遍历一遍，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。

### 深度优先搜索

- 搜索方向，是认准一个方向搜，直到碰壁（在寻找A到B路径问题中就是到达目的地或者重新碰到路径）之后再换方向
- 换方向是撤销原路径，改为节点链接的下一个路径，回溯的过程。

二叉树的递归法其实就是dfs，而二叉树的迭代法，就是bfs

**回溯法代码框架：**

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

**深度优先算法代码框架：**

```c++
void dfs(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本节点所连接的其他节点) {
        处理节点;
        dfs(图，选择的节点); // 递归
        回溯，撤销处理结果
    }
}
```

1.确定递归函数、参数；另外需要二维数组数组结构保存**所有路径**，需要一维数组保存**单一路径**

2.确定终止条件：终止条件不仅是结束本层递归，同时也是我们收获结果的时候。

3.处理从目前搜索节点出发的路径：一般这里就是一个for循环的操作，去遍历 目前搜索节点 所能到的所有节点。

### 广度优先搜索

因为广搜是从起点出发，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。

大家应该好奇，这一圈一圈的搜索过程是怎么做到的，是放在什么容器里，才能这样去遍历。

很多网上的资料都是直接说用队列来实现。

其实，我们仅仅需要一个容器，能保存我们要遍历过的元素就可以，**那么用队列，还是用栈，甚至用数组，都是可以的**。

**用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针**。

因为队列是先进先出，加入元素和弹出元素的顺序是没有改变的。

**如果用栈的话，就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历**。

因为栈是先进后出，加入元素和弹出元素的顺序改变了。

那么广搜需要注意 转圈搜索的顺序吗？ 不需要！

所以用队列，还是用栈都是可以的，但大家都习惯用队列了，**所以下面的讲解用我也用队列来讲，只不过要给大家说清楚，并不是非要用队列，用栈也可以**。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220825102653.png" alt="图二" style="zoom:67%;" />

**代码框架：**

```c++
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向
// grid 是地图，也就是一个二维数组
// visited标记访问过的节点，不要重复访问
// x,y 表示开始搜索节点的下标
void bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
    queue<pair<int, int>> que; // 定义队列
    que.push({x, y}); // 起始节点加入队列
    visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点
    while(!que.empty()) { // 开始遍历队列里的元素
        pair<int ,int> cur = que.front(); que.pop(); // 从队列取元素
        int curx = cur.first;
        int cury = cur.second; // 当前节点坐标
        
        for (int i = 0; i < 4; i++) { // 开始想当前节点的四个方向左右上下去遍历
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 坐标越界了，直接跳过
            if (!visited[nextx][nexty]) { // 如果节点没被访问过
                que.push({nextx, nexty});  // 队列添加该节点为下一轮要遍历的节点
                visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问
            }
        }
    }

}
```

### 所有可能的路径

题目：797

采用DFS：

1.确定函数参数以及返回值：参数需要当前结点（因此需要整个数组和当前结点可以访问的下标）

2.确定终止条件：~~当前结点没有可以访问的结点时~~，（后面的循环也可以处理这种情况），当前结点就是第 n - 1下标的结点

3.单层处理逻辑：遍历当前结点可以访问的结点，如果没有在当前的路径中，就可以添加到路径中，然后继续DFS，DFS返回之后删除这个当前结点；~~如果在当前路径中，就直接跳过不能访问这个结点。~~因为题目说明是有向无环图，如果当前结点指向已经走过的路径，就会存在环，这与题目描述不符合。

### 岛屿的数量

题目：200

思路1：采用深度搜索：使用island表示当前的岛屿，使用result表示总的岛屿个数，使用一个二维数组表示网格哪些点已经被访问过。

1.递归的参数以及返回值：当前结点（行和列，以及网格）

2.终止条件：无

3.单层逻辑：遍历当前结点可以访问的结点（就是四个方向的结点）：如果可访问的结点是1并且没有被访问过，那么加入当前岛屿，并且设置已经被访问过，然后继续DFS这个新结点，最后回溯删除这个新结点。

在最外层选择一个没有被访问的岛屿开始，采用DFS遍历这个岛屿所有的附近岛屿，DFS出来之后周围岛屿都已经被访问过。此时可以记录一个岛屿。



思路2：采用广度优先搜索：使用队列维持当前结点的一层一层的节点数。

这里有一个广搜中很重要的细节：

根本原因是**只要 加入队列就代表 走过，就需要标记，而不是从队列拿出来的时候再去标记走过**。

如果从队列拿出节点，再去标记这个节点走过，就会发生下图所示的结果，会导致很多节点重复加入队列。

![图二](https://code-thinking-1253855093.file.myqcloud.com/pics/20220727100846.png)

（以目前队列中现有的结点为例子，如果新节点加入队列时没有标记，那么目前队列的结点**周围可访问结点中相互重叠的结点**会多次加入队列）









