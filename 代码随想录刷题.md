# 代码随想录

## 数组

### 二分查找

704.二分查找

35.搜索插入位置
34.在排序数组中查找元素的第一个和最后一个位置
69.x 的平方根
367.有效的完全平方数

收获：

1.二分查找法如果失败的话就是应该插入的位置。

2.除2可以用右移1表示。

3.$\sqrt{x}$使用二分法搜索表示为:$k^2\le x$，即搜索最大的整数值；

4.需要注意两个int值相乘的取值范围会超过int，应该使用long long。

### 移除元素

27.移除元素

26.删除排序数组中的重复项
283.移动零
844.比较含退格的字符串
977.有序数组的平方

收获：

1.数组双指针的思路。

### 有序数组的平方

收获：

昨天自己做的思路：找到绝对值最小的位置，左右指针从中间相两边，新的数组从小到大增加元素。

作者的思路：左右指针从最左边和最右边开始，新的数组从最后开始增加大的元素。

### 长度最小的子数组

209.长度最小的子数组

904.水果成篮
76.最小覆盖子串

收获：

主要是滑动窗口的应用。

需要思考：1.窗口里面是什么；2.窗口什么时候右移；3.窗口什么时候收缩。

### 螺旋矩阵

59.螺旋矩阵II

这是一种模型行为类型的题，看上去复杂，第一次遇到。

收获：循环不变量，即在一个循环中保持不变的量，比如二分法循环中不变的是左闭右开区间或者左闭右闭区间，比如简单选择排序中不变的是前i个元素是最小的。

### 总结

作者一共介绍了四种题型和方法，分别是二分法、双指针、滑动窗口、模拟操作（循环不变量）

## 链表

### 删除链表元素

题目：203

收获：删除元素应该先保存链表下一个结点的信息

### 设计链表

题目：707

收获：循环的时候注意循环体执行次数和循环判断条件的关系。

### 翻转链表

题目：206

思路就是使用双指针，值得注意的点就是注意删除操作顺序。

收获：重复的操作可以使用递归实现，，即不断对于两个结点进行翻转。

另一种形式的递归：每次都先翻转后面的链表，后面链表翻转完成之后再进行当前结点的翻转，注意这个递归返回的是最后一个节点值。

栈的思路：遍历一遍链表然后入栈，之后出栈即可。

或者采用头插法。

### 两两交换链表中的结点

题目：24

思路：使用双或者三指针，只需要注意更改next的顺序即可。

### 删除链表中的倒数第n个结点

题目：19

思路：第一个指针先走n步，接着第二个指针跟着第一个结点一起走到尾，就会指向第len-n+1也就是倒数第n个结点。

这题是删除倒数第n个，所以稍有变动。

并且虚拟头结点的好处就是对于第一个结点的操作与其他结点一样，没有虚拟头节点对于头结点的操作需要单独处理。

### 链表相交

题目160

思路：1.将链表A+链表B   链表B+链表A，使用两个指针遍历这两个链表，如果存在相交结点，那么一定相遇在空结点之前。

2.链表A+链表B，判断是否存在循环

作者的思路：求两个链表长度，总之与思路1一样

### 环形链表

题目：142

主要思路：1.使用快慢指针寻找相遇点；2.当第一次相遇时，令其中一个指针指向头结点，两个指针同速前进，再次相遇点就是环的起点。

有三个点：头结点、环的起点、相遇点，相遇点一定在环的起点之后（没到环的起点怎么相遇）。

假设相遇点时slow走了k，那么fast一定走了2k，也就是k一定是环的长度的n倍。

假设相遇点距离环的起点的距离为m，那么环的起点点距离头结点的距离为k-m；即从头结点走k-m到达环的起点。

假如从相遇点开始走，走k一定是重新到达相遇点，那么走k-m是到环的起点。

### 总结

链表的基础操作（删除、插入等）、双指针技巧、删除链表的元素可以删除该结点的后一个元素、环型链表的处理



## 哈希表

主要用于需要判断一个元素是否存在一个数组中时。

### 有效的字母异位词

242.有效的字母异位词

383.赎金信

49.字母异位词分组

438.找到字符串中所有字母异位词

收获：hash表（map）的键值可以是任何东西。比如49题中把string作为键，把列表作为值。

438复习了滑动窗口的使用。



### 两个数组的交集

349.两个数组的交集

350.两个数组的交集 II

收获：主要是set和map的使用，其中set好像更慢一点。

### 快乐数

第202题. 快乐数

收获：学会使用unorder_set

### 两数之和

第1题：两数之和

收获：

- 为什么会想到用哈希表：当需要判断一个元素是否存在时
- 哈希表为什么用map：因为数组的下标只能是int，set没有下标，map用于存一个映射。
- 本题map是用来存什么的：key存target - nums1（第一个加数） value存这个数对应的下标
- map中的key和value用来存什么的

### 四数相加

第454题：

收获：要找的是加数 + 加数 + 加数 + 加数 = 0出现的次数，因此map的key应该是加数，value是出现的次数。

### 赎金信

第383

收获：之前做过，这里由于hash表的长度是固定的（26个小写字母），所以使用数组更加合适。**map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的**

### 三数之和

第15

对于自己来说难以理解：1.hash思路有，但是由于题目中要求不能重复，难以完成。（待完成）

2.使用双指针，先把数组排序，然后需要注意的是：（1）.去重的逻辑：去重a：应该判断与之前的元素是否相同，由于是排序之后的，如果相同说明要么都找不到，要么找到也是重复的；去重bc，在找到第一对bc之后，应该重复判断与他们相邻的是否相等，相等就应该去重。（2）.找到之后两个指针同时跳变

### 四数之和

18

思路：就是在三数之和的基础上加层循环

但是需要注意的是：剪枝的一些细节，比如由于target是一个随机值，不能判断第一个元素大于零就直接返回，因为有可能target是小于第一个元素的。

错误：我的思路是两个双指针，错误的地方是：外层如果用双指针，那么当双指针同时增加时，会漏掉什么元素？？？

这个问题与之前遇到的同时增加的

思考：我的思路：从外层选两个，从内层选两个，

作者的思路：从n个中选一个，从剩下的n-1个中选一个，然后双指针选择剩下的两个

注意：两种方式：（1）从n中选一个，从剩下的n-1中选一个，一共有n(n-1)/2中组合

（2）我的两个指针同时从前后增加，那么只有n/2种组合

而题目明显是要求第一种方式选择，不要漏掉组合。

注意：双指针是如何把从n中选两个的时间复杂度变成n的？

（1）从n中选两个不同的，正常思路就是n的平方；

（2）如果采用双指针，O(n^2)的解法优化为 O(n)的解法，因为一次选中不同的两个？

### 总结

**一般来说哈希表都是用来快速判断一个元素是否出现集合里**。

哈希函数是把传入的key映射到符号表的索引上。

接下来是常见的三种哈希结构：

- 数组
- set（集合）
- map（映射）

**使用set的理由：**

**主要因为如下两点：**

- 数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。
- 如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

**使用map的理由：**

- 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
- set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。

C++提供如下三种map：

- std::map
- std::multimap
- std::unordered_map

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

std::unordered_map 底层实现为哈希，std::map 和std::multimap 的底层实现是红黑树。

在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。

虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。

同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解），[1.两数之和 (opens new window)](https://programmercarl.com/0001.两数之和.html)中并不需要key有序，选择std::unordered_map 效率更高！

## 字符串

**如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。**

### 反转字符串1

题目：第344题

思路：双指针

### 反转字符串2

题目：第341

我的思路：每次取前2k个，用i=1，2，3去乘2k

作者的思路：直接取每个区间的起点，i=0， 2k，

然后在循环中判断i + k是否超过最后字符串结尾即可。

### 替换空格

剑指Offer 05.替换空格

思路：**其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

这么做有两个好处：

1. 不用申请新数组。
2. 从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。

### 151.翻转字符串里的单词

思路1：保存每个字符串并存入栈结构，最后再出栈，这样存储空间是O(n)

思路2：去除多余的空格、翻转整个字符串、翻转单个字符串，存储空间是O(1)

### 左旋转字符串

题目：剑指Offer58-II.左旋转字符串

思路：（原地修改）旋转整个字符串、旋转左半字符串、旋转右半字符串

### 旋转字符串回顾

此时我们已经反转好多次字符串了，来一起回顾一下吧。

在这篇文章344.反转字符串 ，第一次讲到反转一个字符串应该怎么做，使用了双指针法。

然后发现541. 反转字符串II ，这里开始给反转加上了一些条件，当需要固定规律一段一段去处理字符串的时候，要想想在for循环的表达式上做做文章。

后来在151.翻转字符串里的单词 中，要对一句话里的单词顺序进行反转，发现先整体反转再局部反转 是一个很妙的思路。

最后再讲到本题，本题则是先局部反转再 整体反转，与151.翻转字符串里的单词 类似，但是也是一种新的思路。

### 实现KMP算法

复习KMP算法，和作者的不一样

主要是理解思路

### 重复的子字符串

题目：第459题

思路1：O(n^2)，字串的长度一定是s的整数倍，并且假设字串长度为i，那么任意的j > i，都有s[j] == s[j - i]

思路2：利用两个s拼接在一起，一定能从中间找到s，因为如果是由重复字符串构成的话，中间的一部分一定是s。但是不能两端找到字串s，因为就是由两个s组成的。

时间复杂度为KMP算法O(m+n)，空间复杂度为O(n)

思路3：在由重复子串组成的字符串中，最长相等前后缀不包含的子串就是最小重复子串

KMP算法的next数组其实就是最长前缀和最长后缀的概念，只不过我在实现的时候是求不包括当前字符的前缀长度

前缀和后缀的概念：

前缀：是指不包含最后一个字符的所有以第一个字符开头的连续子串

后缀：是指不包含第一个字符的所有以最后一个字符结尾的连续子串

作者求的是当前字符的前后缀长度，与我不同，所以作者遇到当前字符不同时，需要查找前一个字符的next值，我要找当前字符的next值，其实是一样的.

只不过作者引入了-1，我不想看了。

### 总结

双指针法、翻转再翻转、KMP

## 栈与队列

### 用栈实现队列

题目：232

思路：栈1用于输入，当输出时需要将所有元素入栈2，这样栈1的栈底元素就是栈2的栈顶元素。

收获：peek用到了pop函数，即实现了代码复用。

在代码开发时一定要注意复用，忌讳实现类似的函数，即把一段代码复制粘贴稍微修改。



### 使用队列实现栈

题目：225

思路1：哪个队列不为空就入哪个队列（如果都为空随便入）；出队就是将有元素的队列的前面所有元素入另一个队列，最后一个元素为出队元素

收获：作者提供使用一个队列的思路，即每次出队时候都再次入队。

### 有效的括号

题目：20.有效的括号

思路：使用栈完成匹配

### 删除字符串中的所有相邻重复项

题目：1047

思路：使用栈完成匹配

收获：1.string的构造函数，并且string的长度不计算空字符

2.**递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中**，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。

**在企业项目开发中，尽量不要使用递归**！在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），**造成栈溢出错误（这种问题还不好排查！）**

### 逆波兰表达式求值

题目：150

思路：使用栈存储数据，当遇到运算符时就出栈两个元素并将结果入栈。

收获：1.**逆波兰表达式相当于是二叉树中的后序遍历**。 大家可以把运算符作为中间节点，按照后序遍历的规则画出一个二叉树。

2.stoi、stol、stoll函数：在头文件string中，将字符串转换为int、long、long long类型的整数。

int stoi(const std::string& str, std::size_t* pos = 0, int base = 10);

注意默认base是10。

### 滑动窗口最大值

题目：239. 滑动窗口最大值

思路：我原本的思路是使用一个队列保存窗口元素，因为要求当前队列最大值，所以需要对队列进行排序，但是排序之后就无法按照原始顺序弹出元素。

收获：

1.作者给出的思路是：并不需要保持所有元素，而是保持一个单调队列，即还是按照原始顺序，但是保持最大元素在队列头，并且按照单调递减的顺序保留数据，删除其他元素。这样保持一个单调队列，push和pop方法改为：

1.pop(value):如果要弹出的元素不是头元素，那么队列不做任何操作

2.push(value):入队时与队尾元素相比，如果队尾更小，就从队尾弹出元素，保持是一个单调的状态。并且从队尾进页保持了原始顺序。

这个队列是按照原始顺序进队和出队的，只是由于最大值不同队列内元素个数不同。

2.了解双端队列dequeue

### 前 K 个高频元素

题目：347.前 K 个高频元素

收获：1.优先级队列表示大顶堆、小顶堆

2.使用小顶堆删除最小的，保留下来的就是k个最大的。

### 总结

在栈与队列系列中，我们强调栈与队列的基础，也是很多同学容易忽视的点。

使用抽象程度越高的语言，越容易忽视其底层实现，而C++相对来说是比较接近底层的语言。

我们用栈实现队列，用队列实现栈来掌握的栈与队列的基本操作。

接着，通过括号匹配问题、字符串去重问题、逆波兰表达式问题来系统讲解了栈在系统中的应用，以及使用技巧。

通过求滑动窗口最大值，以及前K个高频元素介绍了两种队列：单调队列和优先级队列，这是特殊场景解决问题的利器，是一定要掌握的。

## 二叉树

### 二叉树简介

满二叉树、完全二叉树、二叉查找树（搜索树）、平衡二叉搜索树

二叉树存储结构：顺序存储（如果双亲结点是i那么左孩子是2\*i + 1，右孩子是2\*i + 2)和链式存储

题目：2两数相加

思路：模拟加法进位

### 二叉树递归遍历

递归的方法：

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

144.二叉树的前序遍历(opens new window)
145.二叉树的后序遍历(opens new window)
94.二叉树的中序遍历

### 二叉树迭代遍历

前序遍历：使用栈实现

前序处理的方式是：根、左、右，因此向将根节点放入栈、右孩子进入栈、最后左孩子进入栈

**访问和处理的顺序是一致的。**前序遍历的访问顺序是中左右，处理的顺序也是中左右。

```
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // 中
            st.pop();
            result.push_back(node->val);
            if (node->right) st.push(node->right);           // 右（空节点不入栈）
            if (node->left) st.push(node->left);             // 左（空节点不入栈）
        }
        return result;
    }
};
```

中序遍历：处理顺序是中左右，但是访问顺序是一直访问到左孩子结点为空时才会访问中结点，接着以右孩子作为新的根结点。

因此借助指针来访问，使用栈处理。

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```

后序遍历：

将前序遍历稍微修改：前序遍历是中左右->中右左->逆序->左右中

即逆序。

```
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->right) st.push(node->right); // 空节点不入栈
        }
        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
        return result;
    }
};
```

### 二叉树统一迭代法

以中序遍历为例，**将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**要处理的结点放入栈之后，需要加上一个空结点。

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode *> st;
        vector<int> res;

        // 根节入栈
        if (root != nullptr) st.push(root);

        while (!st.empty()) {
            TreeNode *node = st.top();

            if (node != nullptr) {
                // 先将这个结点弹出
                st.pop();

                // 尝试将右孩子入栈
                if (node->right != nullptr) st.push(node->right);
                // 将中结点入栈，并且中间结点已经访问过，作为下一次处理的结点需要标记
                st.push(node);
                st.push(nullptr);

                // 最后将左孩子入栈但是不标记
                if (node->left != nullptr) st.push(node->left);
            } else {
                // 如果栈顶是空指针，说明下一个是需要处理的结点
                st.pop();

                // 将需要处理的结点假如列表
                res.push_back(st.top()->val);
                st.pop();
            }
        }

        return res;
    }
};
```

前序遍历和后序遍历只需要改变左右孩子、中间结点进入栈的顺序即可。

### 二叉树层序遍历

思路1：我的思路是为每层后面加一个空结点标识，当遇到空结点说明上一层处理完了，同时也要在队列中加一个空结点标识现在队列中是一层。

作者的思路1：当队列不为空时，每次处理一层，使在每次循环最开始记录当前队列多少元素，即为当前层数。然后使用for循环处理这size个结点即可。

作者的思路2：使用深度优先遍历，递归的方式，每次处理完根节点之后，接着递归处理左右孩子。

递归参数：当前根结点，保存访问记录的列表，当前深度（因为一层使用一个列表表示，因此需要知道当前深度应该加到哪个列表中）

递归终止条件：当前根结点为空

一层递归逻辑：处理当前根结点，接着处理左右孩子。

题目：

102.二叉树的层序遍历
107.二叉树的层次遍历II
199.二叉树的右视图

20230526：

637.二叉树的层平均值
429.N叉树的层序遍历
515.在每个树行中找最大值



















